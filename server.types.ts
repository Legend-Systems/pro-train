/*
 * Auto-generated types from server codebase
 * Generated on: 2025-06-01T14:33:34.360Z
 * Generator: SuperDetailedTypeExtractor v2.0
 * 
 * This file contains comprehensive type definitions extracted from the server
 * including DTOs, entities, interfaces, enums, decorators, and metadata
 * 
 * Statistics:
 * - Files Processed: 188
 * - Total Lines Analyzed: 45,853
 * - Dependencies: 306
 * - Errors: 0
 * - Warnings: 0
 */

// ==========================================
// EXTERNAL DEPENDENCIES
// ==========================================

/*
 * External dependencies found in the codebase:
 * - ../../answers/entities/answer.entity
 * - ../../auth/decorators/org-branch-scope.decorator
 * - ../../branch/entities/branch.entity
 * - ../../common/events
 * - ../../course/entities/course.entity
 * - ../../leaderboard/dto/user-stats-response.dto
 * - ../../leaderboard/entities/leaderboard.entity
 * - ../../media-manager/entities/media-manager.entity
 * - ../../org/entities/org.entity
 * - ../../questions/entities/question.entity
 * - ../../results/entities/result.entity
 * - ../../test/entities/test.entity
 * - ../../test_attempts/entities/test_attempt.entity
 * - ../../training_progress/entities/training_progress.entity
 * - ../../user/entities/user.entity
 * - ../answers/answers.module
 * - ../answers/answers.service
 * - ../answers/entities/answer.entity
 * - ../auth/auth.module
 * - ../auth/decorators/get-user.decorator
 * - ../auth/decorators/org-branch-scope.decorator
 * - ../auth/interfaces/authenticated-request.interface
 * - ../auth/jwt-auth.guard
 * - ../auth/services/org-branch-scoping.service
 * - ../branch/dto/create-branch.dto
 * - ../branch/dto/update-branch.dto
 * - ../branch/entities/branch.entity
 * - ../common/events
 * - ../communications.service
 * - ../communications/communications.module
 * - ../communications/entities/communication.entity
 * - ../communications/services/email-queue.service
 * - ../communications/services/email-template.service
 * - ../course/course.module
 * - ../course/course.service
 * - ../course/entities/course.entity
 * - ../dto/course-analytics.dto
 * - ../dto/leaderboard-analytics.dto
 * - ../dto/results-analytics.dto
 * - ../dto/test-analytics.dto
 * - ../dto/training-progress-analytics.dto
 * - ../dto/user-analytics.dto
 * - ../entities/branch.entity
 * - ../entities/communication.entity
 * - ../entities/course-material.entity
 * - ../entities/media-manager.entity
 * - ../entities/question.entity
 * - ../entities/test.entity
 * - ../entities/test_attempt.entity
 * - ../entities/user.entity
 * - ../interfaces/authenticated-request.interface
 * - ../interfaces/email-config.interface
 * - ../interfaces/template.interface
 * - ../leaderboard/dto/user-stats-response.dto
 * - ../leaderboard/entities/leaderboard.entity
 * - ../leaderboard/leaderboard.module
 * - ../leaderboard/leaderboard.service
 * - ../media-manager/entities/media-manager.entity
 * - ../questions/entities/question.entity
 * - ../questions/questions.module
 * - ../questions/questions.service
 * - ../questions_options/entities/questions_option.entity
 * - ../questions_options/questions_options.module
 * - ../questions_options/questions_options.service
 * - ../results/entities/result.entity
 * - ../results/results.module
 * - ../results/results.service
 * - ../test/entities/test.entity
 * - ../test/test.module
 * - ../test/test.service
 * - ../test_attempts/entities/test_attempt.entity
 * - ../training_progress/entities/training_progress.entity
 * - ../user/dto/common-response.dto
 * - ../user/dto/create-user.dto
 * - ../user/dto/refresh-token.dto
 * - ../user/dto/resend-verification.dto
 * - ../user/dto/session-response.dto
 * - ../user/dto/sign-in.dto
 * - ../user/dto/verify-email.dto
 * - ../user/entities/user.entity
 * - ../user/user.module
 * - ../user/user.service
 * - ./answers.controller
 * - ./answers.service
 * - ./answers/answers.module
 * - ./answers/entities/answer.entity
 * - ./app.controller
 * - ./app.module
 * - ./app.service
 * - ./auth.controller
 * - ./auth.service
 * - ./auth/auth.module
 * - ./branch.controller
 * - ./branch.service
 * - ./branch/branch.module
 * - ./communications.controller
 * - ./communications.service
 * - ./communications/communications.module
 * - ./communications/entities/communication.entity
 * - ./course-materials.controller
 * - ./course-materials.service
 * - ./course-materials/course-materials.module
 * - ./course-materials/entities/course-material.entity
 * - ./course.controller
 * - ./course.service
 * - ./course/course.module
 * - ./course/entities/course.entity
 * - ./create-answer.dto
 * - ./create-branch.dto
 * - ./create-communication.dto
 * - ./create-course-material.dto
 * - ./create-course.dto
 * - ./create-leaderboard.dto
 * - ./create-org.dto
 * - ./create-question.dto
 * - ./create-questions_option.dto
 * - ./create-result.dto
 * - ./create-test.dto
 * - ./create-training_progress.dto
 * - ./create-user.dto
 * - ./dto/answer-response.dto
 * - ./dto/assign-org-branch.dto
 * - ./dto/bulk-answers.dto
 * - ./dto/bulk-create-options.dto
 * - ./dto/bulk-create-questions.dto
 * - ./dto/change-password.dto
 * - ./dto/common-response.dto
 * - ./dto/course-analytics.dto
 * - ./dto/course-filter.dto
 * - ./dto/course-material-response.dto
 * - ./dto/course-response.dto
 * - ./dto/create-answer.dto
 * - ./dto/create-communication.dto
 * - ./dto/create-course-material.dto
 * - ./dto/create-course.dto
 * - ./dto/create-leaderboard.dto
 * - ./dto/create-org.dto
 * - ./dto/create-question.dto
 * - ./dto/create-questions_option.dto
 * - ./dto/create-result.dto
 * - ./dto/create-test.dto
 * - ./dto/create-test_attempt.dto
 * - ./dto/create-training_progress.dto
 * - ./dto/create-user.dto
 * - ./dto/forgot-password.dto
 * - ./dto/leaderboard-analytics.dto
 * - ./dto/leaderboard-response.dto
 * - ./dto/mark-answer.dto
 * - ./dto/media-response.dto
 * - ./dto/question-filter.dto
 * - ./dto/question-list-response.dto
 * - ./dto/question-option-list-response.dto
 * - ./dto/question-option-response.dto
 * - ./dto/question-response.dto
 * - ./dto/reset-password.dto
 * - ./dto/result-analytics.dto
 * - ./dto/result-detail.dto
 * - ./dto/result-filter.dto
 * - ./dto/result-list-response.dto
 * - ./dto/result-response.dto
 * - ./dto/results-analytics.dto
 * - ./dto/send-invitation.dto
 * - ./dto/test-analytics.dto
 * - ./dto/test-attempt-filter.dto
 * - ./dto/test-attempt-list-response.dto
 * - ./dto/test-attempt-response.dto
 * - ./dto/test-attempt-stats.dto
 * - ./dto/test-filter.dto
 * - ./dto/test-response.dto
 * - ./dto/training-progress-analytics.dto
 * - ./dto/training-progress-response.dto
 * - ./dto/update-answer.dto
 * - ./dto/update-branch.dto
 * - ./dto/update-communication.dto
 * - ./dto/update-course-material.dto
 * - ./dto/update-course.dto
 * - ./dto/update-org.dto
 * - ./dto/update-question.dto
 * - ./dto/update-questions_option.dto
 * - ./dto/update-test.dto
 * - ./dto/update-test_attempt.dto
 * - ./dto/update-training_progress.dto
 * - ./dto/update-user.dto
 * - ./dto/upload-file.dto
 * - ./dto/user-analytics.dto
 * - ./dto/validate-invitation.dto
 * - ./email-queue.service
 * - ./email-smtp.service
 * - ./email-template.service
 * - ./entities/answer.entity
 * - ./entities/branch.entity
 * - ./entities/communication.entity
 * - ./entities/course-material.entity
 * - ./entities/course.entity
 * - ./entities/leaderboard.entity
 * - ./entities/media-manager.entity
 * - ./entities/org.entity
 * - ./entities/question.entity
 * - ./entities/questions_option.entity
 * - ./entities/result.entity
 * - ./entities/test.entity
 * - ./entities/test_attempt.entity
 * - ./entities/training_progress.entity
 * - ./entities/user.entity
 * - ./interfaces/authenticated-request.interface
 * - ./interfaces/template.interface
 * - ./jwt-auth.guard
 * - ./jwt.strategy
 * - ./leaderboard-response.dto
 * - ./leaderboard.controller
 * - ./leaderboard.service
 * - ./leaderboard/entities/leaderboard.entity
 * - ./leaderboard/leaderboard.module
 * - ./listeners/email.listener
 * - ./media-manager.controller
 * - ./media-manager.service
 * - ./media-manager/entities/media-manager.entity
 * - ./media-manager/media-manager.module
 * - ./org.controller
 * - ./org.service
 * - ./org/org.module
 * - ./question-option-response.dto
 * - ./question-response.dto
 * - ./questions.controller
 * - ./questions.service
 * - ./questions/entities/question.entity
 * - ./questions/questions.module
 * - ./questions_options.controller
 * - ./questions_options.service
 * - ./questions_options/entities/questions_option.entity
 * - ./questions_options/questions_options.module
 * - ./reports.controller
 * - ./reports/reports.module
 * - ./result-response.dto
 * - ./results.controller
 * - ./results.service
 * - ./results/entities/result.entity
 * - ./results/results.module
 * - ./services/course-reports.service
 * - ./services/email-config.service
 * - ./services/email-queue.service
 * - ./services/email-smtp.service
 * - ./services/email-template.service
 * - ./services/leaderboard-reports.service
 * - ./services/org-branch-scoping.service
 * - ./services/results-reports.service
 * - ./services/template-testing.service
 * - ./services/test-reports.service
 * - ./services/training-progress-reports.service
 * - ./services/user-reports.service
 * - ./test-attempt-response.dto
 * - ./test.controller
 * - ./test.service
 * - ./test/entities/test.entity
 * - ./test/test.module
 * - ./test_attempts.controller
 * - ./test_attempts.service
 * - ./test_attempts/entities/test_attempt.entity
 * - ./test_attempts/test_attempts.module
 * - ./token-manager.service
 * - ./training_progress.controller
 * - ./training_progress.service
 * - ./training_progress/entities/training_progress.entity
 * - ./training_progress/training_progress.module
 * - ./user.controller
 * - ./user.service
 * - ./user/entities/user.entity
 * - ./user/user.module
 * - @google-cloud/storage
 * - @nestjs/cache-manager
 * - @nestjs/common
 * - @nestjs/config
 * - @nestjs/core
 * - @nestjs/event-emitter
 * - @nestjs/jwt
 * - @nestjs/mapped-types
 * - @nestjs/passport
 * - @nestjs/platform-express
 * - @nestjs/swagger
 * - @nestjs/throttler
 * - @nestjs/typeorm
 * - bcrypt
 * - cache-manager
 * - class-transformer
 * - class-validator
 * - crypto
 * - express
 * - fs/promises
 * - handlebars
 * - helmet
 * - nodemailer
 * - nodemailer/lib/smtp-transport
 * - passport-jwt
 * - path
 * - sharp
 * - src/answers/entities/answer.entity
 * - src/course-materials/entities/course-material.entity
 * - src/course/entities/course.entity
 * - src/leaderboard/entities/leaderboard.entity
 * - src/questions/entities/question.entity
 * - src/results/entities/result.entity
 * - src/test/entities/test.entity
 * - src/test_attempts/entities/test_attempt.entity
 * - src/training_progress/entities/training_progress.entity
 * - typeorm
 * - uuid
 */

// ==========================================
// ENUMS (14 total)
// ==========================================

/*
 * Enum #1: EmailType
 * Source: communications/entities/communication.entity.ts:22
 * Type: String Enum
 * Values: 15
 * Size: 612 characters
 */
export enum EmailType {
    WELCOME = 'welcome',
    WELCOME_ORGANIZATION = 'welcome_organization',
    WELCOME_BRANCH = 'welcome_branch',
    WELCOME_USER = 'welcome_user',
    PASSWORD_RESET = 'password_reset',
    PASSWORD_CHANGED = 'password_changed',
    EMAIL_VERIFICATION = 'email_verification',
    TEST_NOTIFICATION = 'test_notification',
    RESULTS_SUMMARY = 'results_summary',
    COURSE_ENROLLMENT = 'course_enrollment',
    COURSE_CREATED = 'course_created',
    USER_DEACTIVATED = 'user_deactivated',
    USER_RESTORED = 'user_restored',
    SYSTEM_ALERT = 'system_alert',
    CUSTOM = 'custom',
}

/*
 * Enum #2: EmailStatus
 * Source: communications/entities/communication.entity.ts:40
 * Type: String Enum
 * Values: 8
 * Size: 217 characters
 */
export enum EmailStatus {
    PENDING = 'pending',
    QUEUED = 'queued',
    SENDING = 'sending',
    SENT = 'sent',
    FAILED = 'failed',
    BOUNCED = 'bounced',
    DELIVERED = 'delivered',
    RETRY = 'retry',
}

/*
 * Enum #3: EmailJobPriority
 * Source: communications/services/email-queue.service.ts:43
 * Type: Numeric Enum
 * Values: 14
 * Size: 262 characters
 */
export enum EmailJobPriority {
    CRITICAL = 1, // System alerts, password resets
    HIGH = 2, // Welcome emails, urgent notifications
    NORMAL = 3, // Regular notifications
    LOW = 4, // Marketing emails, newsletters
    BULK = 5, // Mass communications
}

/*
 * Enum #4: MaterialType
 * Source: course-materials/entities/course-material.entity.ts:19
 * Type: String Enum
 * Values: 9
 * Size: 243 characters
 */
export enum MaterialType {
    PDF = 'pdf',
    VIDEO = 'video',
    AUDIO = 'audio',
    DOCUMENT = 'document',
    LINK = 'link',
    IMAGE = 'image',
    PRESENTATION = 'presentation',
    SPREADSHEET = 'spreadsheet',
    OTHER = 'other',
}

/*
 * Enum #5: LeaderboardPeriod
 * Source: leaderboard/dto/leaderboard-filter.dto.ts:13
 * Type: String Enum
 * Values: 3
 * Size: 100 characters
 */
export enum LeaderboardPeriod {
    WEEK = 'week',
    MONTH = 'month',
    ALL_TIME = 'all-time',
}

/*
 * Enum #6: LeaderboardSortBy
 * Source: leaderboard/dto/leaderboard-filter.dto.ts:19
 * Type: String Enum
 * Values: 5
 * Size: 188 characters
 */
export enum LeaderboardSortBy {
    RANK = 'rank',
    SCORE = 'totalScore',
    TESTS_COMPLETED = 'testsCompleted',
    AVERAGE_SCORE = 'averageScore',
    LAST_UPDATED = 'lastUpdated',
}

/*
 * Enum #7: SortOrder
 * Source: leaderboard/dto/leaderboard-filter.dto.ts:27
 * Type: String Enum
 * Values: 2
 * Size: 61 characters
 */
export enum SortOrder {
    ASC = 'ASC',
    DESC = 'DESC',
}

/*
 * Enum #8: MediaType
 * Source: media-manager/entities/media-manager.entity.ts:23
 * Type: String Enum
 * Values: 5
 * Size: 136 characters
 */
export enum MediaType {
    IMAGE = 'image',
    DOCUMENT = 'document',
    VIDEO = 'video',
    AUDIO = 'audio',
    OTHER = 'other',
}

/*
 * Enum #9: ImageVariant
 * Source: media-manager/entities/media-manager.entity.ts:31
 * Type: String Enum
 * Values: 4
 * Size: 128 characters
 */
export enum ImageVariant {
    ORIGINAL = 'original',
    THUMBNAIL = 'thumbnail',
    MEDIUM = 'medium',
    LARGE = 'large',
}

/*
 * Enum #10: QuestionType
 * Source: questions/entities/question.entity.ts:18
 * Type: String Enum
 * Values: 5
 * Size: 193 characters
 */
export enum QuestionType {
    MULTIPLE_CHOICE = 'multiple_choice',
    TRUE_FALSE = 'true_false',
    SHORT_ANSWER = 'short_answer',
    ESSAY = 'essay',
    FILL_IN_BLANK = 'fill_in_blank',
}

/*
 * Enum #11: TestType
 * Source: test/entities/test.entity.ts:29
 * Type: String Enum
 * Values: 3
 * Size: 89 characters
 */
export enum TestType {
    EXAM = 'exam',
    QUIZ = 'quiz',
    TRAINING = 'training',
}

/*
 * Enum #12: AttemptStatus
 * Source: test_attempts/entities/test_attempt.entity.ts:25
 * Type: String Enum
 * Values: 4
 * Size: 145 characters
 */
export enum AttemptStatus {
    IN_PROGRESS = 'in_progress',
    SUBMITTED = 'submitted',
    EXPIRED = 'expired',
    CANCELLED = 'cancelled',
}

/*
 * Enum #13: UserRole
 * Source: user/entities/user.entity.ts:24
 * Type: String Enum
 * Values: 4
 * Size: 110 characters
 */
export enum UserRole {
    BRANDON = 'brandon',
    OWNER = 'owner',
    ADMIN = 'admin',
    USER = 'user',
}

/*
 * Enum #14: UserStatus
 * Source: user/entities/user.entity.ts:31
 * Type: String Enum
 * Values: 4
 * Size: 130 characters
 */
export enum UserStatus {
    ACTIVE = 'active',
    INACTIVE = 'inactive',
    DELETED = 'deleted',
    SUSPENDED = 'suspended',
}

// ==========================================
// INTERFACES (40 total)
// ==========================================

/*
 * Interface #1: SystemInfo
 * Source: app.service.ts:3
 * Properties: 9
 * Complexity: 10
 * Size: 242 characters
 */
export interface SystemInfo {
    name: string;
    version: string;
    description: string;
    features: string[];
    modules: {
        name: string;
        status: string;
        description: string;
        endpoints: string[];
    }

/*
 * Interface #2: OrgBranchScope
 * Source: auth/decorators/org-branch-scope.decorator.ts:4
 * Properties: 3
 * Complexity: 4
 * Size: 98 characters
 */
export interface OrgBranchScope {
    orgId?: string;
    branchId?: string;
    userId: string;
}

/*
 * Interface #3: AuthenticatedUser
 * Source: auth/interfaces/authenticated-request.interface.ts:3
 * Properties: 11
 * Complexity: 12
 * Size: 290 characters
 */
export interface AuthenticatedUser {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    avatar?: {
        id: number;
        originalName?: string;
        url?: string;
        thumbnail?: string;
        medium?: string;
        original?: string;
    }

/*
 * Interface #4: AuthenticatedRequest
 * Source: auth/interfaces/authenticated-request.interface.ts:20
 * Properties: 1
 * Complexity: 2
 * Size: 86 characters
 * Extends: Request
 */
export interface AuthenticatedRequest extends Request {
    user: AuthenticatedUser;
}

/*
 * Interface #5: JwtPayload
 * Source: auth/jwt.strategy.ts:7
 * Properties: 8
 * Complexity: 9
 * Size: 191 characters
 */
export interface JwtPayload {
    sub: string;
    email: string;
    firstName: string;
    lastName: string;
    orgId?: string;
    branchId?: string;
    iat?: number;
    exp?: number;
}

/*
 * Interface #6: ScopeOptions
 * Source: auth/services/org-branch-scoping.service.ts:12
 * Properties: 3
 * Complexity: 4
 * Size: 156 characters
 */
export interface ScopeOptions {
    orgId?: string;
    branchId?: string;
    includeGlobal?: boolean; // Include records without org/branch restrictions
}

/*
 * Interface #7: TokenPayload
 * Source: auth/token-manager.service.ts:6
 * Properties: 8
 * Complexity: 9
 * Size: 193 characters
 */
export interface TokenPayload {
    sub: string;
    email: string;
    firstName: string;
    lastName: string;
    orgId?: string;
    branchId?: string;
    iat?: number;
    exp?: number;
}

/*
 * Interface #8: TokenPair
 * Source: auth/token-manager.service.ts:17
 * Properties: 3
 * Complexity: 4
 * Size: 104 characters
 */
export interface TokenPair {
    accessToken: string;
    refreshToken: string;
    expiresIn: number;
}

/*
 * Interface #9: SpecialTokenData
 * Source: auth/token-manager.service.ts:23
 * Properties: 9
 * Complexity: 10
 * Size: 394 characters
 */
export interface SpecialTokenData {
    userId: string;
    email: string;
    type: 'password_reset' | 'email_verification' | 'invitation';
    expiresAt: number;
    createdAt: number;
    inviterUserId?: string; // For invitation tokens
    inviterName?: string; // For invitation tokens
    organizationId?: string; // For invitation tokens
    branchId?: string; // For invitation tokens
}

/*
 * Interface #10: OperatingHours
 * Source: branch/entities/branch.entity.ts:18
 * Properties: 3
 * Complexity: 4
 * Size: 97 characters
 */
export interface OperatingHours {
    opening: string;
    closing: string;
    days: string[];
}

/*
 * Interface #11: EmailConfig
 * Source: communications/interfaces/email-config.interface.ts:1
 * Properties: 7
 * Complexity: 8
 * Size: 189 characters
 */
export interface EmailConfig {
    smtp: {
        host: string;
        port: number;
        secure: boolean;
        auth: {
            user: string;
            pass: string;
        }

/*
 * Interface #12: EmailSendOptions
 * Source: communications/interfaces/email-config.interface.ts:35
 * Properties: 9
 * Complexity: 10
 * Size: 262 characters
 */
export interface EmailSendOptions {
    to: string | string[];
    from?: string;
    subject: string;
    html?: string;
    text?: string;
    attachments?: Array<{
        filename: string;
        content: Buffer | string;
        contentType?: string;
    }

/*
 * Interface #13: TemplateData
 * Source: communications/interfaces/email-config.interface.ts:50
 * Properties: 1
 * Complexity: 2
 * Size: 57 characters
 */
export interface TemplateData {
    [key: string]: any;
}

/*
 * Interface #14: EmailResult
 * Source: communications/interfaces/email-config.interface.ts:54
 * Properties: 4
 * Complexity: 5
 * Size: 121 characters
 */
export interface EmailResult {
    success: boolean;
    messageId?: string;
    error?: string;
    response?: string;
}

/*
 * Interface #15: TemplateData
 * Source: communications/interfaces/template.interface.ts:3
 * Properties: 1
 * Complexity: 2
 * Size: 57 characters
 */
export interface TemplateData {
    [key: string]: any;
}

/*
 * Interface #16: BaseTemplateData
 * Source: communications/interfaces/template.interface.ts:8
 * Properties: 6
 * Complexity: 7
 * Size: 221 characters
 * Extends: TemplateData
 */
export interface BaseTemplateData extends TemplateData {
    recipientName?: string;
    recipientEmail: string;
    companyName?: string;
    companyUrl?: string;
    unsubscribeUrl?: string;
    supportEmail?: string;
}

/*
 * Interface #17: WelcomeTemplateData
 * Source: communications/interfaces/template.interface.ts:18
 * Properties: 4
 * Complexity: 5
 * Size: 167 characters
 * Extends: BaseTemplateData
 */
export interface WelcomeTemplateData extends BaseTemplateData {
    loginUrl: string;
    dashboardUrl: string;
    profileUrl: string;
    activationToken?: string;
}

/*
 * Interface #18: WelcomeOrganizationTemplateData
 * Source: communications/interfaces/template.interface.ts:26
 * Properties: 7
 * Complexity: 8
 * Size: 255 characters
 * Extends: BaseTemplateData
 */
export interface WelcomeOrganizationTemplateData extends BaseTemplateData {
    organizationName: string;
    organizationId: string;
    dashboardUrl: string;
    loginUrl: string;
    logoUrl?: string;
    website?: string;
    setupGuideUrl?: string;
}

/*
 * Interface #19: WelcomeBranchTemplateData
 * Source: communications/interfaces/template.interface.ts:37
 * Properties: 10
 * Complexity: 11
 * Size: 327 characters
 * Extends: BaseTemplateData
 */
export interface WelcomeBranchTemplateData extends BaseTemplateData {
    branchName: string;
    branchId: string;
    organizationName: string;
    organizationId: string;
    dashboardUrl: string;
    loginUrl: string;
    address?: string;
    contactNumber?: string;
    managerName?: string;
    setupGuideUrl?: string;
}

/*
 * Interface #20: WelcomeUserTemplateData
 * Source: communications/interfaces/template.interface.ts:51
 * Properties: 11
 * Complexity: 12
 * Size: 341 characters
 * Extends: BaseTemplateData
 */
export interface WelcomeUserTemplateData extends BaseTemplateData {
    firstName: string;
    lastName: string;
    userId: string;
    dashboardUrl: string;
    loginUrl: string;
    profileUrl: string;
    organizationName?: string;
    branchName?: string;
    avatar?: string;
    activationToken?: string;
    setupGuideUrl?: string;
}

/*
 * Interface #21: PasswordResetTemplateData
 * Source: communications/interfaces/template.interface.ts:66
 * Properties: 4
 * Complexity: 5
 * Size: 165 characters
 * Extends: BaseTemplateData
 */
export interface PasswordResetTemplateData extends BaseTemplateData {
    resetUrl: string;
    resetToken: string;
    expiryTime: string;
    ipAddress?: string;
}

/*
 * Interface #22: TestNotificationTemplateData
 * Source: communications/interfaces/template.interface.ts:74
 * Properties: 6
 * Complexity: 7
 * Size: 221 characters
 * Extends: BaseTemplateData
 */
export interface TestNotificationTemplateData extends BaseTemplateData {
    testTitle: string;
    testDescription?: string;
    dueDate: string;
    testUrl: string;
    duration?: string;
    instructorName?: string;
}

/*
 * Interface #23: ResultsSummaryTemplateData
 * Source: communications/interfaces/template.interface.ts:84
 * Properties: 8
 * Complexity: 9
 * Size: 269 characters
 * Extends: BaseTemplateData
 */
export interface ResultsSummaryTemplateData extends BaseTemplateData {
    testTitle: string;
    score: number;
    totalQuestions: number;
    correctAnswers: number;
    percentage: number;
    completionTime: string;
    resultsUrl: string;
    feedback?: string;
}

/*
 * Interface #24: CourseEnrollmentTemplateData
 * Source: communications/interfaces/template.interface.ts:96
 * Properties: 6
 * Complexity: 7
 * Size: 228 characters
 * Extends: BaseTemplateData
 */
export interface CourseEnrollmentTemplateData extends BaseTemplateData {
    courseName: string;
    courseDescription?: string;
    courseUrl: string;
    instructorName?: string;
    startDate?: string;
    endDate?: string;
}

/*
 * Interface #25: SystemAlertTemplateData
 * Source: communications/interfaces/template.interface.ts:106
 * Properties: 6
 * Complexity: 7
 * Size: 248 characters
 * Extends: BaseTemplateData
 */
export interface SystemAlertTemplateData extends BaseTemplateData {
    alertType: 'info' | 'warning' | 'error' | 'success';
    alertTitle: string;
    alertMessage: string;
    actionUrl?: string;
    actionText?: string;
    timestamp: string;
}

/*
 * Interface #26: CustomTemplateData
 * Source: communications/interfaces/template.interface.ts:116
 * Properties: 3
 * Complexity: 4
 * Size: 130 characters
 * Extends: BaseTemplateData
 */
export interface CustomTemplateData extends BaseTemplateData {
    title?: string;
    message?: string;
    [key: string]: any;
}

/*
 * Interface #27: TemplateMetadata
 * Source: communications/interfaces/template.interface.ts:123
 * Properties: 7
 * Complexity: 8
 * Size: 215 characters
 */
export interface TemplateMetadata {
    name: string;
    type: EmailType;
    version: string;
    description?: string;
    requiredData: string[];
    optionalData?: string[];
    supportedLanguages?: string[];
}

/*
 * Interface #28: TemplateConfig
 * Source: communications/interfaces/template.interface.ts:134
 * Properties: 6
 * Complexity: 7
 * Size: 192 characters
 */
export interface TemplateConfig {
    name: string;
    type: EmailType;
    htmlFile: string;
    textFile?: string;
    metadata: TemplateMetadata;
    defaultData?: Partial<TemplateData>;
}

/*
 * Interface #29: TemplateRenderOptions
 * Source: communications/interfaces/template.interface.ts:144
 * Properties: 4
 * Complexity: 5
 * Size: 150 characters
 */
export interface TemplateRenderOptions {
    template: string;
    data: TemplateData;
    language?: string;
    format?: 'html' | 'text' | 'both';
}

/*
 * Interface #30: TemplateRenderResult
 * Source: communications/interfaces/template.interface.ts:152
 * Properties: 4
 * Complexity: 5
 * Size: 133 characters
 */
export interface TemplateRenderResult {
    html?: string;
    text?: string;
    subject: string;
    metadata?: TemplateMetadata;
}

/*
 * Interface #31: TemplateValidationResult
 * Source: communications/interfaces/template.interface.ts:160
 * Properties: 4
 * Complexity: 5
 * Size: 146 characters
 */
export interface TemplateValidationResult {
    isValid: boolean;
    errors: string[];
    warnings?: string[];
    missingRequired?: string[];
}

/*
 * Interface #32: EmailJobData
 * Source: communications/services/email-queue.service.ts:14
 * Properties: 12
 * Complexity: 13
 * Size: 392 characters
 */
export interface EmailJobData {
    id: string;
    emailOptions: EmailSendOptions;
    priority?: number;
    templateType?: string;
    userId?: string;
    organizationId?: string;
    metadata?: Record<string, any>;
    attempts?: number;
    maxAttempts?: number;
    createdAt: Date;
    scheduledFor?: Date;
    status: 'pending' | 'processing' | 'completed' | 'failed' | 'retrying';
}

/*
 * Interface #33: BulkEmailJobData
 * Source: communications/services/email-queue.service.ts:29
 * Properties: 11
 * Complexity: 12
 * Size: 362 characters
 */
export interface BulkEmailJobData {
    id: string;
    emails: EmailSendOptions[];
    priority?: number;
    batchSize?: number;
    metadata?: Record<string, any>;
    attempts?: number;
    maxAttempts?: number;
    createdAt: Date;
    scheduledFor?: Date;
    status: 'pending' | 'processing' | 'completed' | 'failed' | 'retrying';
    progress?: number;
}

/*
 * Interface #34: EmailSendOptions
 * Source: communications/services/email-smtp.service.ts:7
 * Properties: 10
 * Complexity: 11
 * Size: 300 characters
 */
export interface EmailSendOptions {
    to: string | string[];
    cc?: string | string[];
    bcc?: string | string[];
    subject: string;
    text?: string;
    html?: string;
    attachments?: Array<{
        filename: string;
        content: Buffer | string;
        contentType?: string;
    }

/*
 * Interface #35: EmailSendResult
 * Source: communications/services/email-smtp.service.ts:21
 * Properties: 5
 * Complexity: 6
 * Size: 146 characters
 */
export interface EmailSendResult {
    success: boolean;
    messageId?: string;
    error?: string;
    retryCount?: number;
    sentAt?: Date;
}

/*
 * Interface #36: OrgBranchScope
 * Source: course-materials/course-materials.service.ts:29
 * Properties: 2
 * Complexity: 3
 * Size: 78 characters
 */
export interface OrgBranchScope {
    orgId?: string;
    branchId?: string;
}

/*
 * Interface #37: OrganizationStats
 * Source: org/interfaces/organization.interface.ts:1
 * Properties: 3
 * Complexity: 4
 * Size: 123 characters
 */
export interface OrganizationStats {
    totalBranches: number;
    activeBranches: number;
    inactiveBranches: number;
}

/*
 * Interface #38: OrganizationWithStats
 * Source: org/interfaces/organization.interface.ts:7
 * Properties: 2
 * Complexity: 3
 * Size: 126 characters
 */
export interface OrganizationWithStats {
    organization: any; // Will be Organization entity
    stats: OrganizationStats;
}

/*
 * Interface #39: BranchFilters
 * Source: org/interfaces/organization.interface.ts:12
 * Properties: 3
 * Complexity: 4
 * Size: 113 characters
 */
export interface BranchFilters {
    organizationId?: string;
    isActive?: boolean;
    managerName?: string;
}

/*
 * Interface #40: OrganizationFilters
 * Source: org/interfaces/organization.interface.ts:18
 * Properties: 2
 * Complexity: 3
 * Size: 83 characters
 */
export interface OrganizationFilters {
    isActive?: boolean;
    name?: string;
}

// ==========================================
// CLASSES (DTOs, Entities, etc.) - 318 total
// ==========================================

/*
 * Class #1: AnswersController
 * Source: answers/answers.controller.ts:33
 * Type: Exported Class
 * Methods: 6
 * Properties: 144
 * Decorators: 44
 * Complexity: 138
 * Size: 12299 characters (363 lines)
 */
export class AnswersController {
    constructor(private readonly answersService: AnswersService) {}

    @Post()
    @ApiOperation({
        summary: '📝 Create Answer',
        description: `
        **Create a new answer for a test question**
        
        This endpoint allows students to submit answers to questions during an active test attempt.
        The system will validate attempt ownership, question validity, and prevent duplicate answers.
        
        **Features:**
        - Support for multiple choice (selectedOptionId) and text answers
        - Automatic validation of attempt status and ownership
        - Prevention of duplicate answers for the same question
        - Validation that selected options belong to the question
        
        **Business Rules:**
        - Only active (in_progress) attempts can receive new answers
        - Students can only create answers for their own attempts
        - One answer per question per attempt
        - Selected options must belong to the specified question
        
        **Security:**
        - JWT authentication required
        - Ownership validation for test attempts
        - Input validation and sanitization
        `,
    })
    @ApiBody({
        type: CreateAnswerDto,
        description: 'Answer details',
        examples: {
            multipleChoice: {
                summary: 'Multiple choice answer',
                description: 'Answer with selected option',
                value: {
                    attemptId: 1,
                    questionId: 1,
                    selectedOptionId: 3,
                },
            },
            textAnswer: {
                summary: 'Text answer',
                description: 'Open-ended text response',
                value: {
                    attemptId: 1,
                    questionId: 2,
                    textAnswer:
                        'The time complexity of binary search is O(log n)',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description: '✅ Answer created successfully',
        type: AnswerResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid request or business rule violation',
        example: {
            statusCode: 400,
            message: 'Answer already exists for this question in this attempt',
            error: 'Bad Request',
        },
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '❌ Access denied to this attempt',
        example: {
            statusCode: 403,
            message: 'You can only create answers for your own attempts',
            error: 'Forbidden',
        },
    })
    async create(
        @Body() createAnswerDto: CreateAnswerDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<AnswerResponseDto> {
        return this.answersService.create(createAnswerDto, scope.userId);
    }

    @Post('bulk')
    @ApiOperation({
        summary: '📋 Bulk Create Answers',
        description: `
        **Create multiple answers in a single request**
        
        This endpoint allows students to submit multiple answers at once,
        useful for saving progress or submitting all answers together.
        
        **Features:**
        - Process multiple answers in one request
        - Partial success handling (continues if some answers fail)
        - Automatic validation for each answer
        - Efficient batch processing
        
        **Business Rules:**
        - All answers must belong to attempts owned by the user
        - Individual answer validation applies to each item
        - Failed answers are logged but don't stop processing
        - Returns successfully created answers
        
        **Security:**
        - JWT authentication required
        - Individual ownership validation for each answer
        - Comprehensive input validation
        `,
    })
    @ApiBody({
        type: BulkAnswersDto,
        description: 'Multiple answers to create',
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description: '✅ Answers created successfully',
        type: [AnswerResponseDto],
    })
    async bulkCreate(
        @Body() bulkAnswersDto: BulkAnswersDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<AnswerResponseDto[]> {
        return this.answersService.bulkCreate(bulkAnswersDto, scope.userId);
    }

    @Get('attempt/:attemptId')
    @ApiOperation({
        summary: '📚 Get Answers for Attempt',
        description: `
        **Retrieve all answers for a specific test attempt**
        
        This endpoint returns all answers submitted for a test attempt,
        including question details and selected options.
        
        **Features:**
        - Complete answer details with related data
        - Ordered by question ID for consistent display
        - Includes question and option information
        - Shows marking status and scores
        
        **Use Cases:**
        - Reviewing submitted answers
        - Displaying test results
        - Progress tracking during attempts
        - Answer validation and verification
        
        **Security:**
        - JWT authentication required
        - Users can only access their own attempt answers
        - Ownership validation performed
        `,
    })
    @ApiParam({
        name: 'attemptId',
        description: 'Test attempt ID to get answers for',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Answers retrieved successfully',
        type: [AnswerResponseDto],
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '❌ Access denied to this attempt',
        example: {
            statusCode: 403,
            message: 'You can only access your own attempt answers',
            error: 'Forbidden',
        },
    })
    async getAnswersForAttempt(
        @Param('attemptId', ParseIntPipe) attemptId: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<AnswerResponseDto[]> {
        return this.answersService.findByAttempt(attemptId, scope.userId);
    }

    @Put(':id')
    @ApiOperation({
        summary: '✏️ Update Answer',
        description: `
        **Update an existing answer during an active attempt**
        
        This endpoint allows students to modify their answers while
        the test attempt is still in progress.
        
        **Features:**
        - Update selected options or text answers
        - Validation of new answer data
        - Maintains answer history and timestamps
        - Prevents updates to submitted attempts
        
        **Business Rules:**
        - Only answers in active attempts can be updated
        - Students can only update their own answers
        - Selected options must belong to the question
        - Updates are not allowed after attempt submission
        
        **Security:**
        - JWT authentication required
        - Ownership validation for answers and attempts
        - Status validation for attempt activity
        `,
    })
    @ApiParam({
        name: 'id',
        description: 'Answer ID to update',
        example: 1,
    })
    @ApiBody({
        type: UpdateAnswerDto,
        description: 'Updated answer details',
        examples: {
            updateOption: {
                summary: 'Update selected option',
                description: 'Change the selected option for multiple choice',
                value: {
                    selectedOptionId: 4,
                },
            },
            updateText: {
                summary: 'Update text answer',
                description: 'Modify the text response',
                value: {
                    textAnswer: 'Updated: Binary search complexity is O(log n)',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Answer updated successfully',
        type: AnswerResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Cannot update non-active attempt answer',
        example: {
            statusCode: 400,
            message: 'Cannot update answers for non-active attempts',
            error: 'Bad Request',
        },
    })
    async update(
        @Param('id', ParseIntPipe) id: number,
        @Body() updateAnswerDto: UpdateAnswerDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<AnswerResponseDto> {
        return this.answersService.update(id, updateAnswerDto, scope.userId);
    }

    @Post(':id/mark')
    @ApiOperation({
        summary: '🎯 Mark Answer',
        description: `
        **Mark/grade an answer (instructor only)**
        
        This endpoint allows instructors to manually grade answers,
        particularly for open-ended questions that require human evaluation.
        
        **Features:**
        - Award points up to question maximum
        - Provide detailed feedback to students
        - Track marking timestamp and marker identity
        - Automatic correctness determination
        
        **Business Rules:**
        - Points cannot exceed question maximum
        - Marking is final and updates attempt scores
        - Feedback is optional but recommended
        - Marking timestamp is automatically recorded
        
        **Security:**
        - JWT authentication required
        - Instructor-level permissions required
        - Comprehensive audit trail
        `,
    })
    @ApiParam({
        name: 'id',
        description: 'Answer ID to mark',
        example: 1,
    })
    @ApiBody({
        type: MarkAnswerDto,
        description: 'Marking details',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Answer marked successfully',
        type: AnswerResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid marking data',
        example: {
            statusCode: 400,
            message: 'Points awarded cannot exceed question maximum (5)',
            error: 'Bad Request',
        },
    })
    async markAnswer(
        @Param('id', ParseIntPipe) id: number,
        @Body() markAnswerDto: MarkAnswerDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<AnswerResponseDto> {
        return this.answersService.markAnswer(id, markAnswerDto, scope.userId);
    }

    @Post('auto-mark/:attemptId')
    @ApiOperation({
        summary: '🤖 Auto-mark Attempt',
        description: `
        **Automatically mark objective questions in an attempt**
        
        This endpoint triggers automatic marking for multiple choice
        and other objective questions that can be graded programmatically.
        
        **Features:**
        - Automatic grading of multiple choice questions
        - Instant score calculation and feedback
        - Bulk processing for efficiency
        - Preserves manual marking for subjective questions
        
        **Business Rules:**
        - Only processes unmarked objective questions
        - Compares selected options with correct answers
        - Awards full points for correct answers, zero for incorrect
        - Updates marking timestamps and status
        
        **Security:**
        - JWT authentication required
        - Instructor-level permissions recommended
        - Comprehensive processing logs
        `,
    })
    @ApiParam({
        name: 'attemptId',
        description: 'Test attempt ID to auto-mark',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Auto-marking completed successfully',
        example: {
            message: 'Auto-marking completed for attempt 1',
            markedQuestions: 5,
        },
    })
    async autoMarkAttempt(
        @Param('attemptId', ParseIntPipe) attemptId: number,
    ): Promise<{ message: string; markedQuestions: number }> {
        await this.answersService.autoMark(attemptId);
        return {
            message: `Auto-marking completed for attempt ${attemptId}`,
            markedQuestions: 0, // This would be returned from the service
        };
    }
}

/*
 * Class #2: AnswersModule
 * Source: answers/answers.module.ts:23
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 29 characters (1 lines)
 */
export class AnswersModule {}

/*
 * Class #3: AnswersService
 * Source: answers/answers.service.ts:23
 * Type: Exported Class
 * Methods: 29
 * Properties: 71
 * Decorators: 4
 * Complexity: 124
 * Size: 10248 characters (304 lines)
 */
export class AnswersService {
    constructor(
        @InjectRepository(Answer)
        private readonly answerRepository: Repository<Answer>,
        @InjectRepository(TestAttempt)
        private readonly testAttemptRepository: Repository<TestAttempt>,
        @InjectRepository(Question)
        private readonly questionRepository: Repository<Question>,
        @InjectRepository(QuestionOption)
        private readonly questionOptionRepository: Repository<QuestionOption>,
    ) {}

    async create(
        createAnswerDto: CreateAnswerDto,
        userId: string,
    ): Promise<AnswerResponseDto> {
        // Validate attempt ownership and status
        const attempt = await this.testAttemptRepository.findOne({
            where: { attemptId: createAnswerDto.attemptId },
            relations: ['user'],
        });

        if (!attempt) {
            throw new NotFoundException('Test attempt not found');
        }

        if (attempt.userId !== userId) {
            throw new ForbiddenException(
                'You can only create answers for your own attempts',
            );
        }

        if (attempt.status !== AttemptStatus.IN_PROGRESS) {
            throw new BadRequestException(
                'Cannot create answers for non-active attempts',
            );
        }

        // Validate question exists
        const question = await this.questionRepository.findOne({
            where: { questionId: createAnswerDto.questionId },
        });

        if (!question) {
            throw new NotFoundException('Question not found');
        }

        // Check if answer already exists for this question in this attempt
        const existingAnswer = await this.answerRepository.findOne({
            where: {
                attemptId: createAnswerDto.attemptId,
                questionId: createAnswerDto.questionId,
            },
        });

        if (existingAnswer) {
            throw new BadRequestException(
                'Answer already exists for this question in this attempt',
            );
        }

        // Validate selected option if provided
        if (createAnswerDto.selectedOptionId) {
            const option = await this.questionOptionRepository.findOne({
                where: {
                    optionId: createAnswerDto.selectedOptionId,
                    questionId: createAnswerDto.questionId,
                },
            });

            if (!option) {
                throw new BadRequestException(
                    'Selected option does not belong to this question',
                );
            }
        }

        // Create the answer
        const answer = this.answerRepository.create({
            ...createAnswerDto,
            isMarked: false,
            isCorrect: false,
        });

        const savedAnswer = await this.answerRepository.save(answer);

        return this.mapToResponseDto(savedAnswer);
    }

    async update(
        id: number,
        updateAnswerDto: UpdateAnswerDto,
        userId: string,
    ): Promise<AnswerResponseDto> {
        const answer = await this.answerRepository.findOne({
            where: { answerId: id },
            relations: ['attempt'],
        });

        if (!answer) {
            throw new NotFoundException('Answer not found');
        }

        if (answer.attempt.userId !== userId) {
            throw new ForbiddenException(
                'You can only update your own answers',
            );
        }

        if (answer.attempt.status !== AttemptStatus.IN_PROGRESS) {
            throw new BadRequestException(
                'Cannot update answers for non-active attempts',
            );
        }

        // Validate selected option if provided
        if (updateAnswerDto.selectedOptionId) {
            const option = await this.questionOptionRepository.findOne({
                where: {
                    optionId: updateAnswerDto.selectedOptionId,
                    questionId: answer.questionId,
                },
            });

            if (!option) {
                throw new BadRequestException(
                    'Selected option does not belong to this question',
                );
            }
        }

        Object.assign(answer, updateAnswerDto);
        const updatedAnswer = await this.answerRepository.save(answer);

        return this.mapToResponseDto(updatedAnswer);
    }

    async markAnswer(
        id: number,
        markAnswerDto: MarkAnswerDto,
        userId: string,
    ): Promise<AnswerResponseDto> {
        const answer = await this.answerRepository.findOne({
            where: { answerId: id },
            relations: ['attempt', 'question'],
        });

        if (!answer) {
            throw new NotFoundException('Answer not found');
        }

        // Validate points don't exceed question maximum
        if (markAnswerDto.pointsAwarded > answer.question.points) {
            throw new BadRequestException(
                `Points awarded cannot exceed question maximum (${answer.question.points})`,
            );
        }

        // Update answer with marking information
        answer.pointsAwarded = markAnswerDto.pointsAwarded;
        answer.feedback = markAnswerDto.feedback;
        answer.isMarked = true;
        answer.markedByUserId = userId;
        answer.markedAt = new Date();
        answer.isCorrect =
            markAnswerDto.pointsAwarded === answer.question.points;

        const markedAnswer = await this.answerRepository.save(answer);

        return this.mapToResponseDto(markedAnswer);
    }

    async findByAttempt(
        attemptId: number,
        userId: string,
    ): Promise<AnswerResponseDto[]> {
        // Validate attempt access
        const attempt = await this.testAttemptRepository.findOne({
            where: { attemptId },
        });

        if (!attempt) {
            throw new NotFoundException('Test attempt not found');
        }

        if (attempt.userId !== userId) {
            throw new ForbiddenException(
                'You can only access your own attempt answers',
            );
        }

        const answers = await this.answerRepository.find({
            where: { attemptId },
            relations: ['question', 'selectedOption'],
            order: { questionId: 'ASC' },
        });

        return answers.map(answer => this.mapToResponseDto(answer));
    }

    async findByQuestion(questionId: number): Promise<AnswerResponseDto[]> {
        // This method is typically for instructors to see all answers to a question
        const answers = await this.answerRepository.find({
            where: { questionId },
            relations: ['attempt', 'question', 'selectedOption'],
            order: { createdAt: 'DESC' },
        });

        return answers.map(answer => this.mapToResponseDto(answer));
    }

    async bulkCreate(
        bulkAnswersDto: BulkAnswersDto,
        userId: string,
    ): Promise<AnswerResponseDto[]> {
        const results: AnswerResponseDto[] = [];

        for (const answerDto of bulkAnswersDto.answers) {
            try {
                const answer = await this.create(answerDto, userId);
                results.push(answer);
            } catch (error) {
                // Continue with other answers even if one fails
                console.error(
                    `Failed to create answer for question ${answerDto.questionId}:`,
                    error instanceof Error ? error.message : 'Unknown error',
                );
            }
        }

        return results;
    }

    async autoMark(attemptId: number): Promise<void> {
        // Auto-mark objective questions (multiple choice)
        const answers = await this.answerRepository.find({
            where: { attemptId, isMarked: false },
            relations: ['question', 'selectedOption', 'attempt'],
        });

        for (const answer of answers) {
            if (
                answer.selectedOptionId &&
                answer.selectedOption &&
                answer.question.questionType === QuestionType.MULTIPLE_CHOICE
            ) {
                const selectedOption = answer.selectedOption as QuestionOption;
                answer.isCorrect = selectedOption.isCorrect;
                answer.pointsAwarded = answer.isCorrect
                    ? answer.question.points
                    : 0;
                answer.isMarked = true;
                answer.markedAt = new Date();

                await this.answerRepository.save(answer);
            }
        }
    }

    /**
     * Count answers for a specific question
     */
    async countByQuestion(questionId: number): Promise<number> {
        return await this.answerRepository.count({
            where: { questionId },
        });
    }

    private mapToResponseDto(answer: Answer): AnswerResponseDto {
        return {
            answerId: answer.answerId,
            attemptId: answer.attemptId,
            questionId: answer.questionId,
            selectedOptionId: answer.selectedOptionId,
            textAnswer: answer.textAnswer,
            pointsAwarded: answer.pointsAwarded,
            isMarked: answer.isMarked,
            isCorrect: answer.isCorrect,
            markedByUserId: answer.markedByUserId,
            markedAt: answer.markedAt,
            feedback: answer.feedback,
            createdAt: answer.createdAt,
            updatedAt: answer.updatedAt,
            question: answer.question
                ? {
                      questionId: answer.question.questionId,
                      questionText: answer.question.questionText,
                      questionType: answer.question.questionType,
                      points: answer.question.points,
                  }
                : undefined,
            selectedOption: answer.selectedOption
                ? {
                      optionId: (answer.selectedOption as QuestionOption)
                          .optionId,
                      optionText: (answer.selectedOption as QuestionOption)
                          .optionText,
                      isCorrect: (answer.selectedOption as QuestionOption)
                          .isCorrect,
                  }
                : undefined,
        };
    }
}

/*
 * Class #4: AnswerResponseDto
 * Source: answers/dto/answer-response.dto.ts:11
 * Type: Exported Class
 * Methods: 0
 * Properties: 25
 * Decorators: 36
 * Complexity: 85
 * Size: 2883 characters (127 lines)
 */
export class AnswerResponseDto {
    @ApiProperty({
        description: 'Answer unique identifier',
        example: 1,
    })
    @IsNumber()
    answerId: number;

    @ApiProperty({
        description: 'Test attempt ID this answer belongs to',
        example: 1,
    })
    @IsNumber()
    attemptId: number;

    @ApiProperty({
        description: 'Question ID this answer responds to',
        example: 1,
    })
    @IsNumber()
    questionId: number;

    @ApiProperty({
        description: 'Selected option ID for multiple choice questions',
        example: 1,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    selectedOptionId?: number;

    @ApiProperty({
        description: 'Text answer for open-ended questions',
        example: 'The time complexity of binary search is O(log n)',
        required: false,
    })
    @IsOptional()
    @IsString()
    textAnswer?: string;

    @ApiProperty({
        description: 'Points awarded for this answer',
        example: 4.5,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    pointsAwarded?: number;

    @ApiProperty({
        description: 'Whether this answer has been marked/graded',
        example: true,
    })
    @IsBoolean()
    isMarked: boolean;

    @ApiProperty({
        description: 'Whether this answer is correct',
        example: true,
    })
    @IsBoolean()
    isCorrect: boolean;

    @ApiProperty({
        description: 'User ID who marked this answer',
        example: '123e4567-e89b-12d3-a456-426614174000',
        required: false,
    })
    @IsOptional()
    @IsUUID()
    markedByUserId?: string;

    @ApiProperty({
        description: 'When this answer was marked/graded',
        example: '2024-01-01T11:00:00.000Z',
        required: false,
    })
    @IsOptional()
    @IsDateString()
    markedAt?: Date;

    @ApiProperty({
        description: 'Feedback from the marker',
        example: 'Good understanding but could provide more detail',
        required: false,
    })
    @IsOptional()
    @IsString()
    feedback?: string;

    @ApiProperty({
        description: 'Answer submission timestamp',
        example: '2024-01-01T09:30:00.000Z',
    })
    @IsDateString()
    createdAt: Date;

    @ApiProperty({
        description: 'Answer last update timestamp',
        example: '2024-01-01T11:00:00.000Z',
    })
    @IsDateString()
    updatedAt: Date;

    @ApiProperty({
        description: 'Question details',
        required: false,
    })
    @IsOptional()
    question?: {
        questionId: number;
        questionText: string;
        questionType: string;
        points: number;
    };

    @ApiProperty({
        description: 'Selected option details',
        required: false,
    })
    @IsOptional()
    selectedOption?: {
        optionId: number;
        optionText: string;
        isCorrect: boolean;
    };
}

/*
 * Class #5: BulkAnswersDto
 * Source: answers/dto/bulk-answers.dto.ts:6
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 4
 * Complexity: 9
 * Size: 257 characters (10 lines)
 */
export class BulkAnswersDto {
    @ApiProperty({
        description: 'Array of answers to create',
        type: [CreateAnswerDto],
    })
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CreateAnswerDto)
    answers: CreateAnswerDto[];
}

/*
 * Class #6: CreateAnswerDto
 * Source: answers/dto/create-answer.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 7
 * Decorators: 12
 * Complexity: 30
 * Size: 814 characters (35 lines)
 */
export class CreateAnswerDto {
    @ApiProperty({
        description: 'Test attempt ID this answer belongs to',
        example: 1,
    })
    @IsNumber()
    @IsNotEmpty()
    attemptId: number;

    @ApiProperty({
        description: 'Question ID this answer responds to',
        example: 1,
    })
    @IsNumber()
    @IsNotEmpty()
    questionId: number;

    @ApiProperty({
        description: 'Selected option ID for multiple choice questions',
        example: 1,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    selectedOptionId?: number;

    @ApiProperty({
        description: 'Text answer for open-ended questions',
        example: 'The time complexity of binary search is O(log n)',
        required: false,
    })
    @IsOptional()
    @IsString()
    textAnswer?: string;
}

/*
 * Class #7: MarkAnswerDto
 * Source: answers/dto/mark-answer.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 2
 * Decorators: 6
 * Complexity: 16
 * Size: 454 characters (19 lines)
 */
export class MarkAnswerDto {
    @ApiProperty({
        description: 'Points awarded for this answer',
        example: 4.5,
        minimum: 0,
    })
    @IsNumber()
    @Min(0)
    pointsAwarded: number;

    @ApiProperty({
        description: 'Feedback from the marker for manual grading',
        example: 'Good understanding but could provide more detail',
        required: false,
    })
    @IsOptional()
    @IsString()
    feedback?: string;
}

/*
 * Class #8: UpdateAnswerDto
 * Source: answers/dto/update-answer.dto.ts:4
 * Type: Exported Class
 * Methods: 1
 * Properties: 0
 * Decorators: 0
 * Complexity: 3
 * Size: 68 characters (1 lines)
 * Extends: PartialType(CreateAnswerDto)
 */
export class UpdateAnswerDto extends PartialType(CreateAnswerDto) {}

/*
 * Class #9: Answer
 * Source: answers/entities/answer.entity.ts:31
 * Type: Exported Class
 * Methods: 0
 * Properties: 41
 * Decorators: 52
 * Complexity: 123
 * Size: 3771 characters (149 lines)
 */
export class Answer {
    @PrimaryGeneratedColumn()
    @ApiProperty({
        description: 'Answer unique identifier',
        example: 1,
    })
    answerId: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Test attempt ID this answer belongs to',
        example: 1,
    })
    @IsNumber()
    attemptId: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Question ID this answer responds to',
        example: 1,
    })
    @IsNumber()
    questionId: number;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Selected option ID for multiple choice questions',
        example: 1,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    selectedOptionId?: number;

    @Column('text', { nullable: true })
    @ApiProperty({
        description: 'Text answer for open-ended questions',
        example: 'The time complexity of binary search is O(log n)',
        required: false,
    })
    @IsOptional()
    @IsString()
    textAnswer?: string;

    @Column({ type: 'decimal', precision: 5, scale: 2, nullable: true })
    @ApiProperty({
        description: 'Points awarded for this answer',
        example: 4.5,
        minimum: 0,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    pointsAwarded?: number;

    @Column({ default: false })
    @ApiProperty({
        description: 'Whether this answer has been marked/graded',
        example: true,
    })
    @IsBoolean()
    isMarked: boolean;

    @Column({ default: false })
    @ApiProperty({
        description:
            'Whether this answer is correct (for auto-graded questions)',
        example: true,
    })
    @IsBoolean()
    isCorrect: boolean;

    @Column('uuid', { nullable: true })
    @ApiProperty({
        description: 'User ID who marked this answer (for manual grading)',
        example: '123e4567-e89b-12d3-a456-426614174000',
        required: false,
    })
    @IsOptional()
    @IsUUID()
    markedByUserId?: string;

    @Column({ type: 'timestamp', nullable: true })
    @ApiProperty({
        description: 'When this answer was marked/graded',
        example: '2024-01-01T11:00:00.000Z',
        required: false,
    })
    @IsOptional()
    @IsDateString()
    markedAt?: Date;

    @Column('text', { nullable: true })
    @ApiProperty({
        description: 'Feedback from the marker for manual grading',
        example: 'Good understanding but could provide more detail',
        required: false,
    })
    @IsOptional()
    @IsString()
    feedback?: string;

    @CreateDateColumn()
    @ApiProperty({
        description: 'Answer submission timestamp',
        example: '2024-01-01T09:30:00.000Z',
    })
    createdAt: Date;

    @UpdateDateColumn()
    @ApiProperty({
        description: 'Answer last update timestamp',
        example: '2024-01-01T11:00:00.000Z',
    })
    updatedAt: Date;

    @ManyToOne(() => Organization, { nullable: false })
    @ApiProperty({
        description: 'Organization this answer belongs to',
        type: () => Organization,
    })
    orgId: Organization;

    @ManyToOne(() => Branch, { nullable: true })
    @ApiProperty({
        description: 'Branch this answer belongs to',
        type: () => Branch,
        required: false,
    })
    branchId?: Branch;

    @ManyToOne(() => TestAttempt, { onDelete: 'CASCADE' })
    attempt: TestAttempt;

    @ManyToOne(() => Question, { onDelete: 'RESTRICT' })
    question: Question;

    @ManyToOne('QuestionOption', { nullable: true, onDelete: 'RESTRICT' })
    selectedOption: any;

    @ManyToOne(() => User, { nullable: true, onDelete: 'RESTRICT' })
    markedByUser: User;

    constructor(partial: Partial<Answer>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #10: AppController
 * Source: app.controller.ts:14
 * Type: Exported Class
 * Methods: 6
 * Properties: 32
 * Decorators: 15
 * Complexity: 54
 * Size: 3465 characters (114 lines)
 */
export class AppController {
    constructor(
        private readonly appService: AppService,
        @InjectConnection() private connection: Connection,
    ) {}

    @Get()
    @ApiOperation({
        summary: '🏠 Welcome Message',
        description: 'Returns welcome message for the trainpro API system',
    })
    @ApiResponse({
        status: 200,
        description: 'Welcome message',
        schema: {
            type: 'string',
            example:
                'Welcome to trainpro API - Advanced Web-Based Examination & Marking System',
        },
    })
    getHello(): string {
        return this.appService.getHello();
    }

    @Get('system-info')
    @ApiOperation({
        summary: '📋 System Information',
        description: `
            Comprehensive system information including:
            - System overview and description
            - Available modules and their status
            - Feature capabilities by category
            - Technical architecture details
            
            This endpoint provides a complete overview of the trainpro system
            for developers, administrators, and API consumers.
        `,
    })
    @ApiResponse({
        status: 200,
        description: 'Complete system information',
    })
    getSystemInfo() {
        return this.appService.getSystemInfo();
    }

    @Get('api-overview')
    @ApiOperation({
        summary: '🔧 API Technical Overview',
        description: `
            Technical details about the API including:
            - Base URL and versioning
            - Authentication methods
            - Response format standards
            - Error handling approach
            - Rate limiting information
            - Documentation location
            
            Essential information for API integration and development.
        `,
    })
    @ApiResponse({
        status: 200,
        description: 'API technical specifications',
    })
    getApiOverview() {
        return this.appService.getApiOverview();
    }

    @Get('database-schema')
    @ApiOperation({
        summary: '🗄️ Database Schema Information',
        description: `
            Database architecture and schema details including:
            - Schema description and design philosophy
            - Complete table listing with purposes
            - Entity relationships and foreign keys
            - Performance optimization features
            - Scalability considerations
            
            Useful for understanding data structure and relationships.
        `,
    })
    @ApiResponse({
        status: 200,
        description: 'Database schema information',
    })
    getDatabaseSchema() {
        return this.appService.getDatabaseSchema();
    }

    @Get('health')
    @ApiExcludeEndpoint() // Exclude from Swagger docs as it's internal
    async getHealth() {
        try {
            await this.connection.query('SELECT 1');
            return {
                status: 'ok',
                database: 'connected',
                timestamp: new Date().toISOString(),
            };
        } catch (error: unknown) {
            return {
                status: 'error',
                database: 'disconnected',
                error:
                    error instanceof Error
                        ? error.message
                        : 'Unknown database error',
                timestamp: new Date().toISOString(),
            };
        }
    }
}

/*
 * Class #11: AppModule
 * Source: app.module.ts:145
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 25 characters (1 lines)
 */
export class AppModule {}

/*
 * Class #12: AppService
 * Source: app.service.ts:30
 * Type: Exported Class
 * Methods: 4
 * Properties: 76
 * Decorators: 0
 * Complexity: 36
 * Size: 12819 characters (259 lines)
 */
export class AppService {
    getHello(): string {
        return 'Welcome to trainpro API - Advanced Web-Based Examination & Marking System';
    }

    getSystemInfo(): SystemInfo {
        return {
            name: 'trainpro - Advanced Examination System',
            version: '1.0.0',
            description: `
                trainpro is a comprehensive web-based examination and marking system designed for educational institutions, 
                training organizations, and assessment providers. Built with scalability, security, and user experience 
                in mind, trainpro supports multiple question types, automated marking, detailed analytics, and gamified 
                learning experiences through leaderboards and progress tracking.
            `,
            features: [
                '🎓 Multi-Role User Management (Students, Instructors, Admins)',
                '📚 Comprehensive Course Organization & Management',
                '📝 Flexible Test Creation (Exams, Quizzes, Training Modules)',
                '❓ Multiple Question Types (Multiple Choice, True/False, Short Answer, Essay)',
                '⏱️ Timed & Untimed Assessments with Attempt Limits',
                '📊 Real-Time Analytics & Performance Tracking',
                '🏆 Gamified Learning with Leaderboards',
                '📈 Training Progress Monitoring',
                '🔐 Enterprise-Grade Security & Authentication',
                '📱 RESTful API with Comprehensive Documentation',
                '🔄 Automated & Manual Marking Systems',
                '📋 Detailed Reporting & Export Capabilities',
            ],
            modules: [
                {
                    name: 'User Management',
                    status: '✅ COMPLETED',
                    description:
                        'Complete user lifecycle management with role-based access control, profile management, and secure authentication.',
                    endpoints: [
                        'POST /auth/register - User registration',
                        'POST /auth/login - User authentication',
                        'GET /user/profile - Profile retrieval',
                        'PUT /user/profile - Profile updates',
                        'PUT /user/change-password - Password management',
                    ],
                },
                {
                    name: 'Course Management',
                    status: '✅ COMPLETED',
                    description:
                        'Full course lifecycle management with instructor ownership, statistics, and organizational tools.',
                    endpoints: [
                        'POST /courses - Create new courses',
                        'GET /courses - List courses with filtering',
                        'GET /courses/:id - Course details & analytics',
                        'PUT /courses/:id - Update course information',
                        'DELETE /courses/:id - Course deletion with validation',
                    ],
                },
                {
                    name: 'Test Management',
                    status: '✅ COMPLETED',
                    description:
                        'Comprehensive test creation and management with multiple test types, timing controls, and attempt limitations.',
                    endpoints: [
                        'POST /tests - Create tests within courses',
                        'GET /tests - List tests with advanced filtering',
                        'GET /tests/:id - Detailed test information',
                        'PATCH /tests/:id/activate - Enable student access',
                        'GET /tests/:id/stats - Performance analytics',
                    ],
                },
                {
                    name: 'Questions Module',
                    status: '🔄 IN DEVELOPMENT',
                    description:
                        'Question bank management with multiple question types, ordering, and bulk operations.',
                    endpoints: [
                        'POST /questions - Create individual questions',
                        'POST /questions/bulk - Bulk question creation',
                        'GET /questions/test/:testId - Test questions',
                        'PATCH /questions/reorder - Question reordering',
                    ],
                },
                {
                    name: 'Question Options',
                    status: '📋 PLANNED',
                    description:
                        'Answer options for multiple choice and true/false questions with correctness tracking.',
                    endpoints: [
                        'POST /question-options - Create answer options',
                        'PUT /question-options/:id - Update options',
                        'DELETE /question-options/:id - Remove options',
                    ],
                },
                {
                    name: 'Test Attempts',
                    status: '📋 PLANNED',
                    description:
                        'Student test-taking interface with timing, progress tracking, and submission management.',
                    endpoints: [
                        'POST /test-attempts/start - Begin test attempt',
                        'POST /test-attempts/:id/submit - Submit completed test',
                        'GET /test-attempts/my-attempts - Student history',
                    ],
                },
                {
                    name: 'Answer Management',
                    status: '📋 PLANNED',
                    description:
                        'Student response collection, auto-marking for objective questions, and manual marking workflow.',
                    endpoints: [
                        'POST /answers - Submit individual answers',
                        'POST /answers/bulk - Bulk answer submission',
                        'POST /answers/:id/mark - Manual marking (instructors)',
                    ],
                },
                {
                    name: 'Results & Analytics',
                    status: '📋 PLANNED',
                    description:
                        'Comprehensive result calculation, performance analytics, and detailed reporting.',
                    endpoints: [
                        'GET /results/test/:testId - Test results overview',
                        'GET /results/user/:userId - Student performance',
                        'GET /results/analytics - Advanced analytics dashboard',
                    ],
                },
                {
                    name: 'Leaderboards',
                    status: '📋 PLANNED',
                    description:
                        'Gamified learning with course-based rankings and achievement tracking.',
                    endpoints: [
                        'GET /leaderboards/course/:courseId - Course rankings',
                        'GET /leaderboards/user/:userId - User ranking position',
                    ],
                },
                {
                    name: 'Training Progress',
                    status: '📋 PLANNED',
                    description:
                        'Learning path tracking with completion percentages and progress monitoring.',
                    endpoints: [
                        'GET /training-progress/user/:userId - User progress',
                        'PUT /training-progress - Update progress tracking',
                    ],
                },
            ],
            architecture: {
                database:
                    'PostgreSQL with optimized indexing and partitioning for scalability',
                backend:
                    'NestJS with TypeORM, JWT authentication, and comprehensive validation',
                authentication:
                    'JWT-based with refresh tokens and role-based access control',
                documentation:
                    'OpenAPI 3.0 (Swagger) with comprehensive examples and testing interface',
            },
            capabilities: {
                userManagement: [
                    'Multi-role system (brandon, owner, admin, user)',
                    'Secure registration and authentication',
                    'Profile management with avatar support',
                    'Password security with complexity requirements',
                    'Account verification and password reset',
                ],
                courseManagement: [
                    'Course creation with rich descriptions',
                    'Instructor ownership and access control',
                    'Course analytics and statistics',
                    'Test organization within courses',
                    'Student enrollment tracking',
                ],
                testManagement: [
                    'Multiple test types (Exams, Quizzes, Training)',
                    'Flexible timing (timed and untimed tests)',
                    'Attempt limitations and retake policies',
                    'Test activation and scheduling',
                    'Performance analytics and insights',
                ],
                assessmentFeatures: [
                    'Multiple question types support',
                    'Automated marking for objective questions',
                    'Manual marking workflow for subjective answers',
                    'Question ordering and randomization',
                    'Bulk operations for efficiency',
                    'Answer feedback and explanations',
                ],
                analyticsReporting: [
                    'Real-time performance dashboards',
                    'Score distribution analysis',
                    'Completion rate tracking',
                    'Student progress monitoring',
                    'Course effectiveness metrics',
                    'Exportable reports and data',
                ],
            },
        };
    }

    getApiOverview(): {
        baseUrl: string;
        authentication: string;
        responseFormat: string;
        errorHandling: string;
        rateLimit: string;
        documentation: string;
    } {
        return {
            baseUrl: '/api (with versioning support)',
            authentication: 'Bearer JWT tokens in Authorization header',
            responseFormat:
                'JSON with standardized response structure { success, message, data }',
            errorHandling:
                'HTTP status codes with detailed error messages and validation feedback',
            rateLimit: 'Configurable rate limiting for API protection',
            documentation: 'Interactive Swagger UI available at /api/docs',
        };
    }

    getDatabaseSchema(): {
        description: string;
        tables: string[];
        relationships: string[];
        features: string[];
    } {
        return {
            description:
                'Optimized relational database design for web-based examination and marking system',
            tables: [
                'users - User accounts with role-based access',
                'courses - Course organization and management',
                'tests - Examination configuration and settings',
                'questions - Question bank with multiple types',
                'question_options - Answer choices for objective questions',
                'test_attempts - Student test-taking sessions',
                'answers - Student responses and marking data',
                'results - Calculated scores and performance metrics',
                'leaderboards - Gamified ranking system',
                'training_progress - Learning path completion tracking',
            ],
            relationships: [
                'Users create and manage Courses (one-to-many)',
                'Courses contain multiple Tests (one-to-many, cascade delete)',
                'Tests have Questions with Options (hierarchical, cascade delete)',
                'Students make Test Attempts with Answers (tracked sessions)',
                'Results aggregate performance data (computed metrics)',
                'Leaderboards rank students by course (materialized views)',
                'Training Progress tracks learning completion (granular tracking)',
            ],
            features: [
                'Optimized indexing for query performance',
                'Partitioning for scalability (test_attempts by start_time)',
                'CHECK constraints for data integrity',
                'Materialized views for analytics efficiency',
                'Proper foreign key relationships with cascade/restrict policies',
                'Cross-region compatibility with timestamp',
            ],
        };
    }
}

/*
 * Class #13: AuthController
 * Source: auth/auth.controller.ts:43
 * Type: Exported Class
 * Methods: 12
 * Properties: 990
 * Decorators: 97
 * Complexity: 312
 * Size: 73583 characters (1867 lines)
 */
export class AuthController {
    private readonly logger = new Logger(AuthController.name);

    constructor(private readonly authService: AuthService) {}

    @Post('signup')
    @Throttle({ default: { limit: 3, ttl: 60000 } }) // 3 attempts per minute
    @ApiOperation({
        summary: '🚀 Register New User Account',
        description: `
      **Creates a new user account with comprehensive validation and security measures**
      
      This endpoint handles user registration with the following features:
      - Strong password requirements enforcement
      - Email uniqueness validation
      - Welcome email notification
      - Secure password hashing with bcrypt
      - Input sanitization and validation
      - Organization/branch assignment from invitations
      
      **Security Features:**
      - Rate limiting: 3 attempts per minute per IP
      - Password complexity requirements
      - Email format validation
      - Duplicate email prevention
      - SQL injection protection
      - No tokens generated (security best practice)
      
      **Registration Flow:**
      1. User submits registration form
      2. System validates all input data
      3. Password is securely hashed
      4. User account is created
      5. Organization/branch assigned if invited
      6. Welcome email notification is sent
      7. User data returned (no tokens)
      8. User must sign in separately for authentication
      
      **Next Steps After Registration:**
      After successful registration, users must use the Sign In endpoint (/auth/signin) with their email and password to authenticate and receive access tokens.
      
      **Use Cases:**
      - New user onboarding
      - Account creation from landing pages
      - Mobile app registration
      - Invitation-based registration
    `,
        operationId: 'registerUser',
    })
    @ApiBody({
        type: CreateUserDto,
        description: 'User registration data with required and optional fields',
        examples: {
            'basic-registration': {
                summary: '✨ Basic Registration',
                description: 'Minimal required fields for account creation',
                value: {
                    email: 'brandon.new@orrbit.co.za',
                    password: 'SecurePass123!',
                    firstName: 'Brandon',
                    lastName: 'Kawu',
                },
            },
            'complete-registration': {
                summary: '📋 Complete Profile Registration',
                description: 'Full registration with all optional fields',
                value: {
                    email: 'jane.smith@legendsystems.co.za',
                    password: 'StrongPassword456@',
                    firstName: 'Jane',
                    lastName: 'Smith',
                    avatar: 1,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description:
            '✅ User successfully registered - please sign in separately',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Registration success status',
                },
                message: {
                    type: 'string',
                    example:
                        'Account created successfully. Please sign in with your credentials.',
                    description: 'Success confirmation message',
                },
                data: {
                    type: 'object',
                    description:
                        'User data and organization/branch information if applicable',
                    properties: {
                        user: {
                            type: 'object',
                            description: 'Registered user profile data',
                            properties: {
                                uid: {
                                    type: 'string',
                                    example: '1',
                                    description: 'Unique user identifier',
                                },
                                email: {
                                    type: 'string',
                                    example: 'theguy@orrbit.co.za',
                                    description: 'User email address',
                                },
                                firstName: {
                                    type: 'string',
                                    example: 'John',
                                    description: 'User first name',
                                },
                                lastName: {
                                    type: 'string',
                                    example: 'Doe',
                                    description: 'User last name',
                                },
                                avatar: {
                                    type: 'object',
                                    description:
                                        'User avatar with multiple size variants',
                                    nullable: true,
                                    properties: {
                                        id: {
                                            type: 'number',
                                            example: 1,
                                            description: 'Avatar media file ID',
                                        },
                                        originalName: {
                                            type: 'string',
                                            example: 'profile-picture.jpg',
                                            description: 'Original filename',
                                        },
                                        url: {
                                            type: 'string',
                                            example:
                                                'https://cdn.example.com/media/1/profile-picture.jpg',
                                            description: 'Primary avatar URL',
                                        },
                                        thumbnail: {
                                            type: 'string',
                                            example:
                                                'https://cdn.example.com/media/1/thumbnail/profile-picture.jpg',
                                            description:
                                                'Thumbnail variant URL',
                                        },
                                        medium: {
                                            type: 'string',
                                            example:
                                                'https://cdn.example.com/media/1/medium/profile-picture.jpg',
                                            description: 'Medium variant URL',
                                        },
                                        original: {
                                            type: 'string',
                                            example:
                                                'https://cdn.example.com/media/1/profile-picture.jpg',
                                            description: 'Original size URL',
                                        },
                                    },
                                },
                                role: {
                                    type: 'string',
                                    example: 'user',
                                    description: 'User role in the system',
                                },
                                createdAt: {
                                    type: 'string',
                                    example: '2024-01-15T10:30:00.000Z',
                                    description: 'Account creation timestamp',
                                },
                                updatedAt: {
                                    type: 'string',
                                    example: '2024-01-15T10:30:00.000Z',
                                    description: 'Last update timestamp',
                                },
                            },
                        },
                        organization: {
                            type: 'object',
                            description:
                                'Organization information if user was invited to organization',
                            nullable: true,
                            properties: {
                                id: {
                                    type: 'string',
                                    example:
                                        'org-a1b2c3d4-e5f6-7890-abcd-ef1234567890',
                                    description:
                                        'Organization unique identifier',
                                },
                                name: {
                                    type: 'string',
                                    example: 'Acme Corporation',
                                    description: 'Organization name',
                                },
                                avatar: {
                                    type: 'string',
                                    example:
                                        'https://cdn.example.com/logos/acme-corp.png',
                                    description: 'Organization logo URL',
                                    nullable: true,
                                },
                            },
                        },
                        branch: {
                            type: 'object',
                            description:
                                'Branch information if user was invited to specific branch',
                            nullable: true,
                            properties: {
                                id: {
                                    type: 'string',
                                    example:
                                        'branch-b1c2d3e4-f5g6-7890-bcde-fg1234567890',
                                    description: 'Branch unique identifier',
                                },
                                name: {
                                    type: 'string',
                                    example: 'Downtown Branch',
                                    description: 'Branch name',
                                },
                                email: {
                                    type: 'string',
                                    example: 'downtown@acmecorp.com',
                                    description: 'Branch email address',
                                    nullable: true,
                                },
                                address: {
                                    type: 'string',
                                    example:
                                        '123 Main Street, Downtown, City 12345',
                                    description: 'Branch physical address',
                                    nullable: true,
                                },
                                contactNumber: {
                                    type: 'string',
                                    example: '+1-555-123-4567',
                                    description: 'Branch contact phone number',
                                    nullable: true,
                                },
                                managerName: {
                                    type: 'string',
                                    example: 'John Smith',
                                    description: 'Branch manager name',
                                    nullable: true,
                                },
                            },
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data or validation errors',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    examples: [
                        ['Please provide a valid email address'],
                        ['Password must be at least 8 characters long'],
                        ['Name must be at least 2 characters long'],
                    ],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CONFLICT,
        description: '⚠️ User already exists with this email',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 409 },
                message: {
                    type: 'string',
                    example: 'User with this email already exists',
                },
                error: { type: 'string', example: 'Conflict' },
            },
        },
    })
    async signUp(
        @Body() createUserDto: CreateUserDto,
    ): Promise<StandardApiResponse<SignUpResponseDto>> {
        this.logger.log(`Sign up attempt for email: ${createUserDto.email}`);
        return this.authService.signUp(createUserDto);
    }

    @Post('signin')
    @HttpCode(HttpStatus.OK)
    @Throttle({ default: { limit: 5, ttl: 60000 } }) // 5 attempts per minute
    @ApiOperation({
        summary: '🔑 User Authentication & Login',
        description: `
      **Authenticates existing users and provides access tokens**
      
      This endpoint handles user authentication with comprehensive security:
      - Email and password validation
      - Secure password verification using bcrypt
      - JWT token generation for session management
      - Rate limiting to prevent brute force attacks
      - Login attempt monitoring and logging
      - Returns user leaderboard statistics and metrics
      - Returns organization and branch information if applicable
      
      **Security Features:**
      - Rate limiting: 5 attempts per minute per IP
      - Secure password comparison
      - JWT token with expiration
      - Failed attempt logging
      - Account lockout protection (future enhancement)
      
      **Authentication Flow:**
      1. User submits email and password
      2. System validates credentials
      3. Password is verified against hash
      4. JWT tokens are generated
      5. User leaderboard stats are fetched
      6. Organization and branch details are retrieved
      7. Complete session data with metrics is returned
      8. User is authenticated for protected endpoints
      
      **Using the Access Token:**
      After successful authentication, use the returned access token in the Authorization header for protected endpoints:
      
      \`\`\`
      Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
      \`\`\`
      
      **Example API Calls with Headers:**
      
      \`\`\`javascript
      // JavaScript/Node.js example
      const response = await fetch('/api/protected-endpoint', {
        method: 'GET',
        headers: {
          'Authorization': 'Bearer ' + accessToken,
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        }
      });
      \`\`\`
      
      \`\`\`bash
      # cURL example
      curl -X GET "https://api.example.com/protected-endpoint" \\
        -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \\
        -H "Content-Type: application/json" \\
        -H "Accept: application/json"
      \`\`\`
      
      \`\`\`python
      # Python requests example
      import requests
      
      headers = {
        'Authorization': f'Bearer {access_token}',
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
      
      response = requests.get('https://api.example.com/protected-endpoint', headers=headers)
      \`\`\`
      
      **Use Cases:**
      - User login from web application
      - Mobile app authentication
      - API client authentication
      - Session restoration
      - Leaderboard data retrieval
      - Organization and branch context retrieval
    `,
        operationId: 'authenticateUser',
    })
    @ApiBody({
        type: SignInDto,
        description: 'User login credentials',
        examples: {
            'standard-login': {
                summary: '🔐 Standard Login',
                description:
                    'Regular user authentication with email and password',
                value: {
                    email: 'theguy@orrbit.co.za',
                    password: 'SecurePass123!',
                },
            },
            'returning-user': {
                summary: '🔄 Returning User Login',
                description: 'Login for existing user with established account',
                value: {
                    email: 'brandon@legendsystems.co.za',
                    password: 'MyPassword456@',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ User successfully authenticated',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Authentication success status',
                },
                message: {
                    type: 'string',
                    example: 'User signed in successfully',
                    description: 'Success confirmation message',
                },
                data: {
                    type: 'object',
                    description: 'Authentication session data',
                    properties: {
                        accessToken: {
                            type: 'string',
                            example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
                            description: 'JWT access token for API calls',
                        },
                        refreshToken: {
                            type: 'string',
                            example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
                            description:
                                'JWT refresh token for session renewal',
                        },
                        expiresIn: {
                            type: 'number',
                            example: 3600,
                            description: 'Token expiration in seconds',
                        },
                        user: {
                            type: 'object',
                            description: 'Authenticated user profile',
                            properties: {
                                uid: {
                                    type: 'string',
                                    example:
                                        'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
                                    description: 'User unique identifier',
                                },
                                email: {
                                    type: 'string',
                                    example: 'john.doe@example.com',
                                    description: 'User email address',
                                },
                                firstName: {
                                    type: 'string',
                                    example: 'John',
                                    description: 'User first name',
                                },
                                lastName: {
                                    type: 'string',
                                    example: 'Doe',
                                    description: 'User last name',
                                },
                                avatar: {
                                    type: 'object',
                                    description:
                                        'User avatar with multiple size variants',
                                    nullable: true,
                                    properties: {
                                        id: {
                                            type: 'number',
                                            example: 1,
                                            description: 'Avatar media file ID',
                                        },
                                        originalName: {
                                            type: 'string',
                                            example: 'profile-picture.jpg',
                                            description: 'Original filename',
                                        },
                                        url: {
                                            type: 'string',
                                            example:
                                                'https://cdn.example.com/media/1/profile-picture.jpg',
                                            description: 'Primary avatar URL',
                                        },
                                        thumbnail: {
                                            type: 'string',
                                            example:
                                                'https://cdn.example.com/media/1/thumbnail/profile-picture.jpg',
                                            description:
                                                'Thumbnail variant URL',
                                        },
                                        medium: {
                                            type: 'string',
                                            example:
                                                'https://cdn.example.com/media/1/medium/profile-picture.jpg',
                                            description: 'Medium variant URL',
                                        },
                                        original: {
                                            type: 'string',
                                            example:
                                                'https://cdn.example.com/media/1/profile-picture.jpg',
                                            description: 'Original size URL',
                                        },
                                    },
                                },
                                role: {
                                    type: 'string',
                                    example: 'user',
                                    description: 'User role in the system',
                                },
                                createdAt: {
                                    type: 'string',
                                    example: '2024-01-15T10:30:00.000Z',
                                    description: 'Account creation timestamp',
                                },
                                updatedAt: {
                                    type: 'string',
                                    example: '2024-01-15T10:30:00.000Z',
                                    description: 'Last update timestamp',
                                },
                            },
                        },
                        leaderboard: {
                            type: 'object',
                            description:
                                'User leaderboard statistics and metrics',
                            properties: {
                                totalPoints: {
                                    type: 'number',
                                    example: 1250.75,
                                    description:
                                        'Total points earned across all courses',
                                },
                                totalTestsCompleted: {
                                    type: 'number',
                                    example: 15,
                                    description:
                                        'Total number of tests completed',
                                },
                                averageScore: {
                                    type: 'number',
                                    example: 88.5,
                                    description:
                                        'Overall average score across all tests',
                                },
                                coursesEnrolled: {
                                    type: 'number',
                                    example: 3,
                                    description:
                                        'Number of courses enrolled in',
                                },
                                bestRank: {
                                    type: 'number',
                                    example: 2,
                                    nullable: true,
                                    description:
                                        'Best rank achieved across all courses',
                                },
                                recentActivity: {
                                    type: 'array',
                                    description:
                                        'Recent activity in the last 5 courses',
                                    items: {
                                        type: 'object',
                                        description:
                                            'Leaderboard entry details',
                                    },
                                },
                            },
                        },
                        organization: {
                            type: 'object',
                            description:
                                'Organization information if user belongs to an organization',
                            nullable: true,
                            properties: {
                                id: {
                                    type: 'string',
                                    example:
                                        'org-a1b2c3d4-e5f6-7890-abcd-ef1234567890',
                                    description:
                                        'Organization unique identifier',
                                },
                                name: {
                                    type: 'string',
                                    example: 'Acme Corporation',
                                    description: 'Organization name',
                                },
                                avatar: {
                                    type: 'string',
                                    example:
                                        'https://cdn.example.com/logos/acme-corp.png',
                                    description: 'Organization logo URL',
                                    nullable: true,
                                },
                            },
                        },
                        branch: {
                            type: 'object',
                            description:
                                'Branch information if user belongs to a specific branch',
                            nullable: true,
                            properties: {
                                id: {
                                    type: 'string',
                                    example:
                                        'branch-b1c2d3e4-f5g6-7890-bcde-fg1234567890',
                                    description: 'Branch unique identifier',
                                },
                                name: {
                                    type: 'string',
                                    example: 'Downtown Branch',
                                    description: 'Branch name',
                                },
                                email: {
                                    type: 'string',
                                    example: 'downtown@acmecorp.com',
                                    description: 'Branch email address',
                                    nullable: true,
                                },
                                address: {
                                    type: 'string',
                                    example:
                                        '123 Main Street, Downtown, City 12345',
                                    description: 'Branch physical address',
                                    nullable: true,
                                },
                                contactNumber: {
                                    type: 'string',
                                    example: '+1-555-123-4567',
                                    description: 'Branch contact phone number',
                                    nullable: true,
                                },
                                managerName: {
                                    type: 'string',
                                    example: 'John Smith',
                                    description: 'Branch manager name',
                                    nullable: true,
                                },
                            },
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Invalid email or password',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Invalid credentials' },
                error: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input format',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    examples: [
                        ['Please provide a valid email address'],
                        ['Password is required'],
                    ],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    async signIn(
        @Body() signInDto: SignInDto,
    ): Promise<StandardApiResponse<SessionResponseDto>> {
        this.logger.log(`Sign in attempt for email: ${signInDto.email}`);
        return this.authService.signIn(signInDto);
    }

    @Post('refresh')
    @HttpCode(HttpStatus.OK)
    @Throttle({ default: { limit: 10, ttl: 60000 } }) // 10 attempts per minute
    @ApiOperation({
        summary: '🔄 Refresh Authentication Token',
        description: `
      **Refreshes expired access tokens using refresh tokens**
      
      This endpoint handles token refresh functionality with:
      - Refresh token validation
      - New access token generation
      - Optional refresh token rotation
      - Session continuity maintenance
      - Security token validation
      
      **Security Features:**
      - Rate limiting: 10 attempts per minute
      - Refresh token validation
      - Token rotation security
      - Expired token cleanup
      - Invalid token detection
      
      **Refresh Flow:**
      1. Client submits refresh token
      2. System validates refresh token
      3. New access token is generated
      4. Optional new refresh token provided
      5. Old refresh token is invalidated
      6. New tokens returned to client
      
      **Use Cases:**
      - Automatic token refresh
      - Session extension
      - Seamless user experience
      - Background token management
    `,
        operationId: 'refreshAuthToken',
    })
    @ApiBody({
        type: RefreshTokenDto,
        description: 'Refresh token for generating new access token',
        examples: {
            'token-refresh': {
                summary: '🔄 Token Refresh Request',
                description: 'Refresh access token using valid refresh token',
                value: {
                    refreshToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Token successfully refreshed',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Token refresh success status',
                },
                message: {
                    type: 'string',
                    example: 'Token refreshed successfully',
                    description: 'Success confirmation message',
                },
                data: {
                    type: 'object',
                    description: 'New authentication tokens',
                    properties: {
                        accessToken: {
                            type: 'string',
                            example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
                            description:
                                'New JWT access token for API authentication',
                        },
                        refreshToken: {
                            type: 'string',
                            example: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
                            description:
                                'New JWT refresh token (if rotation enabled)',
                        },
                        expiresIn: {
                            type: 'number',
                            example: 3600,
                            description:
                                'Access token expiration time in seconds',
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Invalid or expired refresh token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: {
                    type: 'string',
                    example: 'Invalid or expired refresh token',
                },
                error: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid refresh token format',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    examples: [['Refresh token is required']],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    async refreshToken(
        @Body() refreshTokenDto: RefreshTokenDto,
    ): Promise<StandardApiResponse<any>> {
        this.logger.log('Token refresh request received');
        return this.authService.refreshToken(refreshTokenDto);
    }

    @Post('forgot-password')
    @HttpCode(HttpStatus.OK)
    @Throttle({ default: { limit: 3, ttl: 300000 } }) // 3 attempts per 5 minutes
    @ApiOperation({
        summary: '🔑 Request Password Reset',
        description: `
      **Initiates secure password reset flow via email**
      
      This endpoint handles password reset requests with:
      - Email validation and user lookup
      - Secure reset token generation
      - Password reset email dispatch
      - Rate limiting for security
      - Token expiration management
      
      **Security Features:**
      - Rate limiting: 3 attempts per 5 minutes
      - Secure token generation
      - Time-limited reset tokens
      - Email validation
      - No user enumeration (same response for valid/invalid emails)
      
      **Reset Flow:**
      1. User submits email address
      2. System validates email format
      3. Reset token is generated (if user exists)
      4. Password reset email is sent
      5. User receives reset link
      6. Token is valid for limited time
      
      **Use Cases:**
      - Forgotten password recovery
      - Account security compromise
      - Password strength upgrades
      - Emergency account access
    `,
        operationId: 'requestPasswordReset',
    })
    @ApiBody({
        type: ForgotPasswordDto,
        description: 'Email address for password reset',
        examples: {
            'password-reset-request': {
                summary: '📧 Password Reset Request',
                description: 'Request password reset for existing account',
                value: {
                    email: 'john.doe@example.com',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Password reset email sent (if account exists)',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Request processing status',
                },
                message: {
                    type: 'string',
                    example:
                        'If an account with this email exists, a password reset link has been sent',
                    description: 'Generic success message for security',
                },
                data: {
                    type: 'null',
                    description: 'No data returned for security reasons',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid email format',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    examples: [['Please provide a valid email address']],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    async forgotPassword(
        @Body() forgotPasswordDto: ForgotPasswordDto,
    ): Promise<StandardApiResponse<any>> {
        this.logger.log(
            `Password reset requested for email: ${forgotPasswordDto.email}`,
        );
        return this.authService.forgotPassword(forgotPasswordDto);
    }

    @Post('reset-password')
    @HttpCode(HttpStatus.OK)
    @Throttle({ default: { limit: 3, ttl: 300000 } }) // 3 attempts per 5 minutes
    @ApiOperation({
        summary: '🔐 Reset Password with Token',
        description: `
      **Completes password reset using secure token**
      
      This endpoint finalizes the password reset process:
      - Validates reset token authenticity
      - Verifies token expiration
      - Updates password securely
      - Invalidates reset token
      - Confirms password change
      
      **Security Features:**
      - Token validation and expiration
      - Strong password requirements
      - Secure password hashing
      - Token invalidation after use
      - Rate limiting protection
      
      **Reset Completion:**
      1. User submits token and new password
      2. System validates token
      3. Password requirements are checked
      4. Password is securely hashed
      5. User password is updated
      6. Reset token is invalidated
      7. Success confirmation sent
      
      **Use Cases:**
      - Complete password reset flow
      - Security incident recovery
      - Account access restoration
      - Password update from email link
    `,
        operationId: 'resetPassword',
    })
    @ApiBody({
        type: ResetPasswordDto,
        description: 'Reset token and new password',
        examples: {
            'password-reset': {
                summary: '🔑 Complete Password Reset',
                description: 'Reset password using email token',
                value: {
                    token: 'abc123-reset-token-xyz789',
                    newPassword: 'NewSecurePass123!',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Password successfully reset',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Password reset success status',
                },
                message: {
                    type: 'string',
                    example: 'Password has been successfully reset',
                    description: 'Reset confirmation message',
                },
                data: {
                    type: 'null',
                    description: 'No additional data for security',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid token or password requirements not met',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'string',
                    examples: [
                        'Invalid or expired reset token',
                        'Password must be at least 8 characters long',
                        'Password must contain uppercase, lowercase, number, and special character',
                    ],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    async resetPassword(
        @Body() resetPasswordDto: ResetPasswordDto,
    ): Promise<StandardApiResponse<any>> {
        this.logger.log(`Password reset attempt with token`);
        return this.authService.resetPassword(resetPasswordDto);
    }

    @Post('verify-email')
    @HttpCode(HttpStatus.OK)
    @SkipThrottle() // Allow email verification without limits
    @ApiOperation({
        summary: '📧 Verify Email Address',
        description: `
      **Verifies user email address using verification token**
      
      This endpoint handles email verification with:
      - Token validation and verification
      - Account activation
      - Email confirmation
      - User status updates
      - Welcome flow initiation
      
      **Verification Features:**
      - No rate limiting for user convenience
      - Token authenticity validation
      - Account activation
      - Status confirmation
      - Welcome process initiation
      
      **Verification Flow:**
      1. User clicks email verification link
      2. Token is extracted and validated
      3. Account is marked as verified
      4. User receives confirmation
      5. Welcome flow may be initiated
      
      **Use Cases:**
      - New account email verification
      - Email address confirmation
      - Account activation
      - Security verification
    `,
        operationId: 'verifyEmailAddress',
    })
    @ApiBody({
        type: VerifyEmailDto,
        description: 'Email verification token',
        examples: {
            'email-verification': {
                summary: '✅ Email Verification',
                description: 'Verify email address using token from email',
                value: {
                    token: 'abc123-verify-email-xyz789',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Email successfully verified',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Email verification success status',
                },
                message: {
                    type: 'string',
                    example: 'Email address verified successfully',
                    description: 'Verification confirmation message',
                },
                data: {
                    type: 'null',
                    description: 'No additional data returned',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid or expired verification token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'string',
                    example: 'Invalid or expired verification token',
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    async verifyEmail(
        @Body() verifyEmailDto: VerifyEmailDto,
    ): Promise<StandardApiResponse<any>> {
        this.logger.log(`Email verification attempt`);
        return this.authService.verifyEmail(verifyEmailDto);
    }

    @Post('resend-verification')
    @HttpCode(HttpStatus.OK)
    @Throttle({ default: { limit: 3, ttl: 300000 } }) // 3 attempts per 5 minutes
    @ApiOperation({
        summary: '🔄 Resend Email Verification',
        description: `
      **Resends email verification for unverified accounts**
      
      This endpoint handles verification email resending:
      - Account verification status check
      - New verification token generation
      - Verification email dispatch
      - Rate limiting for abuse prevention
      - Token expiration management
      
      **Security Features:**
      - Rate limiting: 3 attempts per 5 minutes
      - Account status validation
      - New token generation
      - Abuse prevention
      - Expiration time limits
      
      **Resend Flow:**
      1. User requests verification resend
      2. Account verification status is checked
      3. New verification token is generated
      4. Verification email is sent
      5. User receives new verification link
      
      **Use Cases:**
      - Lost verification email
      - Expired verification token
      - Email delivery issues
      - Account activation assistance
    `,
        operationId: 'resendEmailVerification',
    })
    @ApiBody({
        type: ResendVerificationDto,
        description: 'Email address for verification resend',
        examples: {
            'resend-verification': {
                summary: '📧 Resend Verification Email',
                description:
                    'Request new verification email for unverified account',
                value: {
                    email: 'john.doe@example.com',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description:
            '✅ Verification email sent (if account exists and unverified)',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Resend request processing status',
                },
                message: {
                    type: 'string',
                    example:
                        'If an unverified account exists, a verification email has been sent',
                    description: 'Generic success message for security',
                },
                data: {
                    type: 'null',
                    description: 'No data returned for security reasons',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid email format',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    examples: [['Please provide a valid email address']],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    async resendVerification(
        @Body() resendVerificationDto: ResendVerificationDto,
    ): Promise<StandardApiResponse<any>> {
        this.logger.log(
            `Resend verification requested for email: ${resendVerificationDto.email}`,
        );
        return this.authService.resendVerification(resendVerificationDto);
    }

    @Get('token-info')
    @UseGuards(JwtAuthGuard)
    @ApiOperation({
        summary: '🔑 Get Token Information',
        description: `
      **Retrieves information about the authenticated user's token**
      
      This endpoint handles token information retrieval:
      - Token validation
      - User information extraction
      - Token expiration check
      - Token type identification
      
      **Security Features:**
      - Token validation
      - User information extraction
      - Token expiration check
      - Token type identification
      
      **Token Information:**
      - Token type
      - Token expiration
      - User information
      
      **Use Cases:**
      - Token information retrieval
      - Security token validation
      - User information access
    `,
        operationId: 'getTokenInfo',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Token information retrieved',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Token information retrieval success status',
                },
                message: {
                    type: 'string',
                    example: 'Token information retrieved successfully',
                    description: 'Success confirmation message',
                },
                data: {
                    type: 'object',
                    description: 'Token information',
                    properties: {
                        tokenType: {
                            type: 'string',
                            example: 'Bearer',
                            description: 'Token type',
                        },
                        expiresIn: {
                            type: 'number',
                            example: 3600,
                            description: 'Token expiration time in seconds',
                        },
                        user: {
                            type: 'object',
                            description: 'Authenticated user information',
                            properties: {
                                id: {
                                    type: 'string',
                                    example:
                                        'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
                                    description: 'User unique identifier',
                                },
                                email: {
                                    type: 'string',
                                    example: 'john.doe@example.com',
                                    description: 'User email address',
                                },
                                name: {
                                    type: 'string',
                                    example: 'John Doe',
                                    description: 'User display name',
                                },
                                createdAt: {
                                    type: 'string',
                                    example: '2024-01-15T10:30:00.000Z',
                                    description: 'Account creation timestamp',
                                },
                            },
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Invalid or expired token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: {
                    type: 'string',
                    example: 'Invalid or expired token',
                },
                error: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid token format',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    examples: [['Invalid token format']],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiBearerAuth()
    async getTokenInfo(
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardApiResponse<any>> {
        this.logger.log('Token information retrieval request received');
        return this.authService.getTokenInfo(req.user);
    }

    @Post('send-invitation')
    @UseGuards(JwtAuthGuard)
    @Throttle({ default: { limit: 10, ttl: 300000 } }) // 10 invitations per 5 minutes
    @ApiOperation({
        summary: '📧 Send User Invitation',
        description: `
      **Sends an invitation email to a new user to join the platform**
      
      This endpoint handles user invitation functionality with the following features:
      - Email invitation sending
      - Customizable invitation messages
      - Organization/branch assignment
      - Secure invitation token generation
      - Email delivery tracking
      
      **Security Features:**
      - Rate limiting: 10 invitations per 5 minutes per user
      - Authentication required (JWT)
      - Invitation token with expiration
      - Email validation
      - Duplicate invitation prevention
      
      **Invitation Flow:**
      1. Authenticated user sends invitation
      2. System validates email and permissions
      3. Secure invitation token is generated
      4. Invitation email is sent to recipient
      5. Token expires after configured time
      6. Recipient can use token to register
      
      **Use Cases:**
      - Team member onboarding
      - Student invitation to courses
      - Organization member recruitment
      - Branch-specific invitations
    `,
        operationId: 'sendInvitation',
    })
    @ApiBody({
        type: SendInvitationDto,
        description:
            'Invitation details including recipient email and optional message',
        examples: {
            'basic-invitation': {
                summary: '✉️ Basic Invitation',
                description: 'Simple invitation with just email address',
                value: {
                    email: 'newuser@example.com',
                },
            },
            'team-invitation': {
                summary: '👥 Team Invitation',
                description: 'Invitation with custom message and organization',
                value: {
                    email: 'teammate@company.com',
                    message:
                        "Join our team on the trainpro platform! We're excited to have you aboard.",
                    organizationId: 'org_123456789',
                },
            },
            'branch-invitation': {
                summary: '🏢 Branch-Specific Invitation',
                description:
                    'Invitation to specific branch within organization',
                value: {
                    email: 'employee@company.com',
                    message: 'Welcome to our Sales division!',
                    organizationId: 'org_123456789',
                    branchId: 'branch_sales_001',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Invitation sent successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Invitation sending success status',
                },
                message: {
                    type: 'string',
                    example: 'Invitation sent successfully',
                    description: 'Success confirmation message',
                },
                data: {
                    type: 'object',
                    description: 'Invitation details',
                    properties: {
                        invitationId: {
                            type: 'string',
                            example: 'inv_a1b2c3d4e5f6',
                            description: 'Unique invitation identifier',
                        },
                        email: {
                            type: 'string',
                            example: 'newuser@example.com',
                            description: 'Recipient email address',
                        },
                        expiresAt: {
                            type: 'string',
                            example: '2024-01-22T10:30:00.000Z',
                            description: 'Invitation expiration timestamp',
                        },
                        invitedBy: {
                            type: 'string',
                            example: 'John Doe',
                            description: 'Name of user who sent invitation',
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data or user already exists',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    examples: [
                        ['Please provide a valid email address'],
                        ['User with this email already exists'],
                        ['Invalid organization or branch ID'],
                    ],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Authentication required',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: {
                    type: 'string',
                    example: 'Unauthorized',
                },
                error: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.TOO_MANY_REQUESTS,
        description: '⏰ Rate limit exceeded',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 429 },
                message: {
                    type: 'string',
                    example:
                        'Too many invitation requests. Please try again later.',
                },
                error: { type: 'string', example: 'Too Many Requests' },
            },
        },
    })
    @ApiBearerAuth()
    async sendInvitation(
        @Body() sendInvitationDto: SendInvitationDto,
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardApiResponse<any>> {
        this.logger.log(
            `Sending invitation to ${sendInvitationDto.email} from user ${req.user.id}`,
        );
        return this.authService.sendInvitation(sendInvitationDto, req.user.id);
    }

    @Post('validate-invitation')
    @SkipThrottle()
    @ApiOperation({
        summary: '🔍 Validate Invitation Token',
        description: `
      **Validates an invitation token and returns invitation details**
      
      This endpoint handles invitation token validation with the following features:
      - Token authenticity verification
      - Expiration date checking
      - Invitation details retrieval
      - Security token validation
      - Pre-registration validation
      
      **Security Features:**
      - Cryptographic token validation
      - Expiration time enforcement
      - Token tampering detection
      - Rate limiting bypass for validation
      - Secure token parsing
      
      **Validation Flow:**
      1. User receives invitation email
      2. User clicks invitation link with token
      3. Frontend calls this endpoint to validate
      4. System verifies token authenticity
      5. Invitation details are returned if valid
      6. User can proceed with registration
      
      **Use Cases:**
      - Pre-registration token validation
      - Invitation link verification
      - Registration form pre-population
      - Token expiration checking
    `,
        operationId: 'validateInvitation',
    })
    @ApiBody({
        type: ValidateInvitationDto,
        description: 'Invitation token from email link',
        examples: {
            'token-validation': {
                summary: '🎫 Token Validation',
                description: 'Validate invitation token from email',
                value: {
                    token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6Im5ld3VzZXJAZXhhbXBsZS5jb20iLCJ0eXBlIjoiaW52aXRhdGlvbiIsImlhdCI6MTcwNTMxNzAwMCwiZXhwIjoxNzA1OTIxODAwfQ.ABC123...',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Invitation token is valid',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Token validation success status',
                },
                message: {
                    type: 'string',
                    example: 'Invitation token is valid',
                    description: 'Validation confirmation message',
                },
                data: {
                    type: 'object',
                    description: 'Invitation details from valid token',
                    properties: {
                        email: {
                            type: 'string',
                            example: 'newuser@example.com',
                            description:
                                'Email address the invitation was sent to',
                        },
                        invitedBy: {
                            type: 'object',
                            description: 'Details of user who sent invitation',
                            properties: {
                                name: {
                                    type: 'string',
                                    example: 'John Doe',
                                    description: 'Name of inviting user',
                                },
                                email: {
                                    type: 'string',
                                    example: 'john.doe@company.com',
                                    description: 'Email of inviting user',
                                },
                            },
                        },
                        message: {
                            type: 'string',
                            example: 'Join our team on the trainpro platform!',
                            description: 'Custom message from inviter',
                        },
                        organizationId: {
                            type: 'string',
                            example: 'org_123456789',
                            description:
                                'Organization ID if invitation is org-specific',
                            nullable: true,
                        },
                        branchId: {
                            type: 'string',
                            example: 'branch_sales_001',
                            description:
                                'Branch ID if invitation is branch-specific',
                            nullable: true,
                        },
                        expiresAt: {
                            type: 'string',
                            example: '2024-01-22T10:30:00.000Z',
                            description: 'Invitation expiration timestamp',
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid or expired invitation token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    examples: [
                        ['Invalid invitation token'],
                        ['Invitation token has expired'],
                        ['Malformed token format'],
                        ['Invitation token is required'],
                    ],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.GONE,
        description: '🚫 Invitation has been revoked or used',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 410 },
                message: {
                    type: 'string',
                    example: 'Invitation has been revoked or already used',
                },
                error: { type: 'string', example: 'Gone' },
            },
        },
    })
    validateInvitation(
        @Body() validateInvitationDto: ValidateInvitationDto,
    ): StandardApiResponse<any> {
        this.logger.log(
            `Validating invitation token: ${validateInvitationDto.token.substring(0, 20)}...`,
        );
        return this.authService.validateInvitation(validateInvitationDto);
    }

    @Post('re-invite-all')
    @UseGuards(JwtAuthGuard)
    @Throttle({ default: { limit: 1, ttl: 3600000 } }) // 1 attempt per hour
    @ApiOperation({
        summary: '🎓 Send Re-engagement to All Users',
        description: `
      **Sends re-engagement emails to all existing users in the system**
      
      This endpoint handles organizational re-engagement campaigns with the following features:
      - Fetches all users from the system
      - Sends personalized re-engagement emails to each user
      - Encourages users to start actively using the platform
      - Provides detailed reporting of success/failure rates
      - Implements anti-spam measures with randomized delays
      
      **Security Features:**
      - Rate limiting: 1 attempt per hour per user (to prevent abuse)
      - Authentication required (JWT)
      - Admin/elevated permissions recommended
      - Batch operation logging
      - Email delivery tracking
      
      **Re-engagement Flow:**
      1. Authenticated admin initiates bulk re-engagement campaign
      2. System fetches all registered users
      3. Personal re-engagement emails are generated for each user
      4. Emails are queued with randomized delays to avoid spam detection
      5. Detailed report of success/failure is returned
      6. Failed emails are logged for retry attempts
      
      **Email Content:**
      - Personalized greeting with user's name
      - Organizational invitation to start using the platform
      - Highlights of available features and learning opportunities
      - Clear call-to-action to login and begin learning
      - Professional and engaging tone from the organization
      - Links to courses, tests, dashboard, and support
      
      **Use Cases:**
      - User re-engagement campaigns
      - Platform adoption initiatives
      - Learning program launch announcements
      - Organizational onboarding communication
      - Course enrollment campaigns
    `,
        operationId: 'sendReInviteToAllUsers',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Re-engagement emails sent successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Re-engagement sending success status',
                },
                message: {
                    type: 'string',
                    example:
                        'Re-engagement emails sent successfully. 25 emails queued, 0 failed.',
                    description: 'Detailed success confirmation message',
                },
                data: {
                    type: 'object',
                    description: 'Detailed re-engagement statistics',
                    properties: {
                        totalUsers: {
                            type: 'number',
                            example: 25,
                            description: 'Total number of users in the system',
                        },
                        successCount: {
                            type: 'number',
                            example: 25,
                            description:
                                'Number of emails successfully queued',
                        },
                        failedCount: {
                            type: 'number',
                            example: 0,
                            description: 'Number of emails that failed to queue',
                        },
                        failedEmails: {
                            type: 'array',
                            items: { type: 'string' },
                            example: [],
                            description:
                                'List of email addresses that failed (if any)',
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ No users found or operation failed',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'string',
                    example: 'No users found in the system',
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Authentication required',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: {
                    type: 'string',
                    example: 'Unauthorized',
                },
                error: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.TOO_MANY_REQUESTS,
        description: '⏰ Rate limit exceeded',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 429 },
                message: {
                    type: 'string',
                    example: 'Too many re-invite requests. Please try again later.',
                },
                error: { type: 'string', example: 'Too Many Requests' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description: '💥 Server error during email sending',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: {
                    type: 'string',
                    example: 'Failed to send re-invite emails to users',
                },
                error: { type: 'string', example: 'Internal Server Error' },
            },
        },
    })
    @ApiBearerAuth()
    async sendReInviteToAllUsers(
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardApiResponse<any>> {
        this.logger.log(
            `User re-engagement campaign initiated by user ${req.user.id}`,
        );
        return this.authService.sendReInviteToAllUsers();
    }
}

/*
 * Class #14: AuthModule
 * Source: auth/auth.module.ts:41
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 26 characters (1 lines)
 */
export class AuthModule {}

/*
 * Class #15: AuthService
 * Source: auth/auth.service.ts:43
 * Type: Exported Class
 * Methods: 56
 * Properties: 327
 * Decorators: 7
 * Complexity: 289
 * Size: 36344 characters (1058 lines)
 */
export class AuthService {
    private readonly saltRounds = 12;

    constructor(
        private readonly userService: UserService,
        private readonly tokenManagerService: TokenManagerService,
        private readonly leaderboardService: LeaderboardService,
        private readonly emailTemplateService: EmailTemplateService,
        private readonly emailQueueService: EmailQueueService,
        private readonly configService: ConfigService,
    ) {}

    /**
     * Transform MediaFile avatar to response format with variants
     */
    private transformAvatarForResponse(avatar?: MediaFile):
        | {
              id: number;
              originalName?: string;
              url?: string;
              thumbnail?: string;
              medium?: string;
              original?: string;
          }
        | undefined {
        if (!avatar) return undefined;

        // Base response with original file data
        const response = {
            id: avatar.id,
            originalName: avatar.originalName,
            url: avatar.url,
            original: avatar.url,
            thumbnail: avatar.url, // fallback to original if no thumbnail
            medium: avatar.url, // fallback to original if no medium
        };

        // If variants are loaded, use them to populate specific URLs
        if (avatar.variants && avatar.variants.length > 0) {
            avatar.variants.forEach(variant => {
                if (variant.variant === ImageVariant.THUMBNAIL) {
                    response.thumbnail = variant.url;
                } else if (variant.variant === ImageVariant.MEDIUM) {
                    response.medium = variant.url;
                }
            });
        }

        return response;
    }

    async signUp(
        createUserDto: CreateUserDto,
    ): Promise<StandardApiResponse<SignUpResponseDto>> {
        const {
            email,
            password,
            firstName,
            lastName,
            avatar,
            invitationToken,
        } = createUserDto;

        // Check if user already exists
        const existingUser = await this.userService.findByEmail(email);
        if (existingUser) {
            throw new ConflictException('User with this email already exists');
        }

        // Validate invitation token if provided
        let invitationData: {
            organizationId?: string;
            branchId?: string;
            email?: string;
        } | null = null;
        if (invitationToken) {
            const tokenValidation =
                this.tokenManagerService.validateInvitationToken(
                    invitationToken,
                );
            if (!tokenValidation.isValid) {
                throw new BadRequestException(
                    'Invalid or expired invitation token',
                );
            }

            // Ensure email matches invitation
            if (tokenValidation.email !== email) {
                throw new BadRequestException(
                    'Email does not match invitation',
                );
            }

            invitationData = tokenValidation.data as {
                organizationId?: string;
                branchId?: string;
                email?: string;
            };
        }

        // Hash password
        const hashedPassword = await bcrypt.hash(password, this.saltRounds);

        // Create user with org/branch from invitation if available
        await this.userService.create({
            email,
            password: hashedPassword,
            firstName,
            lastName,
            avatar,
        });

        // Fetch the created user
        const user = await this.userService.findByEmail(email);
        if (!user) {
            throw new Error('Failed to retrieve user after creation');
        }

        // Assign organization and branch if from invitation
        if (
            invitationData &&
            (invitationData.organizationId || invitationData.branchId)
        ) {
            await this.userService.assignOrgAndBranch(
                user.id,
                invitationData.organizationId,
                invitationData.branchId,
            );
        }

        // Revoke invitation tokens for this email
        if (invitationToken) {
            this.tokenManagerService.revokeInvitationTokensByEmail(email);
        }

        // Send welcome email notification (not tokens)
        await this.sendWelcomeEmail(user);

        // Fetch updated user with org/branch details if assigned
        const updatedUser =
            await this.userService.findByEmailWithFullDetails(email);

        if (!updatedUser) {
            throw new Error('Failed to retrieve user after creation');
        }

        // Return user without password
        const userResponse: UserResponseDto = {
            uid: updatedUser.id,
            email: updatedUser.email,
            firstName: updatedUser.firstName,
            lastName: updatedUser.lastName,
            avatar: this.transformAvatarForResponse(updatedUser.avatar),
            role: updatedUser.role,
            createdAt: updatedUser.createdAt,
            updatedAt: updatedUser.updatedAt,
        };

        return {
            success: true,
            data: {
                user: userResponse,
                organization: updatedUser.orgId
                    ? {
                          id: updatedUser.orgId.id,
                          name: updatedUser.orgId.name,
                          avatar: updatedUser.orgId.logoUrl,
                      }
                    : undefined,
                branch: updatedUser.branchId
                    ? {
                          id: updatedUser.branchId.id,
                          name: updatedUser.branchId.name,
                          email: updatedUser.branchId.email,
                          address: updatedUser.branchId.address,
                          contactNumber: updatedUser.branchId.contactNumber,
                          managerName: updatedUser.branchId.managerName,
                      }
                    : undefined,
            },
            message:
                'Account created successfully. Please sign in with your credentials.',
        };
    }

    async signIn(
        signInDto: SignInDto,
    ): Promise<StandardApiResponse<SessionResponseDto>> {
        const { email, password } = signInDto;

        // Find user by email with full org/branch details
        const user = await this.userService.findByEmailWithFullDetails(email);
        if (!user) {
            throw new UnauthorizedException('Invalid credentials');
        }

        // Verify password
        const isPasswordValid = await bcrypt.compare(password, user.password);
        if (!isPasswordValid) {
            throw new UnauthorizedException('Invalid credentials');
        }

        // Generate JWT tokens
        const tokenPair = await this.tokenManagerService.generateTokenPair({
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            orgId: user.orgId?.id,
            branchId: user.branchId?.id,
        });

        // Get user leaderboard stats
        const userStats = await this.leaderboardService.getUserOverallStats(
            user.id,
        );
        const leaderboardData = plainToClass(UserStatsResponseDto, userStats, {
            excludeExtraneousValues: true,
        });

        // Return user without password
        const userResponse: UserResponseDto = {
            uid: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            avatar: this.transformAvatarForResponse(user.avatar),
            role: user.role,
            createdAt: user.createdAt,
            updatedAt: user.updatedAt,
        };

        return {
            success: true,
            data: {
                accessToken: tokenPair.accessToken,
                refreshToken: tokenPair.refreshToken,
                expiresIn: tokenPair.expiresIn,
                user: userResponse,
                leaderboard: leaderboardData,
                organization: user.orgId
                    ? {
                          id: user.orgId.id,
                          name: user.orgId.name,
                          avatar: user.orgId.logoUrl,
                      }
                    : undefined,
                branch: user.branchId
                    ? {
                          id: user.branchId.id,
                          name: user.branchId.name,
                          email: user.branchId.email,
                          address: user.branchId.address,
                          contactNumber: user.branchId.contactNumber,
                          managerName: user.branchId.managerName,
                      }
                    : undefined,
            },
            message: 'User signed in successfully',
        };
    }

    async validateUser(email: string, password: string): Promise<any> {
        const user = await this.userService.findByEmail(email);
        if (user && (await bcrypt.compare(password, user.password))) {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const { password: _, ...result } = user;
            return result;
        }
        return null;
    }

    async findById(id: string): Promise<User | null> {
        return await this.userService.findOne(id);
    }

    async forgotPassword(
        forgotPasswordDto: ForgotPasswordDto,
    ): Promise<StandardApiResponse<any>> {
        const { email } = forgotPasswordDto;

        // Check if user exists
        const user = await this.userService.findByEmail(email);
        if (!user) {
            // Return success even if user doesn't exist for security
            return {
                success: true,
                message:
                    'If an account with that email exists, a password reset link has been sent.',
            };
        }

        // Revoke any existing password reset tokens for this user
        this.tokenManagerService.revokeUserSpecialTokens(
            user.id,
            'password_reset',
        );

        // Generate password reset token
        const { token, expiresAt } =
            this.tokenManagerService.generatePasswordResetToken(
                user.id,
                user.email,
            );

        // Send password reset email
        await this.sendPasswordResetEmail(user, token, expiresAt);

        return {
            success: true,
            message:
                'If an account with that email exists, a password reset link has been sent.',
        };
    }

    async resetPassword(
        resetPasswordDto: ResetPasswordDto,
    ): Promise<StandardApiResponse<any>> {
        const { token, password, confirmPassword } = resetPasswordDto;

        if (password !== confirmPassword) {
            throw new BadRequestException('Passwords do not match');
        }

        // Validate reset token
        const tokenValidation =
            this.tokenManagerService.validatePasswordResetToken(token);
        if (!tokenValidation.isValid || !tokenValidation.userId) {
            throw new BadRequestException('Invalid or expired reset token');
        }

        // Find user
        const user = await this.userService.findById(tokenValidation.userId);
        if (!user) {
            throw new NotFoundException('User not found');
        }

        // Hash new password
        const hashedPassword = await bcrypt.hash(password, this.saltRounds);

        // Update user password
        await this.userService.updatePassword(user.id, hashedPassword);

        // Revoke all tokens for the user
        this.tokenManagerService.revokeAllUserTokens(user.id);

        // Consume the reset token
        this.tokenManagerService.consumeSpecialToken(token);

        // Send password changed confirmation email
        await this.sendPasswordChangedEmail(user);

        return {
            success: true,
            message: 'Password has been successfully reset.',
        };
    }

    async verifyEmail(
        verifyEmailDto: VerifyEmailDto,
    ): Promise<StandardApiResponse<any>> {
        const { token } = verifyEmailDto;

        // Validate email verification token
        const tokenValidation =
            this.tokenManagerService.validateEmailVerificationToken(token);
        if (!tokenValidation.isValid || !tokenValidation.userId) {
            throw new BadRequestException(
                'Invalid or expired verification token',
            );
        }

        // Find user
        const user = await this.userService.findById(tokenValidation.userId);
        if (!user) {
            throw new NotFoundException('User not found');
        }

        // Mark email as verified
        await this.userService.verifyEmail(user.id);

        // Consume the verification token
        this.tokenManagerService.consumeSpecialToken(token);

        return {
            success: true,
            message: 'Email has been successfully verified.',
        };
    }

    async resendVerification(
        resendVerificationDto: ResendVerificationDto,
    ): Promise<StandardApiResponse<any>> {
        const { email } = resendVerificationDto;

        // Check if user exists
        const user = await this.userService.findByEmail(email);
        if (!user) {
            throw new NotFoundException('User not found');
        }

        // Check if email is already verified
        if (user.emailVerified) {
            return {
                success: true,
                message: 'Email is already verified',
            };
        }

        // Revoke any existing verification tokens for this user
        this.tokenManagerService.revokeUserSpecialTokens(
            user.id,
            'email_verification',
        );

        // Generate new verification token
        const { token, expiresAt } =
            this.tokenManagerService.generateEmailVerificationToken(
                user.id,
                user.email,
            );

        // Send verification email
        await this.sendEmailVerificationEmail(user, token, expiresAt);

        return {
            success: true,
            message: 'Verification email sent',
        };
    }

    /**
     * Refresh access token using refresh token
     */
    async refreshToken(
        refreshTokenDto: RefreshTokenDto,
    ): Promise<StandardApiResponse<any>> {
        const { refreshToken } = refreshTokenDto;

        try {
            // Validate refresh token
            const validation =
                this.tokenManagerService.validateRefreshToken(refreshToken);

            if (!validation.isValid) {
                throw new UnauthorizedException(
                    'Invalid or expired refresh token',
                );
            }

            // Find user by ID from refresh token
            const user = await this.userService.findById(validation.userId);
            if (!user) {
                throw new UnauthorizedException('User not found');
            }

            // Generate new token pair
            const newTokenPair =
                await this.tokenManagerService.refreshAccessToken(
                    refreshToken,
                    {
                        id: user.id,
                        email: user.email,
                        firstName: user.firstName,
                        lastName: user.lastName,
                        orgId: user.orgId?.id,
                        branchId: user.branchId?.id,
                    },
                );

            return {
                success: true,
                data: {
                    accessToken: newTokenPair.accessToken,
                    refreshToken: newTokenPair.refreshToken,
                    expiresIn: newTokenPair.expiresIn,
                },
                message: 'Token refreshed successfully',
            };
        } catch (error) {
            if (error instanceof UnauthorizedException) {
                throw error;
            }
            throw new UnauthorizedException('Invalid refresh token');
        }
    }

    /**
     * Get token information for authenticated user
     */
    async getTokenInfo(user: {
        id: string;
        email: string;
        firstName: string;
        lastName: string;
        avatar?: {
            id: number;
            originalName?: string;
            url?: string;
            thumbnail?: string;
            medium?: string;
            original?: string;
        };
        orgId?: string;
        branchId?: string;
        createdAt: Date;
        updatedAt: Date;
    }): Promise<StandardApiResponse<any>> {
        // Fetch user with full org/branch details
        const fullUser = await this.userService.findById(user.id);

        if (!fullUser) {
            return {
                success: false,
                message: 'User not found',
            };
        }

        return {
            success: true,
            data: {
                user: {
                    id: fullUser.id,
                    email: fullUser.email,
                    firstName: fullUser.firstName,
                    lastName: fullUser.lastName,
                    avatar: this.transformAvatarForResponse(fullUser.avatar),
                    orgId: fullUser.orgId?.id,
                    branchId: fullUser.branchId?.id,
                    createdAt: fullUser.createdAt,
                    updatedAt: fullUser.updatedAt,
                },
                scope: {
                    orgId: fullUser.orgId?.id,
                    branchId: fullUser.branchId?.id,
                },
                organization: fullUser.orgId
                    ? {
                          id: fullUser.orgId.id,
                          name: fullUser.orgId.name,
                          avatar: fullUser.orgId.logoUrl,
                      }
                    : undefined,
                branch: fullUser.branchId
                    ? {
                          id: fullUser.branchId.id,
                          name: fullUser.branchId.name,
                          email: fullUser.branchId.email,
                          address: fullUser.branchId.address,
                          contactNumber: fullUser.branchId.contactNumber,
                          managerName: fullUser.branchId.managerName,
                      }
                    : undefined,
            },
            message: 'Token information retrieved successfully',
        };
    }

    /**
     * Send welcome email to new user
     */
    private async sendWelcomeEmail(user: User): Promise<void> {
        try {
            const baseUrl = this.configService.get<string>(
                'CLIENT_URL',
                'http://localhost:3000',
            );
            const appName = this.configService.get<string>(
                'APP_NAME',
                'trainpro Platform',
            );

            const templateData = {
                recipientName: `${user.firstName} ${user.lastName}`,
                recipientEmail: user.email,
                loginUrl: `${baseUrl}/login`,
                dashboardUrl: `${baseUrl}/dashboard`,
                profileUrl: `${baseUrl}/profile`,
                companyName: appName,
                companyUrl: baseUrl,
                supportEmail: this.configService.get<string>(
                    'SUPPORT_EMAIL',
                    'support@trainpro.com',
                ),
                unsubscribeUrl: `${baseUrl}/unsubscribe`,
            };

            const rendered = await this.emailTemplateService.renderByType(
                EmailType.WELCOME,
                templateData,
            );

            await this.emailQueueService.queueEmail(
                {
                    to: user.email,
                    subject: rendered.subject,
                    html: rendered.html,
                    text: rendered.text,
                },
                EmailJobPriority.HIGH,
                0, // Send immediately
                {
                    userId: user.id,
                    templateType: EmailType.WELCOME,
                },
            );
        } catch (error) {
            // Log error but don't throw - welcome email failure shouldn't block registration
            console.error('Failed to send welcome email:', error);
        }
    }

    /**
     * Send password reset email
     */
    private async sendPasswordResetEmail(
        user: User,
        token: string,
        expiresAt: Date,
    ): Promise<void> {
        try {
            const baseUrl = this.configService.get<string>(
                'CLIENT_URL',
                'http://localhost:3000',
            );
            const appName = this.configService.get<string>(
                'APP_NAME',
                'trainpro Platform',
            );
            const resetUrl = `${baseUrl}/reset-password?token=${token}`;

            const templateData = {
                recipientName: `${user.firstName} ${user.lastName}`,
                recipientEmail: user.email,
                resetUrl,
                resetToken: token,
                expiryTime: '15 minutes',
                companyName: appName,
                companyUrl: baseUrl,
                supportEmail: this.configService.get<string>(
                    'SUPPORT_EMAIL',
                    'support@trainpro.com',
                ),
                unsubscribeUrl: `${baseUrl}/unsubscribe`,
            };

            const rendered = await this.emailTemplateService.renderByType(
                EmailType.PASSWORD_RESET,
                templateData,
            );

            await this.emailQueueService.queueEmail(
                {
                    to: user.email,
                    subject: rendered.subject,
                    html: rendered.html,
                    text: rendered.text,
                },
                EmailJobPriority.CRITICAL,
                0, // Send immediately
                {
                    userId: user.id,
                    templateType: EmailType.PASSWORD_RESET,
                    tokenExpiresAt: expiresAt,
                },
            );
        } catch (error) {
            console.error('Failed to send password reset email:', error);
            throw new Error('Failed to send password reset email');
        }
    }

    /**
     * Send email verification email
     */
    private async sendEmailVerificationEmail(
        user: User,
        token: string,
        expiresAt: Date,
    ): Promise<void> {
        try {
            const baseUrl = this.configService.get<string>(
                'CLIENT_URL',
                'http://localhost:3000',
            );
            const appName = this.configService.get<string>(
                'APP_NAME',
                'trainpro Platform',
            );
            const verificationUrl = `${baseUrl}/verify-email?token=${token}`;

            const templateData = {
                recipientName: `${user.firstName} ${user.lastName}`,
                recipientEmail: user.email,
                verificationUrl,
                verificationToken: token,
                expiryTime: '24 hours',
                companyName: appName,
                companyUrl: baseUrl,
                supportEmail: this.configService.get<string>(
                    'SUPPORT_EMAIL',
                    'support@trainpro.com',
                ),
                unsubscribeUrl: `${baseUrl}/unsubscribe`,
            };

            const rendered = await this.emailTemplateService.renderByType(
                EmailType.EMAIL_VERIFICATION,
                templateData,
            );

            await this.emailQueueService.queueEmail(
                {
                    to: user.email,
                    subject: rendered.subject,
                    html: rendered.html,
                    text: rendered.text,
                },
                EmailJobPriority.HIGH,
                0, // Send immediately
                {
                    userId: user.id,
                    templateType: EmailType.EMAIL_VERIFICATION,
                    tokenExpiresAt: expiresAt,
                },
            );
        } catch (error) {
            console.error('Failed to send email verification email:', error);
            throw new Error('Failed to send verification email');
        }
    }

    /**
     * Send invitation email to a user
     */
    async sendInvitation(
        sendInvitationDto: SendInvitationDto,
        inviterUserId: string,
    ): Promise<StandardApiResponse<any>> {
        const { email, message, organizationId, branchId } = sendInvitationDto;

        // Check if user already exists
        const existingUser = await this.userService.findByEmail(email);
        if (existingUser) {
            throw new ConflictException('User with this email already exists');
        }

        // Get inviter information
        const inviter = await this.userService.findById(inviterUserId);
        if (!inviter) {
            throw new NotFoundException('Inviter not found');
        }

        // Revoke any existing invitation tokens for this email
        this.tokenManagerService.revokeInvitationTokensByEmail(email);

        // Generate invitation token
        const { token, expiresAt } =
            this.tokenManagerService.generateInvitationToken(
                email,
                inviterUserId,
                `${inviter.firstName} ${inviter.lastName}`,
                organizationId,
                branchId,
            );

        // Send invitation email
        await this.sendInvitationEmail(
            email,
            token,
            inviter,
            message,
            expiresAt,
        );

        return {
            success: true,
            message: 'Invitation sent successfully',
        };
    }

    /**
     * Validate invitation token
     */
    validateInvitation(
        validateInvitationDto: ValidateInvitationDto,
    ): StandardApiResponse<any> {
        const { token } = validateInvitationDto;

        const tokenValidation =
            this.tokenManagerService.validateInvitationToken(token);
        if (!tokenValidation.isValid) {
            throw new BadRequestException(
                'Invalid or expired invitation token',
            );
        }

        return {
            success: true,
            data: {
                email: tokenValidation.email,
                inviterName: tokenValidation.inviterName,
                organizationId: tokenValidation.organizationId,
                branchId: tokenValidation.branchId,
            },
            message: 'Invitation token is valid',
        };
    }

    /**
     * Send password changed confirmation email
     */
    private async sendPasswordChangedEmail(
        user: User,
        ipAddress?: string,
        userAgent?: string,
    ): Promise<void> {
        try {
            const baseUrl = this.configService.get<string>(
                'CLIENT_URL',
                'http://localhost:3000',
            );
            const appName = this.configService.get<string>(
                'APP_NAME',
                'trainpro Platform',
            );

            const templateData = {
                recipientName: `${user.firstName} ${user.lastName}`,
                recipientEmail: user.email,
                changeDateTime: new Date().toLocaleString('en-US', {
                    timeZone: 'UTC',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    timeZoneName: 'short',
                }),
                loginUrl: `${baseUrl}/login`,
                dashboardUrl: `${baseUrl}/dashboard`,
                profileUrl: `${baseUrl}/profile`,
                companyName: appName,
                companyUrl: baseUrl,
                supportEmail: this.configService.get<string>(
                    'SUPPORT_EMAIL',
                    'support@trainpro.com',
                ),
                ipAddress,
                userAgent,
                unsubscribeUrl: `${baseUrl}/unsubscribe`,
            };

            const rendered = await this.emailTemplateService.renderByType(
                EmailType.PASSWORD_CHANGED,
                templateData,
            );

            await this.emailQueueService.queueEmail(
                {
                    to: user.email,
                    subject: rendered.subject,
                    html: rendered.html,
                    text: rendered.text,
                },
                EmailJobPriority.CRITICAL,
                0, // Send immediately
                {
                    userId: user.id,
                    templateType: EmailType.PASSWORD_CHANGED,
                },
            );
        } catch (error) {
            console.error('Failed to send password changed email:', error);
            // Don't throw error - email failure shouldn't block password change
        }
    }

    /**
     * Send re-engagement emails to all existing users
     * This is an organizational initiative to encourage users to start actively using the platform
     */
    async sendReInviteToAllUsers(): Promise<StandardApiResponse<any>> {
        try {
            // Get all users from the system with organization details
            const allUsers = await this.userService.findAll();

            if (!allUsers || allUsers.length === 0) {
                return {
                    success: false,
                    message: 'No users found in the system',
                };
            }

            const baseUrl = this.configService.get<string>(
                'CLIENT_URL',
                'http://localhost:3000',
            );
            const appName = this.configService.get<string>(
                'APP_NAME',
                'Exxam Learning Platform',
            );

            let successCount = 0;
            let failedCount = 0;
            const failedEmails: string[] = [];

            // Send re-engagement email to each user
            for (const user of allUsers) {
                try {
                    // Use the user's linked organization name dynamically, fallback to default if no org
                    const organizationName = user.orgId?.name || 'Your Organization';

                    const templateData = {
                        recipientName: `${user.firstName} ${user.lastName}`,
                        recipientEmail: user.email,
                        loginUrl: `${baseUrl}/login`,
                        dashboardUrl: `${baseUrl}/dashboard`,
                        profileUrl: `${baseUrl}/profile`,
                        coursesUrl: `${baseUrl}/courses`,
                        testsUrl: `${baseUrl}/tests`,
                        leaderboardUrl: `${baseUrl}/leaderboard`,
                        companyName: appName,
                        organizationName: organizationName,
                        companyUrl: baseUrl,
                        supportEmail: this.configService.get<string>(
                            'SUPPORT_EMAIL',
                            'support@exxam.com',
                        ),
                        unsubscribeUrl: `${baseUrl}/unsubscribe`,
                        currentYear: new Date().getFullYear(),
                    };

                    const rendered =
                        await this.emailTemplateService.renderTemplate({
                            template: 're-invite',
                            data: templateData,
                            format: 'both',
                        });

                    await this.emailQueueService.queueEmail(
                        {
                            to: user.email,
                            subject: `🎓 Your Learning Journey Awaits - Start Using ${appName} Today!`,
                            html: rendered.html,
                            text: rendered.text,
                        },
                        EmailJobPriority.HIGH,
                        Math.floor(Math.random() * 300000), // Random delay up to 5 minutes to avoid spam detection
                        {
                            userId: user.id,
                            templateType: 're-invite',
                            batchOperation: true,
                            campaignType: 'user-reengagement',
                            organizationId: user.orgId?.id,
                        },
                    );

                    successCount++;
                } catch (error) {
                    console.error(
                        `Failed to send re-engagement email to ${user.email}:`,
                        error,
                    );
                    failedCount++;
                    failedEmails.push(user.email);
                }
            }

            return {
                success: true,
                message: `Re-engagement emails sent successfully. ${successCount} emails queued, ${failedCount} failed.`,
                data: {
                    totalUsers: allUsers.length,
                    successCount,
                    failedCount,
                    failedEmails,
                },
            };
        } catch (error) {
            console.error('Failed to send re-engagement emails:', error);
            return {
                success: false,
                message: 'Failed to send re-engagement emails to users',
            };
        }
    }

    /**
     * Send invitation email
     */
    private async sendInvitationEmail(
        recipientEmail: string,
        token: string,
        inviter: User,
        customMessage: string | undefined,
        expiresAt: Date,
    ): Promise<void> {
        try {
            const baseUrl = this.configService.get<string>(
                'CLIENT_URL',
                'http://localhost:3000',
            );
            const appName = this.configService.get<string>(
                'APP_NAME',
                'trainpro Platform',
            );
            const invitationUrl = `${baseUrl}/signup?invitation=${token}`;

            const templateData = {
                recipientEmail,
                inviterName: `${inviter.firstName} ${inviter.lastName}`,
                inviterEmail: inviter.email,
                invitationUrl,
                signupUrl: invitationUrl,
                customMessage:
                    customMessage ||
                    `You've been invited to join ${appName} by ${inviter.firstName} ${inviter.lastName}.`,
                expiryTime: '7 days',
                loginInstructions:
                    'After signing up, you will receive your login credentials and can access the platform immediately.',
                companyName: appName,
                companyUrl: baseUrl,
                supportEmail: this.configService.get<string>(
                    'SUPPORT_EMAIL',
                    'support@trainpro.com',
                ),
                unsubscribeUrl: `${baseUrl}/unsubscribe`,
            };

            // Use invitation template for personalized invitations
            const rendered = await this.emailTemplateService.renderTemplate({
                template: 'invitation',
                data: templateData,
                format: 'both',
            });

            await this.emailQueueService.queueEmail(
                {
                    to: recipientEmail,
                    subject: `${inviter.firstName} ${inviter.lastName} invited you to join ${appName}`,
                    html: rendered.html,
                    text: rendered.text,
                },
                EmailJobPriority.HIGH,
                0, // Send immediately
                {
                    inviterUserId: inviter.id,
                    templateType: 'invitation',
                    tokenExpiresAt: expiresAt,
                },
            );
        } catch (error) {
            console.error('Failed to send invitation email:', error);
            throw new Error('Failed to send invitation email');
        }
    }
}

/*
 * Class #16: ForgotPasswordDto
 * Source: auth/dto/forgot-password.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 3
 * Complexity: 9
 * Size: 591 characters (18 lines)
 */
/**
 * Data Transfer Object for password reset request
 * Used to initiate password reset flow by sending reset instructions via email
 */
export class ForgotPasswordDto {
    @ApiProperty({
        description:
            'Registered email address to send password reset instructions',
        example: 'john.doe@example.com',
        format: 'email',
        type: String,
        title: 'Email Address',
        maxLength: 255,
    })
    @IsEmail({}, { message: 'Please provide a valid email address' })
    @MaxLength(255, { message: 'Email address is too long' })
    email: string;
}

/*
 * Class #17: ResetPasswordDto
 * Source: auth/dto/reset-password.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 19
 * Decorators: 10
 * Complexity: 33
 * Size: 1956 characters (54 lines)
 */
/**
 * Data Transfer Object for password reset completion
 * Used to reset user password with secure token validation
 */
export class ResetPasswordDto {
    @ApiProperty({
        description: 'Password reset token received via email',
        example:
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InVzZXJAZXhhbXBsZS5jb20iLCJ0eXBlIjoicGFzc3dvcmRfcmVzZXQiLCJpYXQiOjE3MDUzMTcwMDAsImV4cCI6MTcwNTQwMzQwMH0.token-signature',
        type: String,
        title: 'Reset Token',
        minLength: 10,
    })
    @IsString({ message: 'Reset token is required' })
    @MinLength(10, { message: 'Invalid reset token format' })
    token: string;

    @ApiProperty({
        description:
            'New secure password. Must contain uppercase, lowercase, number, and special character',
        example: 'NewSecurePass123!',
        type: String,
        title: 'New Password',
        format: 'password',
        minLength: 8,
        pattern:
            '^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>\\/?])',
    })
    @IsString({ message: 'Password is required' })
    @MinLength(8, { message: 'Password must be at least 8 characters long' })
    @Matches(
        /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=[\]{};':"\\|,.<>/?])/,
        {
            message:
                'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character',
        },
    )
    password: string;

    @ApiProperty({
        description:
            'Confirmation of the new password (must match password field)',
        example: 'NewSecurePass123!',
        type: String,
        title: 'Confirm Password',
        format: 'password',
        minLength: 8,
    })
    @IsString({ message: 'Password confirmation is required' })
    @MinLength(8, {
        message: 'Password confirmation must be at least 8 characters long',
    })
    confirmPassword: string;
}

/*
 * Class #18: SendInvitationDto
 * Source: auth/dto/send-invitation.dto.ts:10
 * Type: Exported Class
 * Methods: 0
 * Properties: 26
 * Decorators: 14
 * Complexity: 38
 * Size: 2006 characters (62 lines)
 */
/**
 * Data Transfer Object for sending user invitations
 * Used to invite new users to join the platform with optional organization/branch assignment
 */
export class SendInvitationDto {
    @ApiProperty({
        description: 'Email address of the person to invite to the platform',
        example: 'newuser@example.com',
        format: 'email',
        type: String,
        title: 'Recipient Email',
        maxLength: 255,
    })
    @IsEmail({}, { message: 'Please provide a valid email address' })
    @MaxLength(255, { message: 'Email address is too long' })
    email: string;

    @ApiProperty({
        description:
            'Optional personalized message to include in the invitation email',
        example:
            "Join our team on the trainpro platform! We're excited to have you aboard.",
        required: false,
        type: String,
        title: 'Custom Message',
        maxLength: 500,
        minLength: 1,
    })
    @IsOptional()
    @IsString({ message: 'Message must be a string' })
    @MinLength(1, { message: 'Message cannot be empty if provided' })
    @MaxLength(500, {
        message: 'Message is too long (maximum 500 characters)',
    })
    message?: string;

    @ApiProperty({
        description:
            'Organization ID to automatically assign the user upon registration (optional)',
        example: 'org_123456789',
        required: false,
        type: String,
        title: 'Organization ID',
        pattern: '^org_[a-zA-Z0-9]{8,}$',
    })
    @IsOptional()
    @IsString({ message: 'Organization ID must be a string' })
    organizationId?: string;

    @ApiProperty({
        description:
            'Branch ID to automatically assign the user upon registration (optional)',
        example: 'branch_123456789',
        required: false,
        type: String,
        title: 'Branch ID',
        pattern: '^branch_[a-zA-Z0-9]{8,}$',
    })
    @IsOptional()
    @IsString({ message: 'Branch ID must be a string' })
    branchId?: string;
}

/*
 * Class #19: ValidateInvitationDto
 * Source: auth/dto/validate-invitation.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 3
 * Complexity: 8
 * Size: 727 characters (18 lines)
 */
/**
 * Data Transfer Object for validating invitation tokens
 * Used to verify invitation token authenticity and retrieve invitation details
 */
export class ValidateInvitationDto {
    @ApiProperty({
        description: 'Invitation token received via email invitation link',
        example:
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6Im5ld3VzZXJAZXhhbXBsZS5jb20iLCJ0eXBlIjoiaW52aXRhdGlvbiIsImlhdCI6MTcwNTMxNzAwMCwiZXhwIjoxNzA1OTIxODAwfQ.signature',
        type: String,
        title: 'Invitation Token',
        minLength: 10,
        format: 'jwt',
    })
    @IsString({ message: 'Invitation token is required' })
    @MinLength(10, { message: 'Invalid invitation token format' })
    token: string;
}

/*
 * Class #20: JwtAuthGuard
 * Source: auth/jwt-auth.guard.ts:5
 * Type: Exported Class
 * Methods: 1
 * Properties: 0
 * Decorators: 0
 * Complexity: 3
 * Size: 53 characters (1 lines)
 * Extends: AuthGuard('jwt')
 */
export class JwtAuthGuard extends AuthGuard('jwt') {}

/*
 * Class #21: JwtStrategy
 * Source: auth/jwt.strategy.ts:19
 * Type: Exported Class
 * Methods: 3
 * Properties: 16
 * Decorators: 1
 * Complexity: 12
 * Size: 1069 characters (33 lines)
 * Extends: PassportStrategy(Strategy)
 */
export class JwtStrategy extends PassportStrategy(Strategy) {
    constructor(
        private authService: AuthService,
        private configService: ConfigService,
    ) {
        super({
            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
            ignoreExpiration: false,
            secretOrKey:
                configService.get<string>('JWT_SECRET') || 'fallback-secret',
        });
    }

    async validate(payload: JwtPayload) {
        const user = await this.authService.findById(payload.sub);
        if (!user) {
            return null;
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { password: _, ...userWithoutPassword } = user;
        return {
            id: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            avatar: user.avatar,
            orgId: payload.orgId,
            branchId: payload.branchId,
            createdAt: user.createdAt,
            updatedAt: user.updatedAt,
        };
    }
}

/*
 * Class #22: OrgBranchScopingService
 * Source: auth/services/org-branch-scoping.service.ts:19
 * Type: Exported Class
 * Methods: 5
 * Properties: 21
 * Decorators: 0
 * Complexity: 50
 * Size: 3867 characters (122 lines)
 */
export class OrgBranchScopingService {
    /**
     * Apply org and branch scoping to a find query
     */
    applyScopeToFindOptions<T extends ObjectLiteral>(
        options: FindManyOptions<T> = {},
        scope: ScopeOptions,
    ): FindManyOptions<T> {
        const whereClause = this.buildScopeWhereClause(scope);

        if (Object.keys(whereClause).length === 0) {
            return options;
        }

        return {
            ...options,
            where: options.where
                ? Array.isArray(options.where)
                    ? options.where.map(w => ({ ...w, ...whereClause }))
                    : { ...options.where, ...whereClause }
                : whereClause,
        };
    }

    /**
     * Apply org and branch scoping to a find one query
     */
    applyScopeToFindOneOptions<T extends ObjectLiteral>(
        options: FindOneOptions<T> = {},
        scope: ScopeOptions,
    ): FindOneOptions<T> {
        const whereClause = this.buildScopeWhereClause(scope);

        if (Object.keys(whereClause).length === 0) {
            return options;
        }

        return {
            ...options,
            where: options.where
                ? Array.isArray(options.where)
                    ? options.where.map(w => ({ ...w, ...whereClause }))
                    : { ...options.where, ...whereClause }
                : whereClause,
        };
    }

    /**
     * Apply org and branch scoping to a query builder
     */
    applyScopeToQueryBuilder<T extends ObjectLiteral>(
        queryBuilder: SelectQueryBuilder<T>,
        scope: ScopeOptions,
        entityAlias: string = 'entity',
    ): SelectQueryBuilder<T> {
        if (scope.orgId) {
            if (scope.includeGlobal) {
                queryBuilder.andWhere(
                    `(${entityAlias}.orgId IS NULL OR ${entityAlias}.orgId = :orgId)`,
                    { orgId: scope.orgId },
                );
            } else {
                queryBuilder.andWhere(`${entityAlias}.orgId = :orgId`, {
                    orgId: scope.orgId,
                });
            }
        }

        if (scope.branchId) {
            if (scope.includeGlobal) {
                queryBuilder.andWhere(
                    `(${entityAlias}.branchId IS NULL OR ${entityAlias}.branchId = :branchId)`,
                    { branchId: scope.branchId },
                );
            } else {
                queryBuilder.andWhere(`${entityAlias}.branchId = :branchId`, {
                    branchId: scope.branchId,
                });
            }
        }

        return queryBuilder;
    }

    /**
     * Create a scoped repository with pre-applied org/branch filtering
     */
    createScopedRepository<T extends ObjectLiteral>(
        repository: Repository<T>,
        scope: ScopeOptions,
    ): ScopedRepository<T> {
        return new ScopedRepository(repository, scope, this);
    }

    /**
     * Build where clause for org/branch scoping
     */
    private buildScopeWhereClause(scope: ScopeOptions): Record<string, any> {
        const whereClause: Record<string, any> = {};

        if (scope.orgId) {
            if (scope.includeGlobal) {
                // This would need to be handled in query builder for complex OR conditions
                // For simple find operations, we'll apply strict scoping
                whereClause.orgId = { id: scope.orgId };
            } else {
                whereClause.orgId = { id: scope.orgId };
            }
        }

        if (scope.branchId) {
            if (scope.includeGlobal) {
                // This would need to be handled in query builder for complex OR conditions
                whereClause.branchId = { id: scope.branchId };
            } else {
                whereClause.branchId = { id: scope.branchId };
            }
        }

        return whereClause;
    }
}

/*
 * Class #23: ScopedRepository
 * Source: auth/services/org-branch-scoping.service.ts:20
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 2
 * Size: 158 characters (5 lines)
 */
/**
     * Apply org and branch scoping to a find query
     */
    applyScopeToFindOptions<T extends ObjectLiteral>(
        options: FindManyOptions<T> = {}

/*
 * Class #24: TokenManagerService
 * Source: auth/token-manager.service.ts:36
 * Type: Exported Class
 * Methods: 36
 * Properties: 107
 * Decorators: 0
 * Complexity: 151
 * Size: 9935 characters (357 lines)
 */
export class TokenManagerService {
    private readonly accessTokenExpiry = '1h';
    private readonly refreshTokenExpiry = '7d';
    private readonly refreshTokens = new Map<
        string,
        { userId: string; expiresAt: number }
    >();

    // Store password reset and email verification tokens
    private readonly specialTokens = new Map<string, SpecialTokenData>();

    constructor(
        private readonly jwtService: JwtService,
        private readonly configService: ConfigService,
    ) {}

    async generateTokenPair(user: {
        id: string;
        email: string;
        firstName: string;
        lastName: string;
        orgId?: string;
        branchId?: string;
    }): Promise<TokenPair> {
        const payload: TokenPayload = {
            sub: user.id,
            email: user.email,
            firstName: user.firstName,
            lastName: user.lastName,
            orgId: user.orgId,
            branchId: user.branchId,
        };

        const accessToken = await this.jwtService.signAsync(payload, {
            expiresIn: this.accessTokenExpiry,
        });

        const refreshToken = this.generateRefreshToken(user.id);

        // Store refresh token with expiration
        const expiresAt = Date.now() + 7 * 24 * 60 * 60 * 1000; // 7 days
        this.refreshTokens.set(refreshToken, {
            userId: user.id,
            expiresAt,
        });

        return {
            accessToken,
            refreshToken,
            expiresIn: 3600, // 1 hour in seconds
        };
    }

    private generateRefreshToken(userId: string): string {
        const token = crypto.randomBytes(32).toString('hex');
        const expiresAt = Date.now() + 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds

        this.refreshTokens.set(token, { userId, expiresAt });
        return token;
    }

    /**
     * Generate a password reset token
     */
    generatePasswordResetToken(
        userId: string,
        email: string,
    ): { token: string; expiresAt: Date } {
        const token = crypto.randomBytes(32).toString('hex');
        const expiresAt = Date.now() + 15 * 60 * 1000; // 15 minutes

        this.specialTokens.set(token, {
            userId,
            email,
            type: 'password_reset',
            expiresAt,
            createdAt: Date.now(),
        });

        return {
            token,
            expiresAt: new Date(expiresAt),
        };
    }

    /**
     * Generate an email verification token
     */
    generateEmailVerificationToken(
        userId: string,
        email: string,
    ): { token: string; expiresAt: Date } {
        const token = crypto.randomBytes(32).toString('hex');
        const expiresAt = Date.now() + 24 * 60 * 60 * 1000; // 24 hours

        this.specialTokens.set(token, {
            userId,
            email,
            type: 'email_verification',
            expiresAt,
            createdAt: Date.now(),
        });

        return {
            token,
            expiresAt: new Date(expiresAt),
        };
    }

    /**
     * Generate an invitation token
     */
    generateInvitationToken(
        inviteeEmail: string,
        inviterUserId: string,
        inviterName: string,
        organizationId?: string,
        branchId?: string,
    ): { token: string; expiresAt: Date } {
        const token = crypto.randomBytes(32).toString('hex');
        const expiresAt = Date.now() + 7 * 24 * 60 * 60 * 1000; // 7 days

        this.specialTokens.set(token, {
            userId: '', // Will be set when user registers
            email: inviteeEmail,
            type: 'invitation',
            expiresAt,
            createdAt: Date.now(),
            inviterUserId,
            inviterName,
            organizationId,
            branchId,
        });

        return {
            token,
            expiresAt: new Date(expiresAt),
        };
    }

    /**
     * Validate a password reset token
     */
    validatePasswordResetToken(token: string): {
        isValid: boolean;
        userId?: string;
        email?: string;
    } {
        const tokenData = this.specialTokens.get(token);

        if (!tokenData || tokenData.type !== 'password_reset') {
            return { isValid: false };
        }

        if (tokenData.expiresAt < Date.now()) {
            this.specialTokens.delete(token);
            return { isValid: false };
        }

        return {
            isValid: true,
            userId: tokenData.userId,
            email: tokenData.email,
        };
    }

    /**
     * Validate an email verification token
     */
    validateEmailVerificationToken(token: string): {
        isValid: boolean;
        userId?: string;
        email?: string;
    } {
        const tokenData = this.specialTokens.get(token);

        if (!tokenData || tokenData.type !== 'email_verification') {
            return { isValid: false };
        }

        if (tokenData.expiresAt < Date.now()) {
            this.specialTokens.delete(token);
            return { isValid: false };
        }

        return {
            isValid: true,
            userId: tokenData.userId,
            email: tokenData.email,
        };
    }

    /**
     * Validate an invitation token
     */
    validateInvitationToken(token: string): {
        isValid: boolean;
        email?: string;
        inviterName?: string;
        organizationId?: string;
        branchId?: string;
        data?: SpecialTokenData;
    } {
        const tokenData = this.specialTokens.get(token);

        if (!tokenData || tokenData.type !== 'invitation') {
            return { isValid: false };
        }

        if (tokenData.expiresAt < Date.now()) {
            this.specialTokens.delete(token);
            return { isValid: false };
        }

        return {
            isValid: true,
            email: tokenData.email,
            inviterName: tokenData.inviterName,
            organizationId: tokenData.organizationId,
            branchId: tokenData.branchId,
            data: tokenData,
        };
    }

    /**
     * Consume a special token (removes it after use)
     */
    consumeSpecialToken(token: string): {
        isValid: boolean;
        data?: SpecialTokenData;
    } {
        const tokenData = this.specialTokens.get(token);

        if (!tokenData) {
            return { isValid: false };
        }

        if (tokenData.expiresAt < Date.now()) {
            this.specialTokens.delete(token);
            return { isValid: false };
        }

        // Remove token after successful validation
        this.specialTokens.delete(token);
        return { isValid: true, data: tokenData };
    }

    /**
     * Revoke all special tokens for a user
     */
    revokeUserSpecialTokens(
        userId: string,
        type?: 'password_reset' | 'email_verification' | 'invitation',
    ): void {
        for (const [token, data] of this.specialTokens.entries()) {
            if (data.userId === userId && (!type || data.type === type)) {
                this.specialTokens.delete(token);
            }
        }
    }

    /**
     * Revoke invitation tokens by email (for when invitation is consumed)
     */
    revokeInvitationTokensByEmail(email: string): void {
        for (const [token, data] of this.specialTokens.entries()) {
            if (data.type === 'invitation' && data.email === email) {
                this.specialTokens.delete(token);
            }
        }
    }

    async validateAccessToken(token: string): Promise<TokenPayload> {
        try {
            const payload = await this.jwtService.verifyAsync<TokenPayload>(
                token,
                {
                    secret: this.configService.get<string>('JWT_SECRET'),
                },
            );
            return payload;
        } catch {
            throw new UnauthorizedException('Invalid or expired access token');
        }
    }

    validateRefreshToken(token: string): { userId: string; isValid: boolean } {
        const tokenData = this.refreshTokens.get(token);

        if (!tokenData) {
            return { userId: '', isValid: false };
        }

        if (tokenData.expiresAt < Date.now()) {
            this.refreshTokens.delete(token);
            return { userId: '', isValid: false };
        }

        return { userId: tokenData.userId, isValid: true };
    }

    async refreshAccessToken(
        refreshToken: string,
        user: {
            id: string;
            email: string;
            firstName: string;
            lastName: string;
            orgId?: string;
            branchId?: string;
        },
    ): Promise<TokenPair> {
        const validation = this.validateRefreshToken(refreshToken);

        if (!validation.isValid || validation.userId !== user.id) {
            throw new UnauthorizedException('Invalid refresh token');
        }

        const newTokenPair = await this.generateTokenPair(user);
        this.refreshTokens.delete(refreshToken);

        return newTokenPair;
    }

    revokeRefreshToken(token: string): void {
        this.refreshTokens.delete(token);
    }

    revokeAllUserTokens(userId: string): void {
        for (const [token, data] of this.refreshTokens.entries()) {
            if (data.userId === userId) {
                this.refreshTokens.delete(token);
            }
        }

        // Also revoke special tokens
        this.revokeUserSpecialTokens(userId);
    }

    cleanupExpiredTokens(): void {
        const now = Date.now();

        // Cleanup refresh tokens
        for (const [token, data] of this.refreshTokens.entries()) {
            if (data.expiresAt < now) {
                this.refreshTokens.delete(token);
            }
        }

        // Cleanup special tokens
        for (const [token, data] of this.specialTokens.entries()) {
            if (data.expiresAt < now) {
                this.specialTokens.delete(token);
            }
        }
    }
}

/*
 * Class #25: BranchController
 * Source: branch/branch.controller.ts:37
 * Type: Exported Class
 * Methods: 5
 * Properties: 420
 * Decorators: 36
 * Complexity: 98
 * Size: 28287 characters (727 lines)
 */
export class BranchController {
    private readonly logger = new Logger(BranchController.name);

    constructor(private readonly branchService: BranchService) {}

    @Get()
    @ApiOperation({
        summary: '📋 List All Branches',
        description: `
        **Retrieves all branches across all organizations**
        
        **🏪 Complete Branch Directory:**
        - All branches from every organization on the platform
        - Branch details including contact information and management
        - Associated organization information for context
        - Operational status and availability data
        
        **📊 Data Included:**
        - Branch profiles and contact details
        - Operating hours and management information
        - Parent organization relationships
        - Geographic distribution insights
        
        **🎯 Administrative Use Cases:**
        - **Platform Management**: Monitor all branch locations globally
        - **Resource Planning**: Understand total capacity across platform
        - **Support Operations**: Route inquiries to appropriate branches
        - **Analytics**: Generate cross-organizational reports
        - **Compliance**: Ensure all locations meet standards
        
        **💡 Business Intelligence:**
        - Geographic distribution analysis
        - Branch density and coverage assessment
        - Resource allocation optimization
        - Performance benchmarking across organizations
        `,
        operationId: 'getAllBranches',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Branches retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success status',
                },
                message: {
                    type: 'string',
                    example: 'All branches retrieved successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'array',
                    description: 'List of all branches across organizations',
                    items: {
                        type: 'object',
                        properties: {
                            id: {
                                type: 'string',
                                example: 'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
                                description: 'Branch identifier',
                            },
                            name: {
                                type: 'string',
                                example: 'Medical Center Campus',
                                description: 'Branch name',
                            },
                            address: {
                                type: 'string',
                                example: '450 Medical Plaza Drive, CA 90095',
                                description: 'Branch address',
                            },
                            contactNumber: {
                                type: 'string',
                                example: '+1-310-825-9111',
                                description: 'Branch contact phone',
                            },
                            email: {
                                type: 'string',
                                example: 'medcenter@university.edu',
                                description: 'Branch email',
                            },
                            managerName: {
                                type: 'string',
                                example: 'Dr. Sarah Johnson',
                                description: 'Branch manager',
                            },
                            isActive: {
                                type: 'boolean',
                                example: true,
                                description: 'Branch status',
                            },
                            organization: {
                                type: 'object',
                                properties: {
                                    id: {
                                        type: 'string',
                                        example:
                                            'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
                                    },
                                    name: {
                                        type: 'string',
                                        example: 'Stanford University',
                                    },
                                    isActive: {
                                        type: 'boolean',
                                        example: true,
                                    },
                                },
                            },
                            createdAt: {
                                type: 'string',
                                example: '2024-01-01T00:00:00.000Z',
                                description: 'Creation timestamp',
                            },
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description: '🔥 Internal server error during data retrieval',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: { type: 'string', example: 'Internal server error' },
            },
        },
    })
    async findAll() {
        this.logger.log('Retrieving all branches');
        return await this.branchService.findAll();
    }

    @Get(':id')
    @ApiOperation({
        summary: '🔍 Get Branch by ID',
        description: `
        **Retrieves a specific branch with organization context**
        
        **🏢 Detailed Branch Information:**
        - Complete branch profile and contact details
        - Operating hours and management information
        - Associated organization details and context
        - Operational status and availability
        
        **📋 Essential Data:**
        - Branch location and contact information
        - Management personnel and responsibilities
        - Operating schedules and availability windows
        - Parent organization relationship
        
        **🎯 Use Cases:**
        - **User Assignment**: Determine branch affiliation for users
        - **Exam Scheduling**: Plan tests based on operating hours
        - **Support Routing**: Direct inquiries to appropriate contacts
        - **Resource Planning**: Understand branch capacity and capabilities
        - **Compliance**: Verify branch meets operational requirements
        `,
        operationId: 'getBranchById',
    })
    @ApiParam({
        name: 'id',
        description: 'Branch unique identifier',
        example: 'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
        type: 'string',
        format: 'uuid',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Branch retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success status',
                },
                message: {
                    type: 'string',
                    example: 'Branch retrieved successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'object',
                    description: 'Complete branch data with organization',
                    properties: {
                        id: {
                            type: 'string',
                            example: 'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
                            description: 'Branch identifier',
                        },
                        name: {
                            type: 'string',
                            example: 'Medical Center Campus',
                            description: 'Branch name',
                        },
                        address: {
                            type: 'string',
                            example:
                                '450 Medical Plaza Drive, Health Sciences District, CA 90095',
                            description: 'Branch address',
                        },
                        contactNumber: {
                            type: 'string',
                            example: '+1-310-825-9111',
                            description: 'Branch contact phone',
                        },
                        email: {
                            type: 'string',
                            example: 'medcenter@university.edu',
                            description: 'Branch email address',
                        },
                        managerName: {
                            type: 'string',
                            example: 'Dr. Sarah Johnson',
                            description: 'Branch manager name',
                        },
                        operatingHours: {
                            type: 'object',
                            example: {
                                opening: '07:00',
                                closing: '19:00',
                                days: [
                                    'Monday',
                                    'Tuesday',
                                    'Wednesday',
                                    'Thursday',
                                    'Friday',
                                    'Saturday',
                                ],
                            },
                            description: 'Branch operating schedule',
                        },
                        isActive: {
                            type: 'boolean',
                            example: true,
                            description: 'Branch active status',
                        },
                        organization: {
                            type: 'object',
                            properties: {
                                id: {
                                    type: 'string',
                                    example:
                                        'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
                                },
                                name: {
                                    type: 'string',
                                    example: 'Stanford University',
                                },
                                isActive: { type: 'boolean', example: true },
                                logoUrl: {
                                    type: 'string',
                                    example:
                                        'https://cdn.stanford.edu/logo.png',
                                },
                                website: {
                                    type: 'string',
                                    example: 'https://www.stanford.edu',
                                },
                            },
                        },
                        createdAt: {
                            type: 'string',
                            example: '2024-01-01T00:00:00.000Z',
                            description: 'Creation timestamp',
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid branch ID format',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: { type: 'string', example: 'Invalid UUID format' },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Branch not found',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 404 },
                message: {
                    type: 'string',
                    example:
                        'Branch with ID b1c2d3e4-f5g6-7890-bcde-fg1234567890 not found',
                },
                error: { type: 'string', example: 'Not Found' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description: '🔥 Internal server error during data retrieval',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: { type: 'string', example: 'Internal server error' },
            },
        },
    })
    async findOne(@Param('id') id: string) {
        this.logger.log(`Retrieving branch: ${id}`);
        return await this.branchService.findById(id);
    }

    @Put(':id')
    @ApiOperation({
        summary: '✏️ Update Branch Information',
        description: `
        **Updates branch information directly**
        
        **🔄 Updatable Information:**
        - Branch contact information and address changes
        - Operating hours and schedule modifications
        - Management personnel updates
        - Service availability and status changes
        
        **🎯 Why Branch Updates Matter:**
        - **User Experience**: Accurate contact and location information
        - **Operational Efficiency**: Current schedules for exam planning
        - **Emergency Preparedness**: Up-to-date contact information
        - **Regulatory Compliance**: Maintain accurate records
        - **Quality Assurance**: Reflect current management and capabilities
        
        **📋 Common Update Scenarios:**
        - Facility relocations or address changes
        - Management personnel transitions
        - Operating hour adjustments for seasonal changes
        - Contact information updates for better communication
        - Status changes for temporary closures or maintenance
        `,
        operationId: 'updateBranch',
    })
    @ApiParam({
        name: 'id',
        description: 'Branch unique identifier',
        example: 'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
        type: 'string',
        format: 'uuid',
    })
    @ApiBody({
        type: UpdateBranchDto,
        description: 'Branch update data (all fields optional)',
        examples: {
            'contact-update': {
                summary: '📞 Contact Information Update',
                description: 'Update branch contact details',
                value: {
                    contactNumber: '+1-310-825-9999',
                    email: 'new.contact@university.edu',
                    managerName: 'Dr. Michael Thompson',
                },
            },
            'address-change': {
                summary: '🏢 Address Change',
                description: 'Update branch location',
                value: {
                    address: '500 New Medical Plaza Drive, CA 90095',
                },
            },
            'hours-update': {
                summary: '⏰ Operating Hours Update',
                description: 'Modify branch operating schedule',
                value: {
                    operatingHours: {
                        opening: '08:00',
                        closing: '18:00',
                        days: [
                            'Monday',
                            'Tuesday',
                            'Wednesday',
                            'Thursday',
                            'Friday',
                        ],
                    },
                },
            },
            'status-change': {
                summary: '⚡ Status Change',
                description: 'Activate or deactivate branch',
                value: {
                    isActive: false,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Branch updated successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Update operation success status',
                },
                message: {
                    type: 'string',
                    example: 'Branch updated successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'object',
                    description: 'Updated branch data',
                    properties: {
                        id: {
                            type: 'string',
                            example: 'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
                            description: 'Branch identifier',
                        },
                        name: {
                            type: 'string',
                            example: 'Medical Center Campus',
                            description: 'Branch name',
                        },
                        address: {
                            type: 'string',
                            example: '500 New Medical Plaza Drive, CA 90095',
                            description: 'Updated branch address',
                        },
                        contactNumber: {
                            type: 'string',
                            example: '+1-310-825-9999',
                            description: 'Updated contact phone',
                        },
                        email: {
                            type: 'string',
                            example: 'new.contact@university.edu',
                            description: 'Updated email address',
                        },
                        managerName: {
                            type: 'string',
                            example: 'Dr. Michael Thompson',
                            description: 'Updated manager name',
                        },
                        isActive: {
                            type: 'boolean',
                            example: true,
                            description: 'Updated active status',
                        },
                        updatedAt: {
                            type: 'string',
                            example: '2024-01-15T10:45:30.567Z',
                            description: 'Update timestamp',
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data or branch ID format',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    example: [
                        'Email must be a valid email address',
                        'Branch name must be at least 2 characters long',
                        'Invalid UUID format',
                    ],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Branch not found',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 404 },
                message: {
                    type: 'string',
                    example:
                        'Branch with ID b1c2d3e4-f5g6-7890-bcde-fg1234567890 not found',
                },
                error: { type: 'string', example: 'Not Found' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description: '🔥 Internal server error during branch update',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: { type: 'string', example: 'Internal server error' },
            },
        },
    })
    async update(
        @Param('id') id: string,
        @Body() updateBranchDto: UpdateBranchDto,
    ) {
        this.logger.log(`Updating branch: ${id}`);
        return await this.branchService.update(id, updateBranchDto);
    }

    @Delete(':id')
    @ApiOperation({
        summary: '🗑️ Delete Branch',
        description: `
        **Permanently removes a branch from the system**
        
        **⚠️ Critical Operation Warning:**
        - Irreversibly deletes the branch record
        - May cascade delete associated user assignments
        - Affects operational capacity and resource allocation
        - Cannot be undone without data recovery procedures
        
        **📋 Pre-deletion Considerations:**
        - Verify no active users are assigned to this branch
        - Ensure no ongoing exams or training sessions
        - Confirm alternative branch assignments for affected users
        - Review organizational structure impact
        
        **🎯 Use Cases:**
        - **Branch Closure**: Permanent facility shutdown
        - **Organizational Restructuring**: Merging or consolidating branches
        - **Data Cleanup**: Removing test or invalid branch records
        - **Compliance**: Meeting regulatory closure requirements
        
        **⚡ Best Practices:**
        - Archive branch data before deletion
        - Notify affected users and administrators
        - Update routing and assignment logic
        - Document business justification for audit trails
        `,
        operationId: 'deleteBranch',
    })
    @ApiParam({
        name: 'id',
        description: 'Branch unique identifier to delete',
        example: 'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
        type: 'string',
        format: 'uuid',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Branch deleted successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Deletion operation success status',
                },
                message: {
                    type: 'string',
                    example: 'Branch deleted successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'object',
                    description: 'Deletion confirmation details',
                    properties: {
                        deletedBranchId: {
                            type: 'string',
                            example: 'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
                            description: 'ID of the deleted branch',
                        },
                        deletedAt: {
                            type: 'string',
                            example: '2024-01-15T10:45:30.567Z',
                            description: 'Deletion timestamp',
                        },
                        affectedRecords: {
                            type: 'object',
                            properties: {
                                userAssignments: {
                                    type: 'number',
                                    example: 0,
                                    description:
                                        'Number of user assignments affected',
                                },
                                activeExams: {
                                    type: 'number',
                                    example: 0,
                                    description:
                                        'Number of active exams affected',
                                },
                            },
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid branch ID format or deletion constraints',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'string',
                    example:
                        'Cannot delete branch with active user assignments',
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
                error: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Branch not found',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 404 },
                message: {
                    type: 'string',
                    example:
                        'Branch with ID b1c2d3e4-f5g6-7890-bcde-fg1234567890 not found',
                },
                error: { type: 'string', example: 'Not Found' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CONFLICT,
        description:
            '⚠️ Conflict - Branch has dependencies that prevent deletion',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 409 },
                message: {
                    type: 'string',
                    example:
                        'Cannot delete branch: 15 active user assignments and 3 ongoing exams',
                },
                error: { type: 'string', example: 'Conflict' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description: '🔥 Internal server error during branch deletion',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: { type: 'string', example: 'Internal server error' },
                error: { type: 'string', example: 'Internal Server Error' },
            },
        },
    })
    async remove(@Param('id') id: string) {
        this.logger.log(`Deleting branch: ${id}`);
        return await this.branchService.remove(id);
    }
}

/*
 * Class #26: BranchModule
 * Source: branch/branch.module.ts:13
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 28 characters (1 lines)
 */
export class BranchModule {}

/*
 * Class #27: BranchService
 * Source: branch/branch.service.ts:8
 * Type: Exported Class
 * Methods: 12
 * Properties: 23
 * Decorators: 1
 * Complexity: 59
 * Size: 3724 characters (111 lines)
 */
export class BranchService {
    constructor(
        @InjectRepository(Branch)
        private readonly branchRepository: Repository<Branch>,
    ) {}

    private async retryOperation<T>(
        operation: () => Promise<T>,
        maxRetries = 3,
        delay = 1000,
    ): Promise<T> {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                const isConnectionError =
                    error instanceof Error &&
                    (error.message.includes('ECONNRESET') ||
                        error.message.includes('Connection lost') ||
                        error.message.includes('connect ETIMEDOUT'));

                if (isConnectionError && attempt < maxRetries) {
                    console.log(
                        `Database connection error on attempt ${attempt}, retrying in ${delay}ms...`,
                    );
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                    continue;
                }
                throw error;
            }
        }
        throw new Error('Max retries exceeded');
    }

    async findAll(): Promise<Branch[]> {
        return this.retryOperation(async () => {
            return await this.branchRepository.find({
                relations: ['organization'],
                order: { createdAt: 'DESC' },
            });
        });
    }

    async findOne(id: string): Promise<Branch | null> {
        return this.retryOperation(async () => {
            return await this.branchRepository.findOne({
                where: { id },
                relations: ['organization'],
            });
        });
    }

    async findById(id: string): Promise<Branch> {
        const branch = await this.findOne(id);
        if (!branch) {
            throw new NotFoundException(`Branch with ID ${id} not found`);
        }
        return branch;
    }

    async update(
        id: string,
        updateBranchDto: UpdateBranchDto,
    ): Promise<Branch> {
        return this.retryOperation(async () => {
            await this.findById(id); // Verify branch exists
            await this.branchRepository.update(id, updateBranchDto);
            return await this.findById(id);
        });
    }

    async remove(id: string): Promise<void> {
        return this.retryOperation(async () => {
            const branch = await this.findById(id);
            await this.branchRepository.remove(branch);
        });
    }

    // Additional utility methods
    async findByOrganization(organizationId: string): Promise<Branch[]> {
        return this.retryOperation(async () => {
            return await this.branchRepository.find({
                where: { organization: { id: organizationId } },
                relations: ['organization'],
                order: { createdAt: 'DESC' },
            });
        });
    }

    async countByOrganization(organizationId: string): Promise<number> {
        return this.retryOperation(async () => {
            return await this.branchRepository.count({
                where: { organization: { id: organizationId } },
            });
        });
    }

    async findActiveByOrganization(organizationId: string): Promise<Branch[]> {
        return this.retryOperation(async () => {
            return await this.branchRepository.find({
                where: {
                    organization: { id: organizationId },
                    isActive: true,
                },
                relations: ['organization'],
                order: { createdAt: 'DESC' },
            });
        });
    }
}

/*
 * Class #28: CreateBranchDto
 * Source: branch/dto/create-branch.dto.ts:11
 * Type: Exported Class
 * Methods: 0
 * Properties: 6
 * Decorators: 18
 * Complexity: 44
 * Size: 2204 characters (76 lines)
 */
export class CreateBranchDto {
    @ApiProperty({
        description: 'Branch name within the organization',
        example: 'Downtown Branch',
        type: String,
        title: 'Branch Name',
        minLength: 2,
        maxLength: 255,
    })
    @IsString({ message: 'Branch name must be a string' })
    @MinLength(2, { message: 'Branch name must be at least 2 characters long' })
    name: string;

    @ApiProperty({
        description: 'Physical address of the branch location',
        example: '123 Main Street, Downtown, City 12345',
        required: false,
        type: String,
        title: 'Address',
        maxLength: 500,
    })
    @IsOptional()
    @IsString({ message: 'Address must be a string' })
    address?: string;

    @ApiProperty({
        description: 'Branch contact phone number',
        example: '+1-555-123-4567',
        required: false,
        type: String,
        title: 'Contact Number',
        maxLength: 20,
    })
    @IsOptional()
    @IsString({ message: 'Contact number must be a string' })
    contactNumber?: string;

    @ApiProperty({
        description: 'Branch email address for communication',
        example: 'downtown@acmecorp.com',
        required: false,
        type: String,
        title: 'Email Address',
        format: 'email',
    })
    @IsOptional()
    @IsEmail({}, { message: 'Email must be a valid email address' })
    email?: string;

    @ApiProperty({
        description: 'Name of the branch manager or person in charge',
        example: 'John Smith',
        required: false,
        type: String,
        title: 'Manager Name',
        maxLength: 100,
    })
    @IsOptional()
    @IsString({ message: 'Manager name must be a string' })
    managerName?: string;

    @ApiProperty({
        description: 'Branch operating hours and days',
        example: {
            opening: '09:00',
            closing: '17:00',
            days: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],
        },
        required: false,
        type: Object,
        title: 'Operating Hours',
    })
    @IsOptional()
    @IsObject({ message: 'Operating hours must be an object' })
    operatingHours?: OperatingHours;
}

/*
 * Class #29: UpdateBranchDto
 * Source: branch/dto/update-branch.dto.ts:5
 * Type: Exported Class
 * Methods: 1
 * Properties: 6
 * Decorators: 3
 * Complexity: 11
 * Size: 372 characters (12 lines)
 * Extends: PartialType(CreateBranchDto)
 */
export class UpdateBranchDto extends PartialType(CreateBranchDto) {
    @ApiProperty({
        description: 'Branch active status (enable/disable branch)',
        example: true,
        required: false,
        type: Boolean,
        title: 'Active Status',
    })
    @IsOptional()
    @IsBoolean({ message: 'Active status must be a boolean' })
    isActive?: boolean;
}

/*
 * Class #30: Branch
 * Source: branch/entities/branch.entity.ts:29
 * Type: Exported Class
 * Methods: 0
 * Properties: 14
 * Decorators: 31
 * Complexity: 71
 * Size: 2681 characters (96 lines)
 */
export class Branch {
    @PrimaryGeneratedColumn('uuid')
    @ApiProperty({
        description: 'Branch unique identifier',
        example: 'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
    })
    id: string;

    @Column()
    @ApiProperty({
        description: 'Branch name',
        example: 'Downtown Branch',
    })
    @IsString({ message: 'Branch name must be a string' })
    name: string;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Branch address',
        example: '123 Main Street, Downtown, City 12345',
        required: false,
    })
    @IsOptional()
    @IsString({ message: 'Address must be a string' })
    address?: string;

    @Column({ nullable: false, unique: true })
    @ApiProperty({
        description: 'Branch email address',
        example: 'downtown@acmecorp.com',
        required: false,
    })
    @IsEmail({}, { message: 'Email must be a valid email address' })
    email?: string;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Branch contact phone number',
        example: '+1-555-123-4567',
        required: false,
    })
    @IsOptional()
    @IsString({ message: 'Contact number must be a string' })
    contactNumber?: string;

    @Column({ default: true })
    @ApiProperty({
        description: 'Branch active status',
        example: true,
        default: true,
    })
    @IsBoolean({ message: 'Active status must be a boolean' })
    isActive: boolean;

    @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
    @ApiProperty({
        description: 'Branch creation date',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Branch manager name',
        example: 'John Smith',
        required: false,
    })
    @IsOptional()
    @IsString({ message: 'Manager name must be a string' })
    managerName?: string;

    @Column({ type: 'json', nullable: true })
    @ApiProperty({
        description: 'Branch operating hours',
        example: {
            opening: '09:00',
            closing: '17:00',
            days: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],
        },
        required: false,
    })
    @IsOptional()
    @IsObject({ message: 'Operating hours must be an object' })
    operatingHours?: OperatingHours;

    @ManyToOne(() => Organization, organization => organization.branches)
    @ApiProperty({
        description: 'Organization this branch belongs to',
        type: () => Organization,
    })
    organization: Organization;

    constructor(partial: Partial<Branch>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #31: BranchCreatedEvent
 * Source: common/events/branch-created.event.ts:1
 * Type: Exported Class
 * Methods: 0
 * Properties: 8
 * Decorators: 0
 * Complexity: 5
 * Size: 426 characters (12 lines)
 */
export class BranchCreatedEvent {
    constructor(
        public readonly branchId: string,
        public readonly branchName: string,
        public readonly branchEmail: string,
        public readonly organizationId: string,
        public readonly organizationName: string,
        public readonly address?: string,
        public readonly contactNumber?: string,
        public readonly managerName?: string,
    ) {}
}

/*
 * Class #32: CourseCreatedEvent
 * Source: common/events/course-created.event.ts:1
 * Type: Exported Class
 * Methods: 0
 * Properties: 11
 * Decorators: 0
 * Complexity: 6
 * Size: 563 characters (15 lines)
 */
export class CourseCreatedEvent {
    constructor(
        public readonly courseId: number,
        public readonly title: string,
        public readonly description: string,
        public readonly creatorId: string,
        public readonly creatorEmail: string,
        public readonly creatorFirstName: string,
        public readonly creatorLastName: string,
        public readonly organizationId?: string,
        public readonly organizationName?: string,
        public readonly branchId?: string,
        public readonly branchName?: string,
    ) {}
}

/*
 * Class #33: OrganizationCreatedEvent
 * Source: common/events/organization-created.event.ts:1
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 0
 * Complexity: 4
 * Size: 300 characters (9 lines)
 */
export class OrganizationCreatedEvent {
    constructor(
        public readonly organizationId: string,
        public readonly organizationName: string,
        public readonly organizationEmail: string,
        public readonly logoUrl?: string,
        public readonly website?: string,
    ) {}
}

/*
 * Class #34: QuestionCreatedEvent
 * Source: common/events/question-created.event.ts:1
 * Type: Exported Class
 * Methods: 0
 * Properties: 11
 * Decorators: 0
 * Complexity: 7
 * Size: 555 characters (15 lines)
 */
export class QuestionCreatedEvent {
    constructor(
        public readonly questionId: number,
        public readonly testId: number,
        public readonly questionText: string,
        public readonly questionType: string,
        public readonly points: number,
        public readonly orderIndex: number,
        public readonly organizationId?: string,
        public readonly organizationName?: string,
        public readonly branchId?: string,
        public readonly branchName?: string,
        public readonly createdBy?: string,
    ) {}
}

/*
 * Class #35: QuestionDeletedEvent
 * Source: common/events/question-deleted.event.ts:1
 * Type: Exported Class
 * Methods: 0
 * Properties: 8
 * Decorators: 0
 * Complexity: 7
 * Size: 425 characters (12 lines)
 */
export class QuestionDeletedEvent {
    constructor(
        public readonly questionId: number,
        public readonly testId: number,
        public readonly questionText: string,
        public readonly organizationId?: string,
        public readonly organizationName?: string,
        public readonly branchId?: string,
        public readonly branchName?: string,
        public readonly deletedBy?: string,
    ) {}
}

/*
 * Class #36: QuestionUpdatedEvent
 * Source: common/events/question-updated.event.ts:1
 * Type: Exported Class
 * Methods: 0
 * Properties: 12
 * Decorators: 0
 * Complexity: 8
 * Size: 605 characters (16 lines)
 */
export class QuestionUpdatedEvent {
    constructor(
        public readonly questionId: number,
        public readonly testId: number,
        public readonly questionText: string,
        public readonly questionType: string,
        public readonly points: number,
        public readonly orderIndex: number,
        public readonly organizationId?: string,
        public readonly organizationName?: string,
        public readonly branchId?: string,
        public readonly branchName?: string,
        public readonly updatedBy?: string,
        public readonly updatedFields?: string[],
    ) {}
}

/*
 * Class #37: UserCreatedEvent
 * Source: common/events/user-created.event.ts:1
 * Type: Exported Class
 * Methods: 0
 * Properties: 9
 * Decorators: 0
 * Complexity: 7
 * Size: 456 characters (13 lines)
 */
export class UserCreatedEvent {
    constructor(
        public readonly userId: string,
        public readonly userEmail: string,
        public readonly firstName: string,
        public readonly lastName: string,
        public readonly organizationId?: string,
        public readonly organizationName?: string,
        public readonly branchId?: string,
        public readonly branchName?: string,
        public readonly avatar?: string,
    ) {}
}

/*
 * Class #38: UserDeactivatedEvent
 * Source: common/events/user-deactivated.event.ts:1
 * Type: Exported Class
 * Methods: 0
 * Properties: 10
 * Decorators: 0
 * Complexity: 8
 * Size: 508 characters (14 lines)
 */
export class UserDeactivatedEvent {
    constructor(
        public readonly userId: string,
        public readonly userEmail: string,
        public readonly firstName: string,
        public readonly lastName: string,
        public readonly organizationId?: string,
        public readonly organizationName?: string,
        public readonly branchId?: string,
        public readonly branchName?: string,
        public readonly deactivatedBy?: string,
        public readonly reason?: string,
    ) {}
}

/*
 * Class #39: UserOrgBranchAssignedEvent
 * Source: common/events/user-org-branch-assigned.event.ts:1
 * Type: Exported Class
 * Methods: 0
 * Properties: 10
 * Decorators: 0
 * Complexity: 8
 * Size: 511 characters (14 lines)
 */
export class UserOrgBranchAssignedEvent {
    constructor(
        public readonly userId: string,
        public readonly userEmail: string,
        public readonly firstName: string,
        public readonly lastName: string,
        public readonly organizationId?: string,
        public readonly organizationName?: string,
        public readonly branchId?: string,
        public readonly branchName?: string,
        public readonly avatar?: string,
        public readonly assignedBy?: string,
    ) {}
}

/*
 * Class #40: UserPasswordChangedEvent
 * Source: common/events/user-password-changed.event.ts:1
 * Type: Exported Class
 * Methods: 0
 * Properties: 8
 * Decorators: 0
 * Complexity: 6
 * Size: 423 characters (12 lines)
 */
export class UserPasswordChangedEvent {
    constructor(
        public readonly userId: string,
        public readonly userEmail: string,
        public readonly firstName: string,
        public readonly lastName: string,
        public readonly organizationId?: string,
        public readonly organizationName?: string,
        public readonly branchId?: string,
        public readonly branchName?: string,
    ) {}
}

/*
 * Class #41: UserProfileUpdatedEvent
 * Source: common/events/user-profile-updated.event.ts:1
 * Type: Exported Class
 * Methods: 0
 * Properties: 10
 * Decorators: 0
 * Complexity: 8
 * Size: 549 characters (14 lines)
 */
export class UserProfileUpdatedEvent {
    constructor(
        public readonly userId: string,
        public readonly userEmail: string,
        public readonly firstName: string,
        public readonly lastName: string,
        public readonly organizationId?: string,
        public readonly organizationName?: string,
        public readonly branchId?: string,
        public readonly branchName?: string,
        public readonly avatar?: string,
        public readonly updatedFields?: string[], // List of fields that were updated
    ) {}
}

/*
 * Class #42: UserRestoredEvent
 * Source: common/events/user-restored.event.ts:1
 * Type: Exported Class
 * Methods: 0
 * Properties: 9
 * Decorators: 0
 * Complexity: 7
 * Size: 461 characters (13 lines)
 */
export class UserRestoredEvent {
    constructor(
        public readonly userId: string,
        public readonly userEmail: string,
        public readonly firstName: string,
        public readonly lastName: string,
        public readonly organizationId?: string,
        public readonly organizationName?: string,
        public readonly branchId?: string,
        public readonly branchName?: string,
        public readonly restoredBy?: string,
    ) {}
}

/*
 * Class #43: CommunicationsController
 * Source: communications/communications.controller.ts:25
 * Type: Exported Class
 * Methods: 5
 * Properties: 16
 * Decorators: 20
 * Complexity: 52
 * Size: 1593 characters (59 lines)
 */
export class CommunicationsController {
    constructor(
        private readonly communicationsService: CommunicationsService,
    ) {}

    @Post()
    create(
        @Body() createCommunicationDto: CreateCommunicationDto,
        @OrgBranchScope() scope: OrgBranchScope,
        @Req() req: AuthenticatedRequest,
    ) {
        return this.communicationsService.create(
            createCommunicationDto,
            scope,
            req.user.id,
        );
    }

    @Get()
    findAll(
        @OrgBranchScope() scope: OrgBranchScope,
        @Req() req: AuthenticatedRequest,
    ) {
        return this.communicationsService.findAll(scope, req.user.id);
    }

    @Get(':id')
    findOne(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
        @Req() req: AuthenticatedRequest,
    ) {
        return this.communicationsService.findOne(id, scope, req.user.id);
    }

    @Patch(':id')
    update(
        @Param('id', ParseIntPipe) id: number,
        @Body() updateCommunicationDto: UpdateCommunicationDto,
        @OrgBranchScope() scope: OrgBranchScope,
        @Req() req: AuthenticatedRequest,
    ) {
        return this.communicationsService.update(
            id,
            updateCommunicationDto,
            scope,
            req.user.id,
        );
    }

    @Delete(':id')
    remove(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
        @Req() req: AuthenticatedRequest,
    ) {
        return this.communicationsService.remove(id, scope, req.user.id);
    }
}

/*
 * Class #44: CommunicationsModule
 * Source: communications/communications.module.ts:35
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 36 characters (1 lines)
 */
export class CommunicationsModule {}

/*
 * Class #45: CommunicationsService
 * Source: communications/communications.service.ts:22
 * Type: Exported Class
 * Methods: 25
 * Properties: 326
 * Decorators: 18
 * Complexity: 245
 * Size: 29155 characters (843 lines)
 */
export class CommunicationsService {
    private readonly logger = new Logger(CommunicationsService.name);

    constructor(
        @InjectRepository(Communication)
        private readonly communicationRepository: Repository<Communication>,
        private readonly emailTemplateService: EmailTemplateService,
        private readonly emailSMTPService: EmailSMTPService,
        private readonly emailQueueService: EmailQueueService,
        private readonly configService: ConfigService,
    ) {}

    /**
     * Get base template data that all emails should include
     */
    private getBaseTemplateData(
        recipientEmail: string,
        recipientName?: string,
    ) {
        const clientUrl = this.configService.get<string>(
            'CLIENT_URL',
            'http://localhost:3000',
        );
        const appName = this.configService.get<string>(
            'APP_NAME',
            'trainpro Platform',
        );
        const supportEmail = this.configService.get<string>(
            'SUPPORT_EMAIL',
            'support@trainpro.com',
        );

        return {
            recipientName,
            recipientEmail,
            companyName: appName,
            companyUrl: clientUrl,
            supportEmail,
            unsubscribeUrl: `${clientUrl}/unsubscribe`,
        };
    }

    async sendWelcomeOrganizationEmail(
        organizationId: string,
        organizationName: string,
        organizationEmail: string,
        logoUrl?: string,
        website?: string,
    ): Promise<void> {
        try {
            const clientUrl = this.configService.get<string>(
                'CLIENT_URL',
                'http://localhost:3000',
            );
            const baseData = this.getBaseTemplateData(
                organizationEmail,
                organizationName,
            );

            const templateData: WelcomeOrganizationTemplateData = {
                ...baseData,
                organizationName,
                organizationId,
                dashboardUrl: `${clientUrl}/dashboard`,
                loginUrl: `${clientUrl}/login`,
                logoUrl,
                website,
                setupGuideUrl: `${clientUrl}/setup-guide`,
            };

            const rendered = await this.emailTemplateService.renderByType(
                EmailType.WELCOME_ORGANIZATION,
                templateData,
            );

            const communication = this.communicationRepository.create({
                recipientEmail: organizationEmail,
                recipientName: organizationName,
                senderEmail: this.configService.get(
                    'EMAIL_FROM_ADDRESS',
                    'noreply@trainpro.com',
                ),
                senderName: 'trainpro Platform',
                subject: rendered.subject,
                body: rendered.html || '',
                plainTextBody: rendered.text,
                emailType: EmailType.WELCOME_ORGANIZATION,
                templateUsed: 'welcome-organization',
                status: EmailStatus.PENDING,
                metadata: {
                    organizationId,
                    organizationName,
                },
            });

            await this.communicationRepository.save(communication);

            // Queue the email for sending
            await this.emailQueueService.queueEmail({
                to: organizationEmail,
                subject: rendered.subject,
                html: rendered.html,
                text: rendered.text,
            });

            this.logger.log(
                `Welcome email queued for organization: ${organizationName} (${organizationEmail})`,
            );
        } catch (error) {
            this.logger.error(
                `Failed to send welcome email for organization ${organizationName}:`,
                error,
            );
        }
    }

    async sendWelcomeBranchEmail(
        branchId: string,
        branchName: string,
        branchEmail: string,
        organizationId: string,
        organizationName: string,
        address?: string,
        contactNumber?: string,
        managerName?: string,
    ): Promise<void> {
        try {
            const clientUrl = this.configService.get<string>(
                'CLIENT_URL',
                'http://localhost:3000',
            );
            const baseData = this.getBaseTemplateData(branchEmail, branchName);

            const templateData: WelcomeBranchTemplateData = {
                ...baseData,
                branchName,
                branchId,
                organizationName,
                organizationId,
                dashboardUrl: `${clientUrl}/dashboard`,
                loginUrl: `${clientUrl}/login`,
                address,
                contactNumber,
                managerName,
                setupGuideUrl: `${clientUrl}/setup-guide`,
            };

            const rendered = await this.emailTemplateService.renderByType(
                EmailType.WELCOME_BRANCH,
                templateData,
            );

            const communication = this.communicationRepository.create({
                recipientEmail: branchEmail,
                recipientName: branchName,
                senderEmail: this.configService.get(
                    'EMAIL_FROM_ADDRESS',
                    'noreply@trainpro.com',
                ),
                senderName: 'trainpro Platform',
                subject: rendered.subject,
                body: rendered.html || '',
                plainTextBody: rendered.text,
                emailType: EmailType.WELCOME_BRANCH,
                templateUsed: 'welcome-branch',
                status: EmailStatus.PENDING,

                metadata: {
                    branchId,
                    branchName,
                    organizationId,
                    organizationName,
                },
            });

            await this.communicationRepository.save(communication);

            // Queue the email for sending
            await this.emailQueueService.queueEmail({
                to: branchEmail,
                subject: rendered.subject,
                html: rendered.html,
                text: rendered.text,
            });

            this.logger.log(
                `Welcome email queued for branch: ${branchName} (${branchEmail})`,
            );
        } catch (error) {
            this.logger.error(
                `Failed to send welcome email for branch ${branchName}:`,
                error,
            );
        }
    }

    async sendWelcomeUserEmail(
        userId: string,
        userEmail: string,
        firstName: string,
        lastName: string,
        organizationId?: string,
        organizationName?: string,
        branchId?: string,
        branchName?: string,
        avatar?: string,
    ): Promise<void> {
        try {
            const templateData: WelcomeUserTemplateData = {
                recipientName: `${firstName} ${lastName}`,
                recipientEmail: userEmail,
                firstName,
                lastName,
                userId,
                dashboardUrl: `${this.configService.get('CLIENT_URL', 'http://localhost:3000')}/dashboard`,
                loginUrl: `${this.configService.get('CLIENT_URL', 'http://localhost:3000')}/login`,
                profileUrl: `${this.configService.get('CLIENT_URL', 'http://localhost:3000')}/profile`,
                companyName: 'trainpro Platform',
                companyUrl: this.configService.get(
                    'CLIENT_URL',
                    'http://localhost:3000',
                ),
                supportEmail: this.configService.get(
                    'SUPPORT_EMAIL',
                    'support@trainpro.com',
                ),
                organizationName,
                branchName,
                avatar,
                setupGuideUrl: `${this.configService.get('CLIENT_URL', 'http://localhost:3000')}/setup-guide`,
            };

            const rendered = await this.emailTemplateService.renderByType(
                EmailType.WELCOME_USER,
                templateData,
            );

            const communication = this.communicationRepository.create({
                recipientEmail: userEmail,
                recipientName: `${firstName} ${lastName}`,
                senderEmail: this.configService.get(
                    'EMAIL_FROM_ADDRESS',
                    'noreply@trainpro.com',
                ),
                senderName: 'trainpro Platform',
                subject: rendered.subject,
                body: rendered.html || '',
                plainTextBody: rendered.text,
                emailType: EmailType.WELCOME_USER,
                templateUsed: 'welcome-user',
                status: EmailStatus.PENDING,
                metadata: {
                    userId,
                    firstName,
                    lastName,
                    organizationId,
                    organizationName,
                    branchId,
                    branchName,
                },
            });

            await this.communicationRepository.save(communication);

            // Queue the email for sending
            await this.emailQueueService.queueEmail({
                to: userEmail,
                subject: rendered.subject,
                html: rendered.html,
                text: rendered.text,
            });

            this.logger.log(
                `Welcome email queued for user: ${firstName} ${lastName} (${userEmail})`,
            );
        } catch (error) {
            this.logger.error(
                `Failed to send welcome email for user ${firstName} ${lastName}:`,
                error,
            );
        }
    }

    async sendUserProfileUpdateEmail(
        userId: string,
        userEmail: string,
        firstName: string,
        lastName: string,
        updatedFields: string[],
        organizationName?: string,
        branchName?: string,
    ): Promise<void> {
        try {
            const templateData = {
                recipientName: `${firstName} ${lastName}`,
                recipientEmail: userEmail,
                firstName,
                lastName,
                userId,
                updatedFields: updatedFields.join(', '),
                profileUrl: `${this.configService.get('CLIENT_URL', 'http://localhost:3000')}/profile`,
                companyName: 'trainpro Platform',
                companyUrl: this.configService.get(
                    'CLIENT_URL',
                    'http://localhost:3000',
                ),
                supportEmail: this.configService.get(
                    'SUPPORT_EMAIL',
                    'support@trainpro.com',
                ),
                organizationName,
                branchName,
            };

            const rendered = await this.emailTemplateService.renderByType(
                EmailType.SYSTEM_ALERT,
                templateData,
            );

            const communication = this.communicationRepository.create({
                recipientEmail: userEmail,
                recipientName: `${firstName} ${lastName}`,
                senderEmail: this.configService.get(
                    'EMAIL_FROM_ADDRESS',
                    'noreply@trainpro.com',
                ),
                senderName: 'trainpro Platform',
                subject: rendered.subject || 'Profile Updated',
                body: rendered.html || '',
                plainTextBody: rendered.text,
                emailType: EmailType.SYSTEM_ALERT,
                templateUsed: 'profile-update',
                status: EmailStatus.PENDING,
                metadata: {
                    userId,
                    updatedFields,
                    profileUpdate: true,
                },
            });

            await this.communicationRepository.save(communication);

            // Queue the email for sending
            await this.emailQueueService.queueEmail({
                to: userEmail,
                subject: rendered.subject || 'Profile Updated',
                html: rendered.html,
                text: rendered.text,
            });

            this.logger.log(
                `Profile update email queued for user: ${firstName} ${lastName} (${userEmail})`,
            );
        } catch (error) {
            this.logger.error(
                `Failed to send profile update email for user ${firstName} ${lastName}:`,
                error,
            );
        }
    }

    async sendPasswordChangeEmail(
        userId: string,
        userEmail: string,
        firstName: string,
        lastName: string,
        organizationName?: string,
        branchName?: string,
    ): Promise<void> {
        try {
            const templateData = {
                recipientName: `${firstName} ${lastName}`,
                recipientEmail: userEmail,
                firstName,
                lastName,
                userId,
                changeTime: new Date().toISOString(),
                securityUrl: `${this.configService.get('CLIENT_URL', 'http://localhost:3000')}/security`,
                companyName: 'trainpro Platform',
                companyUrl: this.configService.get(
                    'CLIENT_URL',
                    'http://localhost:3000',
                ),
                supportEmail: this.configService.get(
                    'SUPPORT_EMAIL',
                    'support@trainpro.com',
                ),
                organizationName,
                branchName,
            };

            const rendered = await this.emailTemplateService.renderByType(
                EmailType.PASSWORD_RESET,
                templateData,
            );

            const communication = this.communicationRepository.create({
                recipientEmail: userEmail,
                recipientName: `${firstName} ${lastName}`,
                senderEmail: this.configService.get(
                    'EMAIL_FROM_ADDRESS',
                    'noreply@trainpro.com',
                ),
                senderName: 'trainpro Platform',
                subject: rendered.subject || 'Password Changed',
                body: rendered.html || '',
                plainTextBody: rendered.text,
                emailType: EmailType.PASSWORD_RESET,
                templateUsed: 'password-change',
                status: EmailStatus.PENDING,
                metadata: {
                    userId,
                    passwordChange: true,
                    changeTime: new Date().toISOString(),
                },
            });

            await this.communicationRepository.save(communication);

            // Queue the email for sending
            await this.emailQueueService.queueEmail({
                to: userEmail,
                subject: rendered.subject || 'Password Changed',
                html: rendered.html,
                text: rendered.text,
            });

            this.logger.log(
                `Password change email queued for user: ${firstName} ${lastName} (${userEmail})`,
            );
        } catch (error) {
            this.logger.error(
                `Failed to send password change email for user ${firstName} ${lastName}:`,
                error,
            );
        }
    }

    async sendUserDeactivatedEmail(
        userId: string,
        userEmail: string,
        firstName: string,
        lastName: string,
        organizationId?: string,
        organizationName?: string,
        branchId?: string,
        branchName?: string,
        reason?: string,
        deactivatedBy?: string,
    ): Promise<void> {
        try {
            const templateData = {
                recipientName: firstName,
                recipientEmail: userEmail,
                firstName,
                lastName,
                userEmail,
                organizationName,
                branchName,
                reason,
                deactivatedBy,
                companyName: 'trainpro Platform',
                companyUrl: this.configService.get(
                    'CLIENT_URL',
                    'http://localhost:3000',
                ),
                supportEmail: this.configService.get(
                    'SUPPORT_EMAIL',
                    'support@trainpro.com',
                ),
            };

            const rendered = await this.emailTemplateService.renderByType(
                EmailType.USER_DEACTIVATED,
                templateData,
            );

            const communication = this.communicationRepository.create({
                recipientEmail: userEmail,
                recipientName: firstName,
                senderEmail: this.configService.get(
                    'EMAIL_FROM_ADDRESS',
                    'noreply@trainpro.com',
                ),
                senderName: 'trainpro Platform',
                subject: rendered.subject,
                body: rendered.html || '',
                plainTextBody: rendered.text,
                emailType: EmailType.USER_DEACTIVATED,
                templateUsed: 'user-deactivated',
                status: EmailStatus.PENDING,
                metadata: {
                    userId,
                    organizationId,
                    organizationName,
                    branchId,
                    branchName,
                    reason,
                    deactivatedBy,
                },
            });

            await this.communicationRepository.save(communication);

            await this.emailQueueService.queueEmail({
                to: userEmail,
                subject: rendered.subject,
                html: rendered.html,
                text: rendered.text,
            });

            this.logger.log(
                `User deactivated email queued for: ${firstName} ${lastName} (${userEmail})`,
            );
        } catch (error) {
            this.logger.error(
                `Failed to send user deactivated email for ${firstName} ${lastName}:`,
                error,
            );
        }
    }

    async sendUserRestoredEmail(
        userId: string,
        userEmail: string,
        firstName: string,
        lastName: string,
        organizationId?: string,
        organizationName?: string,
        branchId?: string,
        branchName?: string,
        restoredBy?: string,
    ): Promise<void> {
        try {
            const templateData = {
                recipientName: firstName,
                recipientEmail: userEmail,
                firstName,
                lastName,
                userEmail,
                organizationName,
                branchName,
                restoredBy,
                dashboardUrl: `${this.configService.get('CLIENT_URL', 'http://localhost:3000')}/dashboard`,
                companyName: 'trainpro Platform',
                companyUrl: this.configService.get(
                    'CLIENT_URL',
                    'http://localhost:3000',
                ),
                supportEmail: this.configService.get(
                    'SUPPORT_EMAIL',
                    'support@trainpro.com',
                ),
                unsubscribeUrl: `${this.configService.get('CLIENT_URL', 'http://localhost:3000')}/unsubscribe`,
            };

            const rendered = await this.emailTemplateService.renderByType(
                EmailType.USER_RESTORED,
                templateData,
            );

            const communication = this.communicationRepository.create({
                recipientEmail: userEmail,
                recipientName: firstName,
                senderEmail: this.configService.get(
                    'EMAIL_FROM_ADDRESS',
                    'noreply@trainpro.com',
                ),
                senderName: 'trainpro Platform',
                subject: rendered.subject,
                body: rendered.html || '',
                plainTextBody: rendered.text,
                emailType: EmailType.USER_RESTORED,
                templateUsed: 'user-restored',
                status: EmailStatus.PENDING,
                metadata: {
                    userId,
                    organizationId,
                    organizationName,
                    branchId,
                    branchName,
                    restoredBy,
                },
            });

            await this.communicationRepository.save(communication);

            await this.emailQueueService.queueEmail({
                to: userEmail,
                subject: rendered.subject,
                html: rendered.html,
                text: rendered.text,
            });

            this.logger.log(
                `User restored email queued for: ${firstName} ${lastName} (${userEmail})`,
            );
        } catch (error) {
            this.logger.error(
                `Failed to send user restored email for ${firstName} ${lastName}:`,
                error,
            );
        }
    }

    async sendCourseCreatedEmail(
        courseId: number,
        title: string,
        description: string,
        creatorId: string,
        creatorEmail: string,
        creatorFirstName: string,
        creatorLastName: string,
        organizationId?: string,
        organizationName?: string,
        branchId?: string,
        branchName?: string,
    ): Promise<void> {
        try {
            const templateData = {
                recipientName: creatorFirstName,
                recipientEmail: creatorEmail,
                title,
                description,
                creatorFirstName,
                creatorLastName,
                organizationName,
                branchName,
                courseUrl: `${this.configService.get('CLIENT_URL', 'http://localhost:3000')}/courses/${courseId}`,
                dashboardUrl: `${this.configService.get('CLIENT_URL', 'http://localhost:3000')}/dashboard`,
                companyName: 'trainpro Platform',
                companyUrl: this.configService.get(
                    'CLIENT_URL',
                    'http://localhost:3000',
                ),
                supportEmail: this.configService.get(
                    'SUPPORT_EMAIL',
                    'support@trainpro.com',
                ),
                unsubscribeUrl: `${this.configService.get('CLIENT_URL', 'http://localhost:3000')}/unsubscribe`,
            };

            const rendered = await this.emailTemplateService.renderByType(
                EmailType.COURSE_CREATED,
                templateData,
            );

            const communication = this.communicationRepository.create({
                recipientEmail: creatorEmail,
                recipientName: creatorFirstName,
                senderEmail: this.configService.get(
                    'EMAIL_FROM_ADDRESS',
                    'noreply@trainpro.com',
                ),
                senderName: 'trainpro Platform',
                subject: rendered.subject,
                body: rendered.html || '',
                plainTextBody: rendered.text,
                emailType: EmailType.COURSE_CREATED,
                templateUsed: 'course-created',
                status: EmailStatus.PENDING,
                metadata: {
                    courseId,
                    creatorId,
                    organizationId,
                    organizationName,
                    branchId,
                    branchName,
                },
            });

            await this.communicationRepository.save(communication);

            await this.emailQueueService.queueEmail({
                to: creatorEmail,
                subject: rendered.subject,
                html: rendered.html,
                text: rendered.text,
            });

            this.logger.log(
                `Course created email queued for: ${creatorFirstName} ${creatorLastName} (${creatorEmail})`,
            );
        } catch (error) {
            this.logger.error(
                `Failed to send course created email for course ${title}:`,
                error,
            );
        }
    }

    async sendOrganizationAssignmentEmail(
        userId: string,
        userEmail: string,
        firstName: string,
        lastName: string,
        organizationName: string,
        branchName?: string,
        assignedBy?: string,
    ): Promise<void> {
        try {
            const templateData = {
                recipientName: `${firstName} ${lastName}`,
                recipientEmail: userEmail,
                firstName,
                lastName,
                userId,
                organizationName,
                branchName,
                dashboardUrl: `${this.configService.get('CLIENT_URL', 'http://localhost:3000')}/dashboard`,
                companyName: 'trainpro Platform',
                companyUrl: this.configService.get(
                    'CLIENT_URL',
                    'http://localhost:3000',
                ),
                supportEmail: this.configService.get(
                    'SUPPORT_EMAIL',
                    'support@trainpro.com',
                ),
            };

            const rendered = await this.emailTemplateService.renderByType(
                EmailType.SYSTEM_ALERT,
                templateData,
            );

            const communication = this.communicationRepository.create({
                recipientEmail: userEmail,
                recipientName: `${firstName} ${lastName}`,
                senderEmail: this.configService.get(
                    'EMAIL_FROM_ADDRESS',
                    'noreply@trainpro.com',
                ),
                senderName: 'trainpro Platform',
                subject: rendered.subject || 'Organization Assignment Updated',
                body: rendered.html || '',
                plainTextBody: rendered.text,
                emailType: EmailType.SYSTEM_ALERT,
                templateUsed: 'organization-assignment',
                status: EmailStatus.PENDING,
                metadata: {
                    userId,
                    organizationAssignment: true,
                    organizationName,
                    branchName,
                    assignedBy,
                    assignedAt: new Date().toISOString(),
                },
            });

            await this.communicationRepository.save(communication);

            // Queue the email for sending
            await this.emailQueueService.queueEmail({
                to: userEmail,
                subject: rendered.subject || 'Organization Assignment Updated',
                html: rendered.html,
                text: rendered.text,
            });

            this.logger.log(
                `Organization assignment email queued for user: ${firstName} ${lastName} (${userEmail})`,
            );
        } catch (error) {
            this.logger.error(
                `Failed to send organization assignment email for user ${firstName} ${lastName}:`,
                error,
            );
        }
    }

    create(
        createCommunicationDto: CreateCommunicationDto,
        scope: OrgBranchScope,
        userId: string,
    ) {
        // TODO: Implement actual communication creation with proper scoping
        console.log(
            'Creating communication for org:',
            scope.orgId,
            'user:',
            userId,
        );
        console.log('Communication data:', createCommunicationDto);
        return 'This action adds a new communication';
    }

    findAll(scope: OrgBranchScope, userId: string) {
        // TODO: Implement actual communication retrieval with proper scoping
        console.log(
            'Getting communications for org:',
            scope.orgId,
            'user:',
            userId,
        );
        return `This action returns all communications`;
    }

    findOne(id: number, scope: OrgBranchScope, userId: string) {
        // TODO: Implement actual communication retrieval with proper scoping
        console.log(
            'Getting communication',
            id,
            'for org:',
            scope.orgId,
            'user:',
            userId,
        );
        return `This action returns a #${id} communication`;
    }

    update(
        id: number,
        updateCommunicationDto: UpdateCommunicationDto,
        scope: OrgBranchScope,
        userId: string,
    ) {
        // TODO: Implement actual communication update with proper scoping
        console.log(
            'Updating communication',
            id,
            'for org:',
            scope.orgId,
            'user:',
            userId,
        );
        console.log('Update data:', updateCommunicationDto);
        return `This action updates a #${id} communication`;
    }

    remove(id: number, scope: OrgBranchScope, userId: string) {
        // TODO: Implement actual communication deletion with proper scoping
        console.log(
            'Removing communication',
            id,
            'for org:',
            scope.orgId,
            'user:',
            userId,
        );
        return `This action removes a #${id} communication`;
    }
}

/*
 * Class #46: CreateCommunicationDto
 * Source: communications/dto/create-communication.dto.ts:1
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 38 characters (1 lines)
 */
export class CreateCommunicationDto {}

/*
 * Class #47: UpdateCommunicationDto
 * Source: communications/dto/update-communication.dto.ts:4
 * Type: Exported Class
 * Methods: 1
 * Properties: 0
 * Decorators: 0
 * Complexity: 3
 * Size: 89 characters (3 lines)
 * Extends: PartialType(
    CreateCommunicationDto,
)
 */
export class UpdateCommunicationDto extends PartialType(
    CreateCommunicationDto,
) {}

/*
 * Class #48: Communication
 * Source: communications/entities/communication.entity.ts:58
 * Type: Exported Class
 * Methods: 0
 * Properties: 32
 * Decorators: 70
 * Complexity: 163
 * Size: 5041 characters (206 lines)
 */
export class Communication {
    @PrimaryGeneratedColumn('uuid')
    @ApiProperty({
        description: 'Communication unique identifier',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    id: string;

    @Column()
    @ApiProperty({
        description: 'Recipient email address',
        example: 'recipient@example.com',
    })
    @IsEmail()
    recipientEmail: string;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Recipient name',
        example: 'John Doe',
        required: false,
    })
    @IsString()
    @IsOptional()
    recipientName?: string;

    @Column()
    @ApiProperty({
        description: 'Sender email address',
        example: 'noreply@trainpro.com',
    })
    @IsEmail()
    senderEmail: string;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Sender name',
        example: 'trainpro Platform',
        required: false,
    })
    @IsString()
    @IsOptional()
    senderName?: string;

    @Column()
    @ApiProperty({
        description: 'Email subject line',
        example: 'Welcome to trainpro!',
    })
    @IsString()
    subject: string;

    @Column('text')
    @ApiProperty({
        description: 'Email body content (HTML)',
        example: '<h1>Welcome!</h1><p>Thank you for joining trainpro.</p>',
    })
    @IsString()
    body: string;

    @Column('text', { nullable: true })
    @ApiProperty({
        description: 'Plain text version of email body',
        example: 'Welcome! Thank you for joining trainpro.',
        required: false,
    })
    @IsString()
    @IsOptional()
    plainTextBody?: string;

    @Column({
        type: 'enum',
        enum: EmailType,
        default: EmailType.CUSTOM,
    })
    @ApiProperty({
        description: 'Type of email being sent',
        enum: EmailType,
        example: EmailType.WELCOME,
    })
    @IsEnum(EmailType)
    emailType: EmailType;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Template used for this email',
        example: 'welcome-template',
        required: false,
    })
    @IsString()
    @IsOptional()
    templateUsed?: string;

    @Column({
        type: 'enum',
        enum: EmailStatus,
        default: EmailStatus.PENDING,
    })
    @ApiProperty({
        description: 'Current status of the email',
        enum: EmailStatus,
        example: EmailStatus.SENT,
    })
    @IsEnum(EmailStatus)
    status: EmailStatus;

    @Column({ type: 'datetime', nullable: true })
    @ApiProperty({
        description: 'Date and time when email was sent',
        example: '2024-01-01T12:00:00.000Z',
        required: false,
    })
    @IsDateString()
    @IsOptional()
    sentAt?: Date;

    @Column({ type: 'datetime', nullable: true })
    @ApiProperty({
        description: 'Date and time when email was delivered',
        example: '2024-01-01T12:00:30.000Z',
        required: false,
    })
    @IsDateString()
    @IsOptional()
    deliveredAt?: Date;

    @Column('text', { nullable: true })
    @ApiProperty({
        description: 'Error message if email failed',
        example: 'SMTP Error: Connection timeout',
        required: false,
    })
    @IsString()
    @IsOptional()
    errorMessage?: string;

    @Column('json', { nullable: true })
    @ApiProperty({
        description: 'Additional metadata for the email',
        example: { userId: '123', testId: '456', priority: 'high' },
        required: false,
    })
    @IsObject()
    @IsOptional()
    metadata?: Record<string, any>;

    @Column({ default: 0 })
    @ApiProperty({
        description: 'Number of retry attempts',
        example: 2,
    })
    retryCount: number;

    @Column({ type: 'datetime', nullable: true })
    @ApiProperty({
        description: 'Next retry attempt time',
        example: '2024-01-01T13:00:00.000Z',
        required: false,
    })
    @IsDateString()
    @IsOptional()
    nextRetryAt?: Date;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'External email service message ID',
        example: '<msg-123@smtp.gmail.com>',
        required: false,
    })
    @IsString()
    @IsOptional()
    externalMessageId?: string;

    @CreateDateColumn()
    @ApiProperty({
        description: 'Record creation date',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @UpdateDateColumn()
    @ApiProperty({
        description: 'Record last update date',
        example: '2024-01-01T00:00:00.000Z',
    })
    updatedAt: Date;

    @ManyToOne(() => Organization, { nullable: false })
    @ApiProperty({
        description: 'Organization this communication belongs to',
        type: () => Organization,
    })
    orgId: Organization;

    @ManyToOne(() => Branch, { nullable: true })
    @ApiProperty({
        description: 'Branch this communication belongs to',
        type: () => Branch,
        required: false,
    })
    branchId?: Branch;

    constructor(partial: Partial<Communication>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #49: EmailListener
 * Source: communications/listeners/email.listener.ts:17
 * Type: Exported Class
 * Methods: 20
 * Properties: 19
 * Decorators: 9
 * Complexity: 114
 * Size: 7764 characters (234 lines)
 */
export class EmailListener {
    private readonly logger = new Logger(EmailListener.name);

    constructor(
        private readonly communicationsService: CommunicationsService,
    ) {}

    @OnEvent('organization.created')
    async handleOrganizationCreated(event: OrganizationCreatedEvent) {
        try {
            this.logger.log(
                `Handling organization created event for: ${event.organizationName}`,
            );

            await this.communicationsService.sendWelcomeOrganizationEmail(
                event.organizationId,
                event.organizationName,
                event.organizationEmail,
                event.logoUrl,
                event.website,
            );
        } catch (error) {
            this.logger.error(
                'Failed to handle organization created event',
                error instanceof Error ? error.message : String(error),
            );
        }
    }

    @OnEvent('branch.created')
    async handleBranchCreated(event: BranchCreatedEvent) {
        try {
            this.logger.log(
                `Handling branch created event for: ${event.branchName}`,
            );

            await this.communicationsService.sendWelcomeBranchEmail(
                event.branchId,
                event.branchName,
                event.branchEmail,
                event.organizationId,
                event.organizationName,
                event.address,
                event.contactNumber,
                event.managerName,
            );
        } catch (error) {
            this.logger.error(
                'Failed to handle branch created event',
                error instanceof Error ? error.message : String(error),
            );
        }
    }

    @OnEvent('user.created')
    async handleUserCreated(event: UserCreatedEvent) {
        try {
            this.logger.log(
                `Handling user created event for: ${event.firstName} ${event.lastName}`,
            );

            await this.communicationsService.sendWelcomeUserEmail(
                event.userId,
                event.userEmail,
                event.firstName,
                event.lastName,
                event.organizationId,
                event.organizationName,
                event.branchId,
                event.branchName,
                event.avatar,
            );
        } catch (error) {
            this.logger.error(
                'Failed to handle user created event',
                error instanceof Error ? error.message : String(error),
            );
        }
    }

    @OnEvent('user.profile.updated')
    async handleUserProfileUpdated(event: UserProfileUpdatedEvent) {
        try {
            this.logger.log(
                `Handling user profile updated event for: ${event.firstName} ${event.lastName}`,
            );

            await this.communicationsService.sendUserProfileUpdateEmail(
                event.userId,
                event.userEmail,
                event.firstName,
                event.lastName,
                event.updatedFields || [],
                event.organizationName,
                event.branchName,
            );
        } catch (error) {
            this.logger.error(
                'Failed to handle user profile updated event',
                error instanceof Error ? error.message : String(error),
            );
        }
    }

    @OnEvent('user.password.changed')
    async handleUserPasswordChanged(event: UserPasswordChangedEvent) {
        try {
            this.logger.log(
                `Handling user password changed event for: ${event.firstName} ${event.lastName}`,
            );

            await this.communicationsService.sendPasswordChangeEmail(
                event.userId,
                event.userEmail,
                event.firstName,
                event.lastName,
                event.organizationName,
                event.branchName,
            );
        } catch (error) {
            this.logger.error(
                'Failed to handle user password changed event',
                error instanceof Error ? error.message : String(error),
            );
        }
    }

    @OnEvent('user.org.branch.assigned')
    async handleUserOrgBranchAssigned(event: UserOrgBranchAssignedEvent) {
        try {
            this.logger.log(
                `Handling user organization/branch assignment event for: ${event.firstName} ${event.lastName}`,
            );

            if (event.organizationName) {
                await this.communicationsService.sendOrganizationAssignmentEmail(
                    event.userId,
                    event.userEmail,
                    event.firstName,
                    event.lastName,
                    event.organizationName,
                    event.branchName,
                    event.assignedBy,
                );
            }
        } catch (error) {
            this.logger.error(
                'Failed to handle user organization/branch assignment event',
                error instanceof Error ? error.message : String(error),
            );
        }
    }

    @OnEvent('user.deactivated')
    async handleUserDeactivated(event: UserDeactivatedEvent) {
        try {
            this.logger.log(
                `Handling user deactivated event for: ${event.firstName} ${event.lastName}`,
            );

            await this.communicationsService.sendUserDeactivatedEmail(
                event.userId,
                event.userEmail,
                event.firstName,
                event.lastName,
                event.organizationId,
                event.organizationName,
                event.branchId,
                event.branchName,
                event.reason,
                event.deactivatedBy,
            );
        } catch (error) {
            this.logger.error(
                'Failed to handle user deactivated event',
                error instanceof Error ? error.message : String(error),
            );
        }
    }

    @OnEvent('user.restored')
    async handleUserRestored(event: UserRestoredEvent) {
        try {
            this.logger.log(
                `Handling user restored event for: ${event.firstName} ${event.lastName}`,
            );

            await this.communicationsService.sendUserRestoredEmail(
                event.userId,
                event.userEmail,
                event.firstName,
                event.lastName,
                event.organizationId,
                event.organizationName,
                event.branchId,
                event.branchName,
                event.restoredBy,
            );
        } catch (error) {
            this.logger.error(
                'Failed to handle user restored event',
                error instanceof Error ? error.message : String(error),
            );
        }
    }

    @OnEvent('course.created')
    async handleCourseCreated(event: CourseCreatedEvent) {
        try {
            this.logger.log(
                `Handling course created event for: ${event.title}`,
            );

            await this.communicationsService.sendCourseCreatedEmail(
                event.courseId,
                event.title,
                event.description,
                event.creatorId,
                event.creatorEmail,
                event.creatorFirstName,
                event.creatorLastName,
                event.organizationId,
                event.organizationName,
                event.branchId,
                event.branchName,
            );
        } catch (error) {
            this.logger.error(
                'Failed to handle course created event',
                error instanceof Error ? error.message : String(error),
            );
        }
    }
}

/*
 * Class #50: CommunicationsService
 * Source: communications/services/communications.service.ts:10
 * Type: Exported Class
 * Methods: 4
 * Properties: 20
 * Decorators: 2
 * Complexity: 22
 * Size: 2436 characters (79 lines)
 */
export class CommunicationsService {
    private readonly logger = new Logger(CommunicationsService.name);

    constructor(
        @Inject(forwardRef(() => EmailTemplateService))
        private readonly emailTemplateService: EmailTemplateService,
        private readonly emailQueueService: EmailQueueService,
        private readonly configService: ConfigService,
    ) {}

    /**
     * Get base template data that all emails should include
     */
    private getBaseTemplateData(
        recipientEmail: string,
        recipientName?: string,
    ) {
        const clientUrl = this.configService.get(
            'CLIENT_URL',
            'http://localhost:3000',
        );
        const appName = this.configService.get('APP_NAME', 'trainpro Platform');
        const supportEmail = this.configService.get(
            'SUPPORT_EMAIL',
            'support@trainpro.com',
        );

        return {
            recipientName,
            recipientEmail,
            companyName: appName,
            companyUrl: clientUrl,
            supportEmail,
            unsubscribeUrl: `${clientUrl}/unsubscribe`,
        };
    }

    async sendWelcomeOrganizationEmail(
        organizationId: string,
        organizationName: string,
        organizationEmail: string,
        logoUrl?: string,
        website?: string,
    ): Promise<void> {
        try {
            const clientUrl = this.configService.get(
                'CLIENT_URL',
                'http://localhost:3000',
            );
            const baseData = this.getBaseTemplateData(
                organizationEmail,
                organizationName,
            );

            const templateData: WelcomeOrganizationTemplateData = {
                ...baseData,
                organizationName,
                organizationId,
                dashboardUrl: `${clientUrl}/dashboard`,
                loginUrl: `${clientUrl}/login`,
                logoUrl,
                website,
                setupGuideUrl: `${clientUrl}/setup-guide`,
            };

            const rendered = await this.emailTemplateService.renderByType(
                EmailType.WELCOME_ORGANIZATION,
                templateData,
            );

            // ... existing code ...
        } catch (error) {
            this.logger.error(
                `Error sending welcome organization email: ${error.message}`,
            );
            throw error;
        }
    }
}

/*
 * Class #51: EmailConfigService
 * Source: communications/services/email-config.service.ts:7
 * Type: Exported Class
 * Methods: 13
 * Properties: 44
 * Decorators: 0
 * Complexity: 38
 * Size: 5548 characters (167 lines)
 */
export class EmailConfigService {
    private readonly logger = new Logger(EmailConfigService.name);
    private config: EmailConfig;

    constructor(private readonly configService: ConfigService) {
        this.config = this.loadConfiguration();
        this.validateConfiguration();
    }

    private loadConfiguration(): EmailConfig {
        return {
            smtp: {
                host: this.configService.get<string>(
                    'SMTP_HOST',
                    'smtp.gmail.com',
                ),
                port: this.configService.get<number>('SMTP_PORT', 587),
                secure: this.configService.get<boolean>('SMTP_SECURE', false),
                auth: {
                    user: this.configService.get<string>('SMTP_USER') || '',
                    pass: this.configService.get<string>('SMTP_PASSWORD') || '',
                },
                pool: this.configService.get<boolean>('SMTP_POOL', true),
                maxConnections: this.configService.get<number>(
                    'SMTP_MAX_CONNECTIONS',
                    5,
                ),
                maxMessages: this.configService.get<number>(
                    'SMTP_MAX_MESSAGES',
                    100,
                ),
                rateDelta: this.configService.get<number>(
                    'SMTP_RATE_DELTA',
                    1000,
                ),
                rateLimit: this.configService.get<number>(
                    'SMTP_RATE_LIMIT',
                    14,
                ),
            },
            defaults: {
                from: {
                    name: this.configService.get<string>(
                        'EMAIL_FROM_NAME',
                        'trainpro Platform',
                    ),
                    address:
                        this.configService.get<string>('EMAIL_FROM_ADDRESS') ||
                        '',
                },
                replyTo: this.configService.get<string>('EMAIL_REPLY_TO'),
            },
            retries: {
                maxAttempts: this.configService.get<number>(
                    'EMAIL_MAX_RETRIES',
                    3,
                ),
                backoffFactor: this.configService.get<number>(
                    'EMAIL_BACKOFF_FACTOR',
                    2,
                ),
                initialDelay: this.configService.get<number>(
                    'EMAIL_INITIAL_DELAY',
                    1000,
                ),
                maxDelay: this.configService.get<number>(
                    'EMAIL_MAX_DELAY',
                    30000,
                ),
            },
            templates: {
                baseUrl: this.configService.get<string>(
                    'EMAIL_TEMPLATES_PATH',
                    './templates',
                ),
                defaultTemplate: this.configService.get<string>(
                    'EMAIL_DEFAULT_TEMPLATE',
                    'default',
                ),
            },
        };
    }

    private validateConfiguration(): void {
        const requiredFields = [
            'SMTP_USER',
            'SMTP_PASSWORD',
            'EMAIL_FROM_ADDRESS',
        ];

        const missingFields = requiredFields.filter(
            field => !this.configService.get(field),
        );

        if (missingFields.length > 0) {
            const error = `Missing required email configuration: ${missingFields.join(', ')}`;
            this.logger.error(error);
            throw new Error(error);
        }

        // Validate email format
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        const fromAddress = this.config.defaults.from.address;

        if (!emailRegex.test(fromAddress)) {
            const error = `Invalid email format for EMAIL_FROM_ADDRESS: ${fromAddress}`;
            this.logger.error(error);
            throw new Error(error);
        }

        this.logger.log('Email configuration validation successful');
    }

    getConfig(): EmailConfig {
        return this.config;
    }

    getSMTPConfig(): EmailConfig['smtp'] {
        return this.config.smtp;
    }

    getDefaults(): EmailConfig['defaults'] {
        return this.config.defaults;
    }

    getRetryConfig(): EmailConfig['retries'] {
        return this.config.retries;
    }

    getTemplateConfig(): EmailConfig['templates'] {
        return this.config.templates;
    }

    async testConnection(): Promise<boolean> {
        try {
            const transporter = nodemailer.createTransport({
                host: this.config.smtp.host,
                port: this.config.smtp.port,
                secure: this.config.smtp.secure,
                auth: {
                    user: this.config.smtp.auth.user,
                    pass: this.config.smtp.auth.pass,
                },
            });

            await transporter.verify();
            this.logger.log('SMTP connection test successful');
            return true;
        } catch (error) {
            this.logger.error('SMTP connection test failed:', error.message);
            return false;
        }
    }

    getConnectionInfo(): object {
        return {
            host: this.config.smtp.host,
            port: this.config.smtp.port,
            secure: this.config.smtp.secure,
            user: this.config.smtp.auth.user,
            pool: this.config.smtp.pool,
            maxConnections: this.config.smtp.maxConnections,
            maxMessages: this.config.smtp.maxMessages,
            rateLimit: this.config.smtp.rateLimit,
        };
    }
}

/*
 * Class #52: EmailQueueService
 * Source: communications/services/email-queue.service.ts:52
 * Type: Exported Class
 * Methods: 40
 * Properties: 59
 * Decorators: 0
 * Complexity: 194
 * Size: 13188 characters (399 lines)
 * Implements: OnModuleInit, OnModuleDestroy
 */
export class EmailQueueService implements OnModuleInit, OnModuleDestroy {
    private readonly logger = new Logger(EmailQueueService.name);
    private emailQueue: EmailJobData[] = [];
    private bulkEmailQueue: BulkEmailJobData[] = [];
    private processing = false;
    private processingInterval: NodeJS.Timeout | null = null;
    private readonly concurrency = 5;
    private readonly rateLimitPerSecond = 10;
    private readonly bulkConcurrency = 2;
    private lastProcessedTime = 0;

    constructor(
        private configService: ConfigService,
        private emailSMTPService: EmailSMTPService,
    ) {}

    onModuleInit(): void {
        this.initializeQueues();
        this.startProcessing();
    }

    onModuleDestroy() {
        if (this.processingInterval) {
            clearInterval(this.processingInterval);
        }
        this.logger.log('Email queue service destroyed');
    }

    private initializeQueues() {
        this.emailQueue = [];
        this.bulkEmailQueue = [];
        this.logger.log('Email queues initialized successfully');
    }

    private startProcessing() {
        // Process queues every second
        this.processingInterval = setInterval(() => {
            if (!this.processing) {
                this.processing = true;
                this.processQueues()
                    .catch(error => {
                        this.logger.error('Error processing queues:', error);
                    })
                    .finally(() => {
                        this.processing = false;
                    });
            }
        }, 1000);

        this.logger.log('Email workers initialized successfully');
    }

    private async processQueues() {
        const now = Date.now();

        // Rate limiting: ensure we don't exceed rate limits
        if (now - this.lastProcessedTime < 100) {
            return;
        }

        // Process regular email queue
        await this.processEmailQueue();

        // Process bulk email queue
        await this.processBulkEmailQueue();

        this.lastProcessedTime = now;
    }

    private async processEmailQueue() {
        const now = new Date();
        const readyJobs = this.emailQueue
            .filter(
                job =>
                    job.status === 'pending' &&
                    (!job.scheduledFor || job.scheduledFor <= now),
            )
            .sort((a, b) => (a.priority || 3) - (b.priority || 3))
            .slice(0, this.concurrency);

        for (const job of readyJobs) {
            try {
                job.status = 'processing';
                this.logger.log(`Processing email job ${job.id}...`);

                const result = await this.emailSMTPService.sendEmail(
                    job.emailOptions,
                );

                if (result.success) {
                    job.status = 'completed';
                    this.logger.log(
                        `Email job ${job.id} completed successfully`,
                    );
                    // Remove completed jobs after a delay
                    setTimeout(() => this.removeCompletedJob(job.id), 5000);
                } else {
                    this.handleJobFailure(job, result.error || 'Unknown error');
                }
            } catch (error) {
                this.handleJobFailure(job, error?.message || 'Unknown error');
            }
        }
    }

    private async processBulkEmailQueue() {
        const now = new Date();
        const readyJobs = this.bulkEmailQueue
            .filter(
                job =>
                    job.status === 'pending' &&
                    (!job.scheduledFor || job.scheduledFor <= now),
            )
            .sort((a, b) => (a.priority || 5) - (b.priority || 5))
            .slice(0, this.bulkConcurrency);

        for (const job of readyJobs) {
            try {
                job.status = 'processing';
                job.progress = 0;
                this.logger.log(
                    `Processing bulk email job ${job.id} with ${job.emails.length} emails...`,
                );

                const results = await this.processBulkEmailJobData(job);

                const successCount = results.filter(r => r.success).length;
                const failureCount = results.length - successCount;

                job.status = 'completed';
                job.progress = 100;
                this.logger.log(
                    `Bulk email job ${job.id} completed: ${successCount} successful, ${failureCount} failed`,
                );

                // Remove completed jobs after a delay
                setTimeout(() => this.removeBulkCompletedJob(job.id), 10000);
            } catch (error) {
                await this.handleBulkJobFailure(job, error.message);
            }
        }
    }

    private async processBulkEmailJobData(
        job: BulkEmailJobData,
    ): Promise<EmailSendResult[]> {
        const { emails, batchSize = 10 } = job;
        const results: EmailSendResult[] = [];

        for (let i = 0; i < emails.length; i += batchSize) {
            const batch = emails.slice(i, i + batchSize);
            const batchResults =
                await this.emailSMTPService.sendBulkEmails(batch);
            results.push(...batchResults);

            // Update job progress
            const progress = Math.round(
                ((i + batchSize) / emails.length) * 100,
            );
            job.progress = Math.min(progress, 100);

            // Brief pause between batches
            if (i + batchSize < emails.length) {
                await this.delay(100);
            }
        }

        return results;
    }

    private handleJobFailure(job: EmailJobData, error: string) {
        job.attempts = (job.attempts || 0) + 1;
        job.maxAttempts = job.maxAttempts || 3;

        if (job.attempts < job.maxAttempts) {
            job.status = 'retrying';
            // Exponential backoff: delay = 2^attempts seconds
            job.scheduledFor = new Date(
                Date.now() + Math.pow(2, job.attempts) * 1000,
            );
            this.logger.warn(
                `Email job ${job.id} failed, retrying in ${Math.pow(2, job.attempts)} seconds`,
            );
        } else {
            job.status = 'failed';
            this.logger.error(`Email job ${job.id} failed permanently:`, error);
            // Remove failed jobs after a longer delay
            setTimeout(() => this.removeCompletedJob(job.id), 30000);
        }
    }

    private async handleBulkJobFailure(job: BulkEmailJobData, error: string) {
        job.attempts = (job.attempts || 0) + 1;
        job.maxAttempts = job.maxAttempts || 2;

        if (job.attempts < job.maxAttempts) {
            job.status = 'retrying';
            job.scheduledFor = new Date(
                Date.now() + Math.pow(2, job.attempts) * 2000,
            );
            this.logger.warn(
                `Bulk email job ${job.id} failed, retrying in ${Math.pow(2, job.attempts) * 2} seconds`,
            );
        } else {
            job.status = 'failed';
            this.logger.error(
                `Bulk email job ${job.id} failed permanently:`,
                error,
            );
            setTimeout(() => this.removeBulkCompletedJob(job.id), 60000);
        }
    }

    async queueEmail(
        emailOptions: EmailSendOptions,
        priority: EmailJobPriority = EmailJobPriority.NORMAL,
        delay?: number,
        metadata?: Record<string, any>,
    ): Promise<string> {
        const jobId = `email-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

        const jobData: EmailJobData = {
            id: jobId,
            emailOptions,
            priority,
            metadata,
            attempts: 0,
            maxAttempts: 3,
            createdAt: new Date(),
            scheduledFor: delay ? new Date(Date.now() + delay) : undefined,
            status: 'pending',
        };

        this.emailQueue.push(jobData);

        this.logger.log(
            `Email queued with ID: ${jobId}, Priority: ${priority}`,
        );
        return jobId;
    }

    async queueBulkEmails(
        emails: EmailSendOptions[],
        priority: EmailJobPriority = EmailJobPriority.BULK,
        batchSize: number = 10,
        delay?: number,
        metadata?: Record<string, any>,
    ): Promise<string> {
        const jobId = `bulk-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

        const jobData: BulkEmailJobData = {
            id: jobId,
            emails,
            priority,
            batchSize,
            metadata,
            attempts: 0,
            maxAttempts: 2,
            createdAt: new Date(),
            scheduledFor: delay ? new Date(Date.now() + delay) : undefined,
            status: 'pending',
            progress: 0,
        };

        this.bulkEmailQueue.push(jobData);

        this.logger.log(
            `Bulk email job queued with ID: ${jobId}, ${emails.length} emails`,
        );
        return jobId;
    }

    async getJobStatus(
        jobId: string,
    ): Promise<EmailJobData | BulkEmailJobData | null> {
        const emailJob = this.emailQueue.find(job => job.id === jobId);
        if (emailJob) return emailJob;

        const bulkJob = this.bulkEmailQueue.find(job => job.id === jobId);
        return bulkJob || null;
    }

    async getQueueStats() {
        const emailStats = {
            pending: this.emailQueue.filter(job => job.status === 'pending')
                .length,
            processing: this.emailQueue.filter(
                job => job.status === 'processing',
            ).length,
            completed: this.emailQueue.filter(job => job.status === 'completed')
                .length,
            failed: this.emailQueue.filter(job => job.status === 'failed')
                .length,
            retrying: this.emailQueue.filter(job => job.status === 'retrying')
                .length,
        };

        const bulkEmailStats = {
            pending: this.bulkEmailQueue.filter(job => job.status === 'pending')
                .length,
            processing: this.bulkEmailQueue.filter(
                job => job.status === 'processing',
            ).length,
            completed: this.bulkEmailQueue.filter(
                job => job.status === 'completed',
            ).length,
            failed: this.bulkEmailQueue.filter(job => job.status === 'failed')
                .length,
            retrying: this.bulkEmailQueue.filter(
                job => job.status === 'retrying',
            ).length,
        };

        return {
            emailQueue: emailStats,
            bulkEmailQueue: bulkEmailStats,
            timestamp: new Date(),
        };
    }

    async pauseQueues(): Promise<void> {
        if (this.processingInterval) {
            clearInterval(this.processingInterval);
            this.processingInterval = null;
        }
        this.logger.log('Email queues paused');
    }

    async resumeQueues(): Promise<void> {
        if (!this.processingInterval) {
            await this.startProcessing();
        }
        this.logger.log('Email queues resumed');
    }

    async retryFailedJobs(limit: number = 10): Promise<number> {
        const failedEmailJobs = this.emailQueue
            .filter(job => job.status === 'failed')
            .slice(0, limit);

        const failedBulkJobs = this.bulkEmailQueue
            .filter(job => job.status === 'failed')
            .slice(0, limit - failedEmailJobs.length);

        let retriedCount = 0;

        for (const job of failedEmailJobs) {
            job.status = 'pending';
            job.attempts = 0;
            job.scheduledFor = undefined;
            retriedCount++;
        }

        for (const job of failedBulkJobs) {
            job.status = 'pending';
            job.attempts = 0;
            job.scheduledFor = undefined;
            job.progress = 0;
            retriedCount++;
        }

        this.logger.log(`Retried ${retriedCount} failed jobs`);
        return retriedCount;
    }

    async clearCompletedJobs(): Promise<number> {
        const emailCompleted = this.emailQueue.filter(
            job => job.status === 'completed',
        ).length;
        const bulkCompleted = this.bulkEmailQueue.filter(
            job => job.status === 'completed',
        ).length;

        this.emailQueue = this.emailQueue.filter(
            job => job.status !== 'completed',
        );
        this.bulkEmailQueue = this.bulkEmailQueue.filter(
            job => job.status !== 'completed',
        );

        const totalCleared = emailCompleted + bulkCompleted;
        this.logger.log(`Cleared ${totalCleared} completed jobs`);
        return totalCleared;
    }

    private removeCompletedJob(jobId: string): void {
        this.emailQueue = this.emailQueue.filter(job => job.id !== jobId);
    }

    private removeBulkCompletedJob(jobId: string): void {
        this.bulkEmailQueue = this.bulkEmailQueue.filter(
            job => job.id !== jobId,
        );
    }

    private delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

/*
 * Class #53: EmailSMTPService
 * Source: communications/services/email-smtp.service.ts:30
 * Type: Exported Class
 * Methods: 30
 * Properties: 71
 * Decorators: 0
 * Complexity: 155
 * Size: 10080 characters (306 lines)
 */
export class EmailSMTPService {
    private readonly logger = new Logger(EmailSMTPService.name);
    private transporter: Transporter;
    private readonly maxRetries = 3;
    private readonly retryDelay = 1000; // 1 second base delay

    constructor(private configService: ConfigService) {
        this.initializeTransporter();
    }

    private initializeTransporter(): void {
        const port = this.configService.get<number>('SMTP_PORT', 587);
        const isSecurePort = port === 465;

        const smtpConfig: any = {
            host: this.configService.get<string>('SMTP_HOST', 'smtp.gmail.com'),
            port: port,
            secure: isSecurePort, // true for 465, false for other ports like 587
            auth: {
                user: this.configService.get<string>('SMTP_USER'),
                pass:
                    this.configService.get<string>('SMTP_PASSWORD') ||
                    this.configService.get<string>('SMTP_PASS'),
            },
            pool: this.configService.get<boolean>('SMTP_POOL', true),
            maxConnections: this.configService.get<number>(
                'SMTP_MAX_CONNECTIONS',
                5,
            ),
            maxMessages: this.configService.get<number>(
                'SMTP_MAX_MESSAGES',
                100,
            ),
            tls: {
                rejectUnauthorized: false,
                minVersion: 'TLSv1.2',
            },
        };

        // Add rate limiting if configured
        const rateLimit = this.configService.get<number>('SMTP_RATE_LIMIT');
        if (rateLimit) {
            smtpConfig.rateLimit = rateLimit;
            smtpConfig.rateDelta = this.configService.get<number>(
                'SMTP_RATE_DELTA',
                1000,
            );
        }

        // Add debug logging if enabled
        if (this.configService.get<boolean>('SMTP_DEBUG', false)) {
            smtpConfig.debug = true;
            smtpConfig.logger = true;
        }

        this.transporter = nodemailer.createTransport(smtpConfig);

        // Verify connection configuration
        this.verifyConnection();
    }

    private async verifyConnection(): Promise<void> {
        try {
            await this.transporter.verify();
            this.logger.log('✅ SMTP');
        } catch (error: unknown) {
            const errorMessage = this.getErrorMessage(error);
            this.logger.error('SMTP connection verification failed:', error);
            throw new Error(`SMTP configuration error: ${errorMessage}`);
        }
    }

    async sendEmail(
        options: EmailSendOptions,
        retryCount = 0,
    ): Promise<EmailSendResult> {
        const startTime = Date.now();

        try {
            const fromEmail =
                this.configService.get<string>('EMAIL_FROM_ADDRESS') ||
                this.configService.get<string>('SMTP_FROM') ||
                this.configService.get<string>('SMTP_USER') ||
                '';

            const fromName = this.configService.get<string>(
                'EMAIL_FROM_NAME',
                'trainpro Platform',
            );
            const fromString = fromName
                ? `"${fromName}" <${fromEmail}>`
                : fromEmail;

            const mailOptions = {
                from: fromString,
                to: Array.isArray(options.to)
                    ? options.to.join(', ')
                    : options.to,
                cc: options.cc
                    ? Array.isArray(options.cc)
                        ? options.cc.join(', ')
                        : options.cc
                    : undefined,
                bcc: options.bcc
                    ? Array.isArray(options.bcc)
                        ? options.bcc.join(', ')
                        : options.bcc
                    : undefined,
                subject: options.subject,
                text: options.text,
                html: options.html,
                attachments: options.attachments,
            };

            const result = (await this.transporter.sendMail(
                mailOptions,
            )) as SentMessageInfo;

            const duration = Date.now() - startTime;
            this.logger.log(
                `Email sent successfully in ${duration}ms - MessageID: ${result.messageId}`,
            );

            return {
                success: true,
                messageId: result.messageId,
                retryCount,
                sentAt: new Date(),
            };
        } catch (error: unknown) {
            const duration = Date.now() - startTime;
            const errorMessage = this.getErrorMessage(error);
            this.logger.error(
                `Email send failed after ${duration}ms (attempt ${retryCount + 1}/${this.maxRetries + 1}):`,
                error,
            );

            // Check if we should retry
            if (retryCount < this.maxRetries && this.shouldRetry(error)) {
                const delay = this.calculateRetryDelay(retryCount);
                this.logger.log(`Retrying email send in ${delay}ms...`);

                await this.delay(delay);
                return this.sendEmail(options, retryCount + 1);
            }

            return {
                success: false,
                error: errorMessage,
                retryCount,
            };
        }
    }

    async sendBulkEmails(
        emails: EmailSendOptions[],
    ): Promise<EmailSendResult[]> {
        this.logger.log(`Starting bulk email send for ${emails.length} emails`);

        const results: EmailSendResult[] = [];
        const batchSize = 10; // Process in batches to avoid overwhelming the SMTP server

        for (let i = 0; i < emails.length; i += batchSize) {
            const batch = emails.slice(i, i + batchSize);
            const batchPromises = batch.map(email => this.sendEmail(email));

            const batchResults = await Promise.allSettled(batchPromises);

            batchResults.forEach(result => {
                if (result.status === 'fulfilled') {
                    results.push(result.value);
                } else {
                    const errorMessage = this.getErrorMessage(result.reason);
                    results.push({
                        success: false,
                        error: errorMessage,
                        retryCount: 0,
                    });
                }
            });

            // Add delay between batches to respect rate limits
            if (i + batchSize < emails.length) {
                await this.delay(100);
            }
        }

        const successCount = results.filter(r => r.success).length;
        this.logger.log(
            `Bulk email send completed: ${successCount}/${emails.length} successful`,
        );

        return results;
    }

    async testConnection(): Promise<{ connected: boolean; error?: string }> {
        try {
            await this.transporter.verify();
            return { connected: true };
        } catch (error: unknown) {
            const errorMessage = this.getErrorMessage(error);
            this.logger.error('SMTP connection test failed:', error);
            return {
                connected: false,
                error: errorMessage,
            };
        }
    }

    getConnectionInfo(): {
        host: string;
        port: number;
        secure: boolean;
        poolSize: number;
        authenticated: boolean;
    } {
        const options = this.transporter.options as {
            host?: string;
            port?: number;
            secure?: boolean;
            maxConnections?: number;
            auth?: { user?: string };
        };

        return {
            host: options.host ?? 'unknown',
            port: options.port ?? 0,
            secure: options.secure ?? false,
            poolSize: options.maxConnections ?? 1,
            authenticated: !!options.auth?.user,
        };
    }

    private shouldRetry(error: unknown): boolean {
        // Retry on temporary failures, but not on authentication or permanent errors
        const retryableErrors = [
            'ETIMEDOUT',
            'ECONNRESET',
            'ENOTFOUND',
            'ECONNREFUSED',
            'EMFILE',
        ];

        const errorCode = this.getErrorCode(error);
        const errorMessage = this.getErrorMessage(error).toLowerCase();

        // Don't retry on authentication errors
        if (
            errorMessage.includes('authentication') ||
            errorMessage.includes('invalid login')
        ) {
            return false;
        }

        // Don't retry on invalid recipient errors
        if (
            errorMessage.includes('recipient') ||
            errorMessage.includes('invalid')
        ) {
            return false;
        }

        return (
            retryableErrors.includes(errorCode) ||
            errorMessage.includes('timeout') ||
            errorMessage.includes('connection')
        );
    }

    private calculateRetryDelay(retryCount: number): number {
        // Exponential backoff: 1s, 2s, 4s
        return this.retryDelay * Math.pow(2, retryCount);
    }

    private delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    private getErrorMessage(error: unknown): string {
        if (error instanceof Error) {
            return error.message;
        }
        if (typeof error === 'string') {
            return error;
        }
        if (error && typeof error === 'object' && 'message' in error) {
            return String((error as { message: unknown }).message);
        }
        return 'Unknown error';
    }

    private getErrorCode(error: unknown): string {
        if (error && typeof error === 'object') {
            const errorObj = error as { code?: string; errno?: string };
            return errorObj.code || errorObj.errno || '';
        }
        return '';
    }

    close(): void {
        if (this.transporter) {
            this.transporter.close();
            this.logger.log('SMTP transporter closed');
        }
    }
}

/*
 * Class #54: EmailTemplateService
 * Source: communications/services/email-template.service.ts:16
 * Type: Exported Class
 * Methods: 36
 * Properties: 204
 * Decorators: 0
 * Complexity: 167
 * Size: 22358 characters (578 lines)
 */
export class EmailTemplateService {
    private readonly logger = new Logger(EmailTemplateService.name);
    private templateCache: Map<string, Handlebars.TemplateDelegate> = new Map();
    private templateConfigs: Map<EmailType, TemplateConfig> = new Map();
    private templatesPath: string;

    constructor(private readonly configService: ConfigService) {
        this.templatesPath = this.configService.get<string>(
            'EMAIL_TEMPLATES_PATH',
            path.join(process.cwd(), 'templates'),
        );
        this.initializeHandlebars();
    }

    async onModuleInit() {
        this.loadTemplateConfigurations();
        await this.preloadTemplates();
    }

    private initializeHandlebars(): void {
        // Register common Handlebars helpers
        Handlebars.registerHelper('eq', (a: any, b: any): boolean => a === b);
        Handlebars.registerHelper('ne', (a: any, b: any): boolean => a !== b);
        Handlebars.registerHelper('gt', (a: any, b: any): boolean => a > b);
        Handlebars.registerHelper('lt', (a: any, b: any): boolean => a < b);
        Handlebars.registerHelper('gte', (a: any, b: any): boolean => a >= b);
        Handlebars.registerHelper('lte', (a: any, b: any): boolean => a <= b);
        Handlebars.registerHelper('and', (a: any, b: any): boolean => a && b);
        Handlebars.registerHelper('or', (a: any, b: any): boolean => a || b);
        Handlebars.registerHelper('not', a => !a);

        // Date formatting helper
        Handlebars.registerHelper(
            'formatDate',
            (date: any, format: any): string => {
                if (!date) return '';
                const d = new Date(date);
                if (format === 'short') {
                    return d.toLocaleDateString();
                }
                if (format === 'long') {
                    return (
                        d.toLocaleDateString() + ' ' + d.toLocaleTimeString()
                    );
                }
                return d.toISOString();
            },
        );

        // Percentage helper
        Handlebars.registerHelper(
            'percentage',
            (value: any, total: any): string => {
                if (!total || total === 0) return '0%';
                return Math.round((value / total) * 100) + '%';
            },
        );

        // Capitalize helper
        Handlebars.registerHelper('capitalize', (str: any): string => {
            if (!str) return '';
            const stringValue = String(str);
            return (
                stringValue.charAt(0).toUpperCase() +
                stringValue.slice(1).toLowerCase()
            );
        });

        this.logger.log('Handlebars helpers registered successfully');
    }

    private loadTemplateConfigurations(): void {
        try {
            // Define template configurations
            const configs: TemplateConfig[] = [
                {
                    name: 'welcome',
                    type: EmailType.WELCOME,
                    htmlFile: 'welcome.hbs',
                    textFile: 'welcome.txt.hbs',
                    metadata: {
                        name: 'Welcome Email',
                        type: EmailType.WELCOME,
                        version: '1.0.0',
                        description: 'Welcome new users to the platform',
                        requiredData: [
                            'recipientName',
                            'loginUrl',
                            'dashboardUrl',
                        ],
                        optionalData: ['activationToken', 'profileUrl'],
                    },
                },
                {
                    name: 'welcome-organization',
                    type: EmailType.WELCOME_ORGANIZATION,
                    htmlFile: 'welcome-organization.hbs',
                    textFile: 'welcome-organization.txt.hbs',
                    metadata: {
                        name: 'Organization Welcome Email',
                        type: EmailType.WELCOME_ORGANIZATION,
                        version: '1.0.0',
                        description:
                            'Welcome new organizations to the platform',
                        requiredData: [
                            'organizationName',
                            'organizationId',
                            'dashboardUrl',
                            'loginUrl',
                        ],
                        optionalData: ['logoUrl', 'website', 'setupGuideUrl'],
                    },
                },
                {
                    name: 'welcome-branch',
                    type: EmailType.WELCOME_BRANCH,
                    htmlFile: 'welcome-branch.hbs',
                    textFile: 'welcome-branch.txt.hbs',
                    metadata: {
                        name: 'Branch Welcome Email',
                        type: EmailType.WELCOME_BRANCH,
                        version: '1.0.0',
                        description: 'Welcome new branches to the platform',
                        requiredData: [
                            'branchName',
                            'branchId',
                            'organizationName',
                            'organizationId',
                            'dashboardUrl',
                            'loginUrl',
                        ],
                        optionalData: [
                            'address',
                            'contactNumber',
                            'managerName',
                            'setupGuideUrl',
                        ],
                    },
                },
                {
                    name: 'welcome-user',
                    type: EmailType.WELCOME_USER,
                    htmlFile: 'welcome-user.hbs',
                    textFile: 'welcome-user.txt.hbs',
                    metadata: {
                        name: 'User Welcome Email',
                        type: EmailType.WELCOME_USER,
                        version: '1.0.0',
                        description: 'Welcome new users to the platform',
                        requiredData: [
                            'firstName',
                            'lastName',
                            'userId',
                            'dashboardUrl',
                            'loginUrl',
                            'profileUrl',
                        ],
                        optionalData: [
                            'organizationName',
                            'branchName',
                            'avatar',
                            'activationToken',
                            'setupGuideUrl',
                        ],
                    },
                },
                {
                    name: 'password-reset',
                    type: EmailType.PASSWORD_RESET,
                    htmlFile: 'password-reset.hbs',
                    textFile: 'password-reset.txt.hbs',
                    metadata: {
                        name: 'Password Reset',
                        type: EmailType.PASSWORD_RESET,
                        version: '1.0.0',
                        description: 'Password reset instructions',
                        requiredData: ['resetUrl', 'resetToken', 'expiryTime'],
                        optionalData: ['ipAddress'],
                    },
                },
                {
                    name: 'password-changed',
                    type: EmailType.PASSWORD_CHANGED,
                    htmlFile: 'password-changed.hbs',
                    textFile: 'password-changed.txt.hbs',
                    metadata: {
                        name: 'Password Changed',
                        type: EmailType.PASSWORD_CHANGED,
                        version: '1.0.0',
                        description:
                            'Password change confirmation notification',
                        requiredData: [
                            'recipientName',
                            'changeDateTime',
                            'loginUrl',
                        ],
                        optionalData: ['ipAddress', 'userAgent'],
                    },
                },
                {
                    name: 'test-notification',
                    type: EmailType.TEST_NOTIFICATION,
                    htmlFile: 'test-notification.hbs',
                    textFile: 'test-notification.txt.hbs',
                    metadata: {
                        name: 'Test Notification',
                        type: EmailType.TEST_NOTIFICATION,
                        version: '1.0.0',
                        description: 'Notify users about new tests',
                        requiredData: ['testTitle', 'dueDate', 'testUrl'],
                        optionalData: [
                            'testDescription',
                            'duration',
                            'instructorName',
                        ],
                    },
                },
                {
                    name: 'results-summary',
                    type: EmailType.RESULTS_SUMMARY,
                    htmlFile: 'results-summary.hbs',
                    textFile: 'results-summary.txt.hbs',
                    metadata: {
                        name: 'Results Summary',
                        type: EmailType.RESULTS_SUMMARY,
                        version: '1.0.0',
                        description: 'Test results summary',
                        requiredData: [
                            'testTitle',
                            'score',
                            'totalQuestions',
                            'correctAnswers',
                            'percentage',
                            'completionTime',
                            'resultsUrl',
                        ],
                        optionalData: ['feedback'],
                    },
                },
                {
                    name: 'course-enrollment',
                    type: EmailType.COURSE_ENROLLMENT,
                    htmlFile: 'course-enrollment.hbs',
                    textFile: 'course-enrollment.txt.hbs',
                    metadata: {
                        name: 'Course Enrollment',
                        type: EmailType.COURSE_ENROLLMENT,
                        version: '1.0.0',
                        description: 'Course enrollment confirmation',
                        requiredData: ['courseName', 'courseUrl'],
                        optionalData: [
                            'courseDescription',
                            'instructorName',
                            'startDate',
                            'endDate',
                        ],
                    },
                },
                {
                    name: 'course-created',
                    type: EmailType.COURSE_CREATED,
                    htmlFile: 'course-created.hbs',
                    textFile: 'course-created.txt.hbs',
                    metadata: {
                        name: 'Course Created',
                        type: EmailType.COURSE_CREATED,
                        version: '1.0.0',
                        description:
                            'Course creation confirmation for creators',
                        requiredData: [
                            'title',
                            'description',
                            'creatorFirstName',
                            'creatorLastName',
                            'courseUrl',
                            'dashboardUrl',
                        ],
                        optionalData: ['organizationName', 'branchName'],
                    },
                },
                {
                    name: 'user-deactivated',
                    type: EmailType.USER_DEACTIVATED,
                    htmlFile: 'user-deactivated.hbs',
                    textFile: 'user-deactivated.txt.hbs',
                    metadata: {
                        name: 'User Deactivated',
                        type: EmailType.USER_DEACTIVATED,
                        version: '1.0.0',
                        description: 'User account deactivation notification',
                        requiredData: ['firstName', 'lastName', 'userEmail'],
                        optionalData: [
                            'organizationName',
                            'branchName',
                            'reason',
                            'deactivatedBy',
                        ],
                    },
                },
                {
                    name: 'user-restored',
                    type: EmailType.USER_RESTORED,
                    htmlFile: 'user-restored.hbs',
                    textFile: 'user-restored.txt.hbs',
                    metadata: {
                        name: 'User Restored',
                        type: EmailType.USER_RESTORED,
                        version: '1.0.0',
                        description: 'User account restoration notification',
                        requiredData: [
                            'firstName',
                            'lastName',
                            'userEmail',
                            'dashboardUrl',
                        ],
                        optionalData: [
                            'organizationName',
                            'branchName',
                            'restoredBy',
                        ],
                    },
                },
                {
                    name: 'system-alert',
                    type: EmailType.SYSTEM_ALERT,
                    htmlFile: 'system-alert.hbs',
                    textFile: 'system-alert.txt.hbs',
                    metadata: {
                        name: 'System Alert',
                        type: EmailType.SYSTEM_ALERT,
                        version: '1.0.0',
                        description: 'System notifications and alerts',
                        requiredData: [
                            'alertType',
                            'alertTitle',
                            'alertMessage',
                            'timestamp',
                        ],
                        optionalData: ['actionUrl', 'actionText'],
                    },
                },
                {
                    name: 'custom',
                    type: EmailType.CUSTOM,
                    htmlFile: 'custom.hbs',
                    textFile: 'custom.txt.hbs',
                    metadata: {
                        name: 'Custom Email',
                        type: EmailType.CUSTOM,
                        version: '1.0.0',
                        description: 'Flexible custom email template',
                        requiredData: ['title', 'message'],
                        optionalData: [],
                    },
                },
            ];

            // Store configurations
            configs.forEach(config => {
                this.templateConfigs.set(config.type, config);
            });

            this.logger.log(`Loaded ${configs.length} template configurations`);
        } catch (error) {
            this.logger.error('Failed to load template configurations', error);
            throw error;
        }
    }

    private async preloadTemplates(): Promise<void> {
        try {
            for (const [type, config] of this.templateConfigs) {
                await this.loadTemplate(config.htmlFile);
                if (config.textFile) {
                    await this.loadTemplate(config.textFile);
                }
            }
            this.logger.log('✅ Email Templates');
        } catch (error) {
            this.logger.warn('Some templates failed to preload', error);
            // Don't throw - templates can be loaded on demand
        }
    }

    private async loadTemplate(
        templateFile: string,
    ): Promise<Handlebars.TemplateDelegate> {
        const cacheKey = templateFile;

        // Check cache first
        if (this.templateCache.has(cacheKey)) {
            return this.templateCache.get(cacheKey)!;
        }

        try {
            const templatePath = path.join(this.templatesPath, templateFile);
            const templateContent = await fs.readFile(templatePath, 'utf-8');
            const compiledTemplate = Handlebars.compile(templateContent);

            // Cache the compiled template
            this.templateCache.set(cacheKey, compiledTemplate);

            this.logger.debug(`Template loaded and cached: ${templateFile}`);
            return compiledTemplate;
        } catch (error) {
            this.logger.error(
                `Failed to load template: ${templateFile}`,
                error,
            );
            throw new NotFoundException(`Template not found: ${templateFile}`);
        }
    }

    async renderTemplate(
        options: TemplateRenderOptions,
    ): Promise<TemplateRenderResult> {
        const { template, data, format = 'both' } = options;

        try {
            const result: TemplateRenderResult = {
                subject: this.generateSubject(template, data),
            };

            if (format === 'html' || format === 'both') {
                const htmlTemplate = await this.loadTemplate(`${template}.hbs`);
                result.html = htmlTemplate(data);
            }

            if (format === 'text' || format === 'both') {
                try {
                    const textTemplate = await this.loadTemplate(
                        `${template}.txt.hbs`,
                    );
                    result.text = textTemplate(data);
                } catch (error) {
                    // If text template doesn't exist, generate from HTML
                    if (result.html) {
                        result.text = this.stripHtml(result.html);
                    }
                }
            }

            return result;
        } catch (error) {
            this.logger.error(`Failed to render template: ${template}`, error);
            throw error;
        }
    }

    async renderByType(
        type: EmailType,
        data: TemplateData,
        format?: 'html' | 'text' | 'both',
    ): Promise<TemplateRenderResult> {
        const config = this.templateConfigs.get(type);
        if (!config) {
            throw new NotFoundException(
                `Template configuration not found for type: ${type}`,
            );
        }

        // Validate required data
        const validation = this.validateTemplateData(type, data);
        if (!validation.isValid) {
            throw new Error(
                `Template validation failed: ${validation.errors.join(', ')}`,
            );
        }

        return this.renderTemplate({
            template: config.name,
            data,
            format,
        });
    }

    validateTemplateData(
        type: EmailType,
        data: TemplateData,
    ): TemplateValidationResult {
        const config = this.templateConfigs.get(type);
        if (!config) {
            return {
                isValid: false,
                errors: [`Template configuration not found for type: ${type}`],
            };
        }

        const errors: string[] = [];
        const warnings: string[] = [];
        const missingRequired: string[] = [];

        // Check required fields
        config.metadata.requiredData.forEach(field => {
            if (!data[field] && data[field] !== 0 && data[field] !== false) {
                missingRequired.push(field);
                errors.push(`Required field missing: ${field}`);
            }
        });

        // Check email format if present
        if (
            data.recipientEmail &&
            !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.recipientEmail)
        ) {
            errors.push('Invalid email format for recipientEmail');
        }

        return {
            isValid: errors.length === 0,
            errors,
            warnings,
            missingRequired,
        };
    }

    private generateSubject(templateName: string, data: TemplateData): string {
        // Subject templates based on email type
        const subjectTemplates: Record<string, string> = {
            welcome: 'Welcome to {{companyName}} - Get Started!',
            'welcome-organization':
                'Welcome {{organizationName}} to {{companyName}}!',
            'welcome-branch':
                'Welcome {{branchName}} - {{organizationName}} Branch Setup Complete!',
            'welcome-user':
                'Welcome {{firstName}}! Your {{companyName}} Account is Ready',
            'password-reset': 'Password Reset Request',
            'password-changed': 'Password Changed Successfully',
            'test-notification': 'New Test Available: {{testTitle}}',
            'results-summary': 'Test Results: {{testTitle}}',
            'course-enrollment': 'Enrolled in {{courseName}}',
            'system-alert': '{{alertTitle}}',
            custom: '{{title}}',
        };

        const subjectTemplate = subjectTemplates[templateName] || '{{title}}';
        const compiledSubject = Handlebars.compile(subjectTemplate);

        // Provide default company name if not provided
        const subjectData = {
            companyName: 'trainpro Platform',
            ...data,
        };

        return compiledSubject(subjectData);
    }

    private stripHtml(html: string): string {
        return html
            .replace(/<[^>]*>/g, '')
            .replace(/&nbsp;/g, ' ')
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'")
            .trim();
    }

    getTemplateConfig(type: EmailType): TemplateConfig | undefined {
        return this.templateConfigs.get(type);
    }

    getAllTemplateConfigs(): TemplateConfig[] {
        return Array.from(this.templateConfigs.values());
    }

    clearCache(): void {
        this.templateCache.clear();
        this.logger.log('Template cache cleared');
    }

    async reloadTemplate(templateFile: string): Promise<void> {
        this.templateCache.delete(templateFile);
        await this.loadTemplate(templateFile);
        this.logger.log(`Template reloaded: ${templateFile}`);
    }
}

/*
 * Class #55: TemplateTestingService
 * Source: communications/services/template-testing.service.ts:16
 * Type: Exported Class
 * Methods: 16
 * Properties: 102
 * Decorators: 2
 * Complexity: 92
 * Size: 10188 characters (299 lines)
 */
export class TemplateTestingService {
    private readonly logger = new Logger(TemplateTestingService.name);

    constructor(private readonly emailTemplateService: EmailTemplateService) {}

    /**
     * Generate sample data for testing templates
     */
    generateSampleData(type: EmailType): TemplateData {
        const baseData = {
            recipientName: 'John Doe',
            recipientEmail: 'john.doe@example.com',
            companyName: 'trainpro Platform',
            companyUrl: 'https://trainpro.com',
            supportEmail: 'support@trainpro.com',
            unsubscribeUrl: 'https://trainpro.com/unsubscribe?token=sample',
        };

        switch (type) {
            case EmailType.WELCOME:
                return {
                    ...baseData,
                    loginUrl: 'https://trainpro.com/login',
                    dashboardUrl: 'https://trainpro.com/dashboard',
                    profileUrl: 'https://trainpro.com/profile',
                    activationToken: 'sample-activation-token',
                } as WelcomeTemplateData;

            case EmailType.PASSWORD_RESET:
                return {
                    ...baseData,
                    resetUrl:
                        'https://trainpro.com/reset-password?token=sample-reset-token',
                    resetToken: 'sample-reset-token',
                    expiryTime: '15 minutes',
                    ipAddress: '192.168.1.100',
                } as PasswordResetTemplateData;

            case EmailType.TEST_NOTIFICATION:
                return {
                    ...baseData,
                    testTitle: 'JavaScript Fundamentals Quiz',
                    testDescription:
                        'Test your knowledge of JavaScript basics including variables, functions, and DOM manipulation.',
                    dueDate: new Date(
                        Date.now() + 7 * 24 * 60 * 60 * 1000,
                    ).toISOString(), // 7 days from now
                    testUrl:
                        'https://trainpro.com/tests/javascript-fundamentals',
                    duration: '45 minutes',
                    instructorName: 'Dr. Sarah Wilson',
                } as TestNotificationTemplateData;

            case EmailType.RESULTS_SUMMARY:
                return {
                    ...baseData,
                    testTitle: 'JavaScript Fundamentals Quiz',
                    score: 85,
                    totalQuestions: 20,
                    correctAnswers: 17,
                    percentage: 85,
                    completionTime: '32 minutes',
                    resultsUrl:
                        'https://trainpro.com/results/javascript-fundamentals-123',
                    feedback:
                        'Great job! You have a solid understanding of JavaScript fundamentals. Consider reviewing array methods for improvement.',
                } as ResultsSummaryTemplateData;

            case EmailType.COURSE_ENROLLMENT:
                return {
                    ...baseData,
                    courseName: 'Full Stack Web Development',
                    courseDescription:
                        'Learn to build modern web applications using React, Node.js, and databases.',
                    courseUrl:
                        'https://trainpro.com/courses/full-stack-web-dev',
                    instructorName: 'Prof. Michael Chen',
                    startDate: new Date(
                        Date.now() + 3 * 24 * 60 * 60 * 1000,
                    ).toISOString(), // 3 days from now
                    endDate: new Date(
                        Date.now() + 90 * 24 * 60 * 60 * 1000,
                    ).toISOString(), // 90 days from now
                } as CourseEnrollmentTemplateData;

            case EmailType.SYSTEM_ALERT:
                return {
                    ...baseData,
                    alertType: 'info' as const,
                    alertTitle: 'Scheduled Maintenance Notice',
                    alertMessage:
                        'We will be performing scheduled maintenance on our servers this Sunday from 2:00 AM to 4:00 AM EST. During this time, the platform may be temporarily unavailable.',
                    actionUrl: 'https://trainpro.com/status',
                    actionText: 'Check Status',
                    timestamp: new Date().toISOString(),
                } as SystemAlertTemplateData;

            case EmailType.CUSTOM:
            default:
                return {
                    ...baseData,
                    title: 'Important Update',
                    message:
                        'This is a sample custom email message for testing purposes.',
                } as CustomTemplateData;
        }
    }

    /**
     * Test a specific template with sample data
     */
    async testTemplate(type: EmailType): Promise<{
        success: boolean;
        html?: string;
        text?: string;
        subject?: string;
        error?: string;
    }> {
        try {
            const sampleData = this.generateSampleData(type);
            const result = await this.emailTemplateService.renderByType(
                type,
                sampleData,
            );

            this.logger.log(`Template test successful for type: ${type}`);
            return {
                success: true,
                html: result.html,
                text: result.text,
                subject: result.subject,
            };
        } catch (error) {
            this.logger.error(`Template test failed for type: ${type}`, error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error',
            };
        }
    }

    /**
     * Test all templates
     */
    async testAllTemplates(): Promise<
        Record<
            EmailType,
            {
                success: boolean;
                html?: string;
                text?: string;
                subject?: string;
                error?: string;
            }
        >
    > {
        const results: Record<string, any> = {};
        const emailTypes = Object.values(EmailType);

        for (const type of emailTypes) {
            results[type] = await this.testTemplate(type);
        }

        return results as Record<EmailType, any>;
    }

    /**
     * Validate template data against template requirements
     */
    validateTemplateData(
        type: EmailType,
        data: TemplateData,
    ): {
        isValid: boolean;
        errors: string[];
        warnings: string[];
    } {
        const result = this.emailTemplateService.validateTemplateData(
            type,
            data,
        );
        return {
            isValid: result.isValid,
            errors: result.errors,
            warnings: result.warnings || [],
        };
    }

    /**
     * Generate test report for all templates
     */
    async generateTestReport(): Promise<{
        summary: {
            total: number;
            passed: number;
            failed: number;
        };
        details: Record<
            EmailType,
            {
                status: 'passed' | 'failed';
                error?: string;
            }
        >;
    }> {
        const testResults = await this.testAllTemplates();

        let passed = 0;
        let failed = 0;
        const details: Record<string, any> = {};

        Object.entries(testResults).forEach(([type, result]) => {
            if (result.success) {
                passed++;
                details[type] = { status: 'passed' };
            } else {
                failed++;
                details[type] = { status: 'failed', error: result.error };
            }
        });

        return {
            summary: {
                total: Object.keys(testResults).length,
                passed,
                failed,
            },
            details: details as Record<EmailType, any>,
        };
    }

    /**
     * Validate all template configurations
     */
    validateAllTemplateConfigs(): {
        isValid: boolean;
        errors: string[];
        templateStatus: Record<string, boolean>;
    } {
        const configs = this.emailTemplateService.getAllTemplateConfigs();
        const errors: string[] = [];
        const templateStatus: Record<string, boolean> = {};

        configs.forEach(config => {
            try {
                // Basic validation
                if (!config.name) {
                    errors.push(`Template missing name: ${config.type}`);
                    templateStatus[config.type] = false;
                    return;
                }

                if (!config.htmlFile) {
                    errors.push(`Template missing HTML file: ${config.type}`);
                    templateStatus[config.type] = false;
                    return;
                }

                if (
                    !config.metadata.requiredData ||
                    config.metadata.requiredData.length === 0
                ) {
                    errors.push(
                        `Template missing required data specification: ${config.type}`,
                    );
                    templateStatus[config.type] = false;
                    return;
                }

                templateStatus[config.type] = true;
            } catch (error) {
                errors.push(
                    `Template validation error for ${config.type}: ${error instanceof Error ? error.message : 'Unknown error'}`,
                );
                templateStatus[config.type] = false;
            }
        });

        return {
            isValid: errors.length === 0,
            errors,
            templateStatus,
        };
    }

    /**
     * Get template preview data for development/testing
     */
    getTemplatePreviewData(): Record<EmailType, TemplateData> {
        const previewData: Record<string, any> = {};
        const emailTypes = Object.values(EmailType);

        emailTypes.forEach(type => {
            previewData[type] = this.generateSampleData(type);
        });

        return previewData as Record<EmailType, TemplateData>;
    }
}

/*
 * Class #56: CourseController
 * Source: course/course.controller.ts:57
 * Type: Exported Class
 * Methods: 16
 * Properties: 322
 * Decorators: 67
 * Complexity: 231
 * Size: 24272 characters (747 lines)
 */
export class CourseController {
    private readonly logger = new Logger(CourseController.name);

    constructor(private readonly courseService: CourseService) {}

    @Post()
    @HttpCode(HttpStatus.CREATED)
    @ApiOperation({
        summary: '🆕 Create New Course',
        description: `
      **Creates a new course with comprehensive validation and caching**
      
      This endpoint allows authenticated users to create new courses with:
      - Course title and description validation
      - Automatic creator assignment from JWT context
      - Organization/branch scope assignment
      - Comprehensive caching invalidation
      - Input validation and sanitization
      
      **Security Features:**
      - Requires valid JWT authentication
      - Organization/branch scope validation
      - Automatic creator ownership tracking
      - Input validation and sanitization
      
      **Business Rules:**
      - Course title must be at least 3 characters
      - Description is optional but recommended
      - Creator is automatically set from authenticated user
      - Course inherits organization/branch from user context
      
      **Use Cases:**
      - Creating new educational courses
      - Setting up exam structures
      - Organizing learning content
      - Building course catalogs
    `,
        operationId: 'createCourse',
    })
    @ApiBody({
        type: CreateCourseDto,
        description: 'Course creation data',
        examples: {
            'computer-science': {
                summary: '💻 Computer Science Course',
                description: 'Example of a comprehensive CS course',
                value: {
                    title: 'Introduction to Computer Science',
                    description:
                        'A comprehensive introduction to computer science fundamentals including programming, algorithms, data structures, and problem-solving techniques. Perfect for beginners with no prior experience.',
                },
            },
            mathematics: {
                summary: '📊 Mathematics Course',
                description: 'Example of a mathematics course',
                value: {
                    title: 'Calculus I - Differential Calculus',
                    description:
                        'First course in calculus covering limits, derivatives, and applications of differentiation.',
                },
            },
            minimal: {
                summary: '📝 Minimal Course',
                description: 'Minimal required fields only',
                value: {
                    title: 'Basic Programming Concepts',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description: '✅ Course created successfully',
        type: CourseCreatedResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data or validation errors',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    examples: [
                        'Course title must be at least 3 characters long',
                        'Course title is required',
                        'Course description must be a string',
                    ],
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 400 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ User not found',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'User with ID xxx not found',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 404 },
            },
        },
    })
    async create(
        @Body() createCourseDto: CreateCourseDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(
                `Creating course "${createCourseDto.title}" for user: ${scope.userId} in org: ${scope.orgId}, branch: ${scope.branchId}`,
            );

            return await this.courseService.create(createCourseDto, scope);
        } catch (error) {
            this.logger.error(
                `Error creating course for user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Get()
    @ApiOperation({
        summary: '📋 List All Courses',
        description: `
      **Retrieves a paginated list of courses with filtering and comprehensive caching**
      
      This endpoint provides comprehensive course discovery with:
      - Advanced pagination support for large datasets
      - Multiple filtering options (title, creator, date range)
      - Flexible sorting capabilities
      - Course statistics and metadata
      - Comprehensive caching for performance
      
      **Filtering Options:**
      - **Title**: Partial text search in course titles
      - **Creator**: Filter by specific user who created courses
      - **Date Range**: Filter by creation date (after/before)
      - **Sorting**: Sort by title, creation date, or update date
      - **Pagination**: Page-based navigation with configurable page size
      
      **Response Includes:**
      - Course basic information with creator details
      - Test count per course (cached)
      - Student enrollment count (cached)
      - Organization and branch information
      - Comprehensive pagination metadata
      
      **Performance Features:**
      - Intelligent caching at multiple levels
      - Optimized database queries with eager loading
      - Efficient count calculations
      - Cache invalidation on course changes
    `,
        operationId: 'getAllCourses',
    })
    @ApiQuery({
        name: 'title',
        required: false,
        description: 'Filter courses by title (partial match)',
        example: 'Computer Science',
    })
    @ApiQuery({
        name: 'createdBy',
        required: false,
        description: 'Filter courses by creator user ID',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    @ApiQuery({
        name: 'createdAfter',
        required: false,
        description: 'Filter courses created after this date',
        example: '2024-01-01',
    })
    @ApiQuery({
        name: 'createdBefore',
        required: false,
        description: 'Filter courses created before this date',
        example: '2024-12-31',
    })
    @ApiQuery({
        name: 'page',
        required: false,
        description: 'Page number for pagination',
        example: 1,
    })
    @ApiQuery({
        name: 'limit',
        required: false,
        description: 'Number of courses per page',
        example: 10,
    })
    @ApiQuery({
        name: 'sortBy',
        required: false,
        description: 'Sort field',
        example: 'createdAt',
        enum: ['title', 'createdAt', 'updatedAt'],
    })
    @ApiQuery({
        name: 'sortOrder',
        required: false,
        description: 'Sort order',
        example: 'DESC',
        enum: ['ASC', 'DESC'],
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Courses retrieved successfully',
        type: CourseListApiResponse,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async findAll(
        @Query() filters: CourseFilterDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardApiResponse> {
        try {
            this.logger.log(
                `Getting courses for user: ${scope.userId} with filters:`,
                JSON.stringify(filters),
            );

            const result = await this.courseService.findAll(filters, scope);

            return {
                success: true,
                message: 'Courses retrieved successfully',
                data: result,
                meta: {
                    timestamp: new Date().toISOString(),
                    pagination: {
                        page: result.page,
                        limit: result.limit,
                        total: result.total,
                        totalPages: result.totalPages,
                    },
                },
            };
        } catch (error) {
            this.logger.error(
                `Error getting courses for user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Get('my-courses')
    @ApiOperation({
        summary: '👤 Get My Created Courses',
        description: `
      **Retrieves courses created by the authenticated user with caching**
      
      This endpoint provides a filtered view of courses created by the current user:
      - Automatic filtering by creator (authenticated user)
      - Same filtering and pagination options as general course list
      - Comprehensive caching for performance
      - Creator-specific optimizations
      
      **Use Cases:**
      - User dashboard showing their courses
      - Course management interface
      - Creator analytics and insights
      - Personal course portfolio
    `,
        operationId: 'getMyCreatedCourses',
    })
    @ApiQuery({
        name: 'title',
        required: false,
        description: 'Filter your courses by title (partial match)',
        example: 'Computer Science',
    })
    @ApiQuery({
        name: 'createdAfter',
        required: false,
        description: 'Filter your courses created after this date',
        example: '2024-01-01',
    })
    @ApiQuery({
        name: 'createdBefore',
        required: false,
        description: 'Filter your courses created before this date',
        example: '2024-12-31',
    })
    @ApiQuery({
        name: 'page',
        required: false,
        description: 'Page number for pagination',
        example: 1,
    })
    @ApiQuery({
        name: 'limit',
        required: false,
        description: 'Number of courses per page',
        example: 10,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ User courses retrieved successfully',
        type: CourseListApiResponse,
    })
    async getMyCreatedCourses(
        @Query() filters: CourseFilterDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardApiResponse> {
        try {
            this.logger.log(`Getting courses created by user: ${scope.userId}`);

            const result = await this.courseService.findByCreator(
                scope.userId,
                filters,
                scope,
            );

            return {
                success: true,
                message: 'User courses retrieved successfully',
                data: result,
                meta: {
                    timestamp: new Date().toISOString(),
                    pagination: {
                        page: result.page,
                        limit: result.limit,
                        total: result.total,
                        totalPages: result.totalPages,
                    },
                },
            };
        } catch (error) {
            this.logger.error(
                `Error getting courses for user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Get(':id')
    @ApiOperation({
        summary: '🔍 Get Course Details',
        description: `
      **Retrieves detailed information about a specific course with caching**
      
      This endpoint provides comprehensive course details including:
      - Complete course information with creator details
      - Detailed statistics (test counts, attempts, scores)
      - Organization and branch information
      - Comprehensive caching for performance
      
      **Statistics Included:**
      - Total and active test counts
      - Student enrollment and attempt statistics
      - Average scores and pass rates
      - Recent activity timestamps
      
      **Use Cases:**
      - Course detail pages
      - Course analytics and reporting
      - Instructor dashboards
      - Course performance monitoring
    `,
        operationId: 'getCourseById',
    })
    @ApiParam({
        name: 'id',
        description: 'Course ID to retrieve',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course details retrieved successfully',
        type: CourseDetailApiResponse,
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course not found',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: false },
                message: {
                    type: 'string',
                    example: 'Course with ID 1 not found',
                },
                data: { type: 'null' },
            },
        },
    })
    async findOne(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardApiResponse> {
        try {
            this.logger.log(`Getting course ${id} for user: ${scope.userId}`);

            const course = await this.courseService.findOne(id, scope);

            if (!course) {
                return {
                    success: false,
                    message: `Course with ID ${id} not found`,
                    data: null,
                };
            }

            return {
                success: true,
                message: 'Course details retrieved successfully',
                data: course,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                `Error getting course ${id} for user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Get(':id/stats')
    @ApiOperation({
        summary: '📊 Get Course Statistics',
        description: `
      **Retrieves comprehensive statistics for a specific course with caching**
      
      This endpoint provides detailed analytics including:
      - Test and student counts with breakdowns
      - Performance metrics (average scores, pass rates)
      - Activity tracking (last attempt timestamps)
      - Comprehensive caching for performance
      
      **Statistics Included:**
      - **Test Metrics**: Total tests, active tests
      - **Student Metrics**: Unique students, total attempts
      - **Performance**: Average scores, pass rates
      - **Activity**: Last activity timestamps
      
      **Use Cases:**
      - Course analytics dashboards
      - Performance monitoring
      - Instructor insights
      - Administrative reporting
    `,
        operationId: 'getCourseStats',
    })
    @ApiParam({
        name: 'id',
        description: 'Course ID to get statistics for',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course statistics retrieved successfully',
        type: CourseStatsApiResponse,
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course not found',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: false },
                message: {
                    type: 'string',
                    example: 'Course with ID 1 not found',
                },
                data: { type: 'null' },
            },
        },
    })
    async getStats(
        @Param('id', ParseIntPipe) id: number,
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardApiResponse> {
        try {
            this.logger.log(
                `Getting stats for course ${id} by user: ${req.user.id}`,
            );

            const stats = await this.courseService.getStats(id);

            return {
                success: true,
                message: 'Course statistics retrieved successfully',
                data: stats,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                `Error getting stats for course ${id} by user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Put(':id')
    @ApiOperation({
        summary: '✏️ Update Course',
        description: `
      **Updates an existing course with validation and cache management**
      
      This endpoint allows course creators to update their courses:
      - Title and description modifications
      - Ownership validation (only creator can update)
      - Comprehensive cache invalidation
      - Input validation and sanitization
      
      **Security Features:**
      - Ownership validation (only creator can update)
      - Input validation and sanitization
      - Automatic cache invalidation
      
      **Use Cases:**
      - Course information updates
      - Content improvements
      - Course maintenance
      - Information corrections
    `,
        operationId: 'updateCourse',
    })
    @ApiParam({
        name: 'id',
        description: 'Course ID to update',
        example: 1,
    })
    @ApiBody({
        type: UpdateCourseDto,
        description: 'Course update data',
        examples: {
            'title-update': {
                summary: '📝 Update Title',
                description: 'Update course title only',
                value: {
                    title: 'Advanced Computer Science Concepts',
                },
            },
            'full-update': {
                summary: '🔄 Complete Update',
                description: 'Update both title and description',
                value: {
                    title: 'Advanced Computer Science Concepts',
                    description:
                        'An advanced course covering complex computer science topics including advanced algorithms, system design, and software architecture patterns.',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course updated successfully',
        type: CourseUpdatedResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data or validation errors',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    examples: [
                        'Course title must be at least 3 characters long',
                        'Course description must be a string',
                    ],
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 400 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '⛔ Forbidden - Not course creator',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'You are not authorized to modify this course',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 403 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course not found',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'Course with ID 1 not found',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 404 },
            },
        },
    })
    async update(
        @Param('id', ParseIntPipe) id: number,
        @Body() updateCourseDto: UpdateCourseDto,
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(`Updating course ${id} by user: ${req.user.id}`);

            return await this.courseService.update(
                id,
                updateCourseDto,
                req.user.id,
            );
        } catch (error) {
            this.logger.error(
                `Error updating course ${id} by user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Delete(':id')
    @ApiOperation({
        summary: '🗑️ Delete Course',
        description: `
      **Deletes a course with validation and cache management**
      
      This endpoint allows course creators to delete their courses:
      - Ownership validation (only creator can delete)
      - Test dependency checking (cannot delete course with tests)
      - Comprehensive cache invalidation
      - Safe deletion with validation
      
      **Security Features:**
      - Ownership validation (only creator can delete)
      - Dependency checking before deletion
      - Comprehensive cache invalidation
      
      **Business Rules:**
      - Cannot delete course that has tests
      - Only course creator can delete
      - Deletion is permanent and irreversible
      
      **Use Cases:**
      - Removing obsolete courses
      - Cleaning up test/draft courses
      - Course management maintenance
    `,
        operationId: 'deleteCourse',
    })
    @ApiParam({
        name: 'id',
        description: 'Course ID to delete',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course deleted successfully',
        type: CourseDeletedResponse,
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description:
            '⛔ Forbidden - Cannot delete course with tests or not creator',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    examples: [
                        'You are not authorized to modify this course',
                        'Cannot delete course that has tests',
                    ],
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 403 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course not found',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'Course with ID 1 not found',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 404 },
            },
        },
    })
    async remove(
        @Param('id', ParseIntPipe) id: number,
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(`Deleting course ${id} by user: ${req.user.id}`);

            return await this.courseService.remove(id, req.user.id);
        } catch (error) {
            this.logger.error(
                `Error deleting course ${id} by user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }
}

/*
 * Class #57: CourseModule
 * Source: course/course.module.ts:27
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 28 characters (1 lines)
 */
export class CourseModule {}

/*
 * Class #58: CourseService
 * Source: course/course.service.ts:33
 * Type: Exported Class
 * Methods: 51
 * Properties: 139
 * Decorators: 5
 * Complexity: 293
 * Size: 24530 characters (727 lines)
 */
export class CourseService {
    private readonly logger = new Logger(CourseService.name);

    // Cache keys with comprehensive coverage
    private readonly CACHE_KEYS = {
        COURSE_BY_ID: (id: number) => `course:${id}`,
        COURSES_BY_ORG: (orgId: string, filters: string) =>
            `courses:org:${orgId}:${filters}`,
        COURSES_BY_BRANCH: (branchId: string, filters: string) =>
            `courses:branch:${branchId}:${filters}`,
        COURSES_BY_CREATOR: (userId: string, filters: string) =>
            `courses:creator:${userId}:${filters}`,
        COURSE_STATS: (courseId: number) => `course:stats:${courseId}`,
        COURSE_LIST: (filters: string) => `courses:list:${filters}`,
        USER_COURSES: (userId: string) => `user:${userId}:courses`,
        ALL_COURSES: 'courses:all',
        COURSE_DETAIL: (id: number) => `course:detail:${id}`,
        COURSE_TESTS_COUNT: (courseId: number) =>
            `course:tests:count:${courseId}`,
        COURSE_STUDENTS_COUNT: (courseId: number) =>
            `course:students:count:${courseId}`,
    };

    // Cache TTL in seconds with different durations for different data types
    private readonly CACHE_TTL = {
        COURSE: 300, // 5 minutes
        COURSE_LIST: 180, // 3 minutes
        STATS: 600, // 10 minutes
        COUNTS: 120, // 2 minutes
        USER_DATA: 240, // 4 minutes
        ALL_COURSES: 900, // 15 minutes
        COURSE_DETAIL: 300, // 5 minutes
    };

    constructor(
        @InjectRepository(Course)
        private readonly courseRepository: Repository<Course>,
        @InjectRepository(Test)
        private readonly testRepository: Repository<Test>,
        @InjectRepository(TestAttempt)
        private readonly testAttemptRepository: Repository<TestAttempt>,
        @InjectRepository(Result)
        private readonly resultRepository: Repository<Result>,
        private readonly userService: UserService,
        private readonly orgBranchScopingService: OrgBranchScopingService,
        private readonly eventEmitter: EventEmitter2,
        @Inject(CACHE_MANAGER)
        private readonly cacheManager: Cache,
    ) {}

    private async retryOperation<T>(
        operation: () => Promise<T>,
        maxRetries = 3,
        delay = 1000,
    ): Promise<T> {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                const isConnectionError =
                    error instanceof Error &&
                    (error.message.includes('ECONNRESET') ||
                        error.message.includes('Connection lost') ||
                        error.message.includes('connect ETIMEDOUT'));

                if (isConnectionError && attempt < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                    continue;
                }
                throw error;
            }
        }
        throw new Error('Max retries exceeded');
    }

    /**
     * Cache helper methods
     */
    private async invalidateCourseCache(
        courseId: number,
        userId?: string,
    ): Promise<void> {
        const keysToDelete = [
            this.CACHE_KEYS.COURSE_BY_ID(courseId),
            this.CACHE_KEYS.COURSE_DETAIL(courseId),
            this.CACHE_KEYS.COURSE_STATS(courseId),
            this.CACHE_KEYS.COURSE_TESTS_COUNT(courseId),
            this.CACHE_KEYS.COURSE_STUDENTS_COUNT(courseId),
        ];

        if (userId) {
            keysToDelete.push(this.CACHE_KEYS.USER_COURSES(userId));
        }

        // Also invalidate general course lists
        keysToDelete.push(this.CACHE_KEYS.ALL_COURSES);

        await Promise.all(keysToDelete.map(key => this.cacheManager.del(key)));
    }

    private async invalidateCourseListCaches(): Promise<void> {
        // Note: This is a simplified approach. In production, you might want to
        // maintain a list of active org/branch cache keys or use cache tags
        // For now, we'll just clear specific pattern-based keys
        // await this.cacheManager.reset(); // This method might not exist in all cache implementations
    }

    private async invalidateUserCoursesCache(userId: string): Promise<void> {
        const keysToDelete = [
            this.CACHE_KEYS.USER_COURSES(userId),
            this.CACHE_KEYS.ALL_COURSES,
        ];

        await Promise.all(keysToDelete.map(key => this.cacheManager.del(key)));
    }

    private generateCacheKeyForCourses(
        filters?: CourseFilterDto,
        prefix: string = 'list',
    ): string {
        const filterKey = JSON.stringify({
            title: filters?.title,
            createdBy: filters?.createdBy,
            createdAfter: filters?.createdAfter,
            createdBefore: filters?.createdBefore,
            page: filters?.page,
            limit: filters?.limit,
            sortBy: filters?.sortBy,
            sortOrder: filters?.sortOrder,
        });
        return `${this.CACHE_KEYS.COURSE_LIST(filterKey)}:${prefix}`;
    }

    async create(
        createCourseDto: CreateCourseDto,
        scope: OrgBranchScope,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            // Validate user exists
            const user = await this.userService.findById(scope.userId);
            if (!user) {
                throw new NotFoundException(
                    `User with ID ${scope.userId} not found`,
                );
            }

            const course = this.courseRepository.create({
                ...createCourseDto,
                createdBy: scope.userId,
                orgId: scope.orgId ? { id: scope.orgId } : undefined,
                branchId: scope.branchId ? { id: scope.branchId } : undefined,
            });

            const savedCourse = await this.courseRepository.save(course);

            // Invalidate list caches since a new course was created
            await this.invalidateCourseListCaches();

            // Emit course created event
            this.eventEmitter.emit(
                'course.created',
                new CourseCreatedEvent(
                    savedCourse.courseId,
                    savedCourse.title,
                    savedCourse.description || '',
                    user.id,
                    user.email,
                    user.firstName,
                    user.lastName,
                    scope.orgId,
                    user.orgId?.name,
                    scope.branchId,
                    user.branchId?.name,
                ),
            );

            this.logger.log(
                `Course ${savedCourse.courseId} created successfully by user ${scope.userId}`,
            );

            return {
                message: 'Course created successfully',
                status: 'success',
                code: 201,
            };
        });
    }

    async findAll(
        filters: CourseFilterDto,
        scope?: OrgBranchScope,
    ): Promise<CourseListResponseDto> {
        return this.retryOperation(async () => {
            // Check cache first
            const cacheKey = this.generateCacheKeyForCourses(filters, 'all');

            const cachedResult =
                await this.cacheManager.get<CourseListResponseDto>(cacheKey);

            if (cachedResult) {
                return cachedResult;
            }

            const {
                title,
                createdBy,
                createdAfter,
                createdBefore,
                page = 1,
                limit = 10,
                sortBy = 'createdAt',
                sortOrder = 'DESC',
            } = filters;

            const query = this.courseRepository.createQueryBuilder('course');
            query.leftJoinAndSelect('course.creator', 'creator');
            query.leftJoinAndSelect('course.orgId', 'org');
            query.leftJoinAndSelect('course.branchId', 'branch');

            // Apply org/branch scoping
            if (scope?.orgId) {
                query.andWhere('course.orgId = :orgId', { orgId: scope.orgId });
            }
            if (scope?.branchId) {
                query.andWhere('course.branchId = :branchId', {
                    branchId: scope.branchId,
                });
            }

            // Apply filters
            if (title) {
                query.andWhere('course.title LIKE :title', {
                    title: `%${title}%`,
                });
            }

            if (createdBy) {
                query.andWhere('course.createdBy = :createdBy', {
                    createdBy,
                });
            }

            if (createdAfter) {
                query.andWhere('course.createdAt >= :createdAfter', {
                    createdAfter,
                });
            }

            if (createdBefore) {
                query.andWhere('course.createdAt <= :createdBefore', {
                    createdBefore,
                });
            }

            // Add sorting
            query.orderBy(`course.${sortBy}`, sortOrder);

            // Add pagination
            const skip = (page - 1) * limit;
            query.skip(skip).take(limit);

            const [courses, total] = await query.getManyAndCount();

            // Calculate actual test counts for each course with caching and map creator
            const coursesWithCounts = await Promise.all(
                courses.map(async course => {
                    const testCount = await this.getCachedTestCount(
                        course.courseId,
                    );
                    const studentCount = await this.getCachedStudentCount(
                        course.courseId,
                    );

                    // Map User entity to simplified CourseCreatorDto
                    const creatorDto: CourseCreatorDto | undefined =
                        course.creator
                            ? {
                                  id: course.creator.id,
                                  email: course.creator.email,
                                  firstName: course.creator.firstName,
                                  lastName: course.creator.lastName,
                                  role: course.creator.role,
                              }
                            : undefined;

                    return {
                        ...course,
                        creator: creatorDto,
                        testCount,
                        studentCount,
                    };
                }),
            );

            const result = {
                courses: coursesWithCounts,
                total,
                page,
                limit,
                totalPages: Math.ceil(total / limit),
            };

            // Cache the result
            await this.cacheManager.set(
                cacheKey,
                result,
                this.CACHE_TTL.COURSE_LIST * 1000,
            );

            return result;
        });
    }

    async findOne(
        id: number,
        scope?: OrgBranchScope,
    ): Promise<CourseDetailDto | null> {
        return this.retryOperation(async () => {
            // Check cache first
            const cacheKey = this.CACHE_KEYS.COURSE_DETAIL(id);

            const cachedCourse =
                await this.cacheManager.get<CourseDetailDto>(cacheKey);

            if (cachedCourse) {
                return cachedCourse;
            }

            const query = this.courseRepository.createQueryBuilder('course');
            query.leftJoinAndSelect('course.creator', 'creator');
            query.leftJoinAndSelect('course.orgId', 'org');
            query.leftJoinAndSelect('course.branchId', 'branch');
            query.leftJoinAndSelect(
                'course.courseMaterials',
                'courseMaterials',
            );
            query.where('course.courseId = :id', { id });

            // Apply org/branch scoping
            if (scope?.orgId) {
                query.andWhere('course.orgId = :orgId', { orgId: scope.orgId });
            }
            if (scope?.branchId) {
                query.andWhere('course.branchId = :branchId', {
                    branchId: scope.branchId,
                });
            }

            const course = await query.getOne();

            if (!course) {
                return null;
            }

            // Get statistics with caching
            const stats = await this.getStats(id);

            // Map User entity to simplified CourseCreatorDto to avoid complex nested structures
            const creatorDto: CourseCreatorDto | undefined = course.creator
                ? {
                      id: course.creator.id,
                      email: course.creator.email,
                      firstName: course.creator.firstName,
                      lastName: course.creator.lastName,
                      role: course.creator.role,
                  }
                : undefined;

            const result: CourseDetailDto = {
                ...course,
                creator: creatorDto,
                testCount: stats.totalTests,
                studentCount: stats.uniqueStudents,
                statistics: {
                    totalTests: stats.totalTests,
                    activeTests: stats.activeTests,
                    totalAttempts: stats.totalAttempts,
                    averageScore: stats.averageScore,
                },
            };

            // Cache the result
            await this.cacheManager.set(
                cacheKey,
                result,
                this.CACHE_TTL.COURSE_DETAIL * 1000,
            );

            return result;
        });
    }

    async findByCreator(
        userId: string,
        filters: Partial<CourseFilterDto>,
        scope?: OrgBranchScope,
    ): Promise<CourseListResponseDto> {
        const fullFilters = { ...filters, createdBy: userId };
        return this.findAll(fullFilters as CourseFilterDto, scope);
    }

    async update(
        id: number,
        updateCourseDto: UpdateCourseDto,
        userId: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            const course = await this.findById(id);
            if (!course) {
                throw new NotFoundException(`Course with ID ${id} not found`);
            }

            // Validate ownership
            await this.validateOwnership(id, userId);

            Object.assign(course, updateCourseDto);
            await this.courseRepository.save(course);

            // Invalidate course cache
            await this.invalidateCourseCache(id, userId);

            this.logger.log(
                `Course ${id} updated successfully by user ${userId}`,
            );

            return {
                message: 'Course updated successfully',
                status: 'success',
                code: 200,
            };
        });
    }

    async remove(
        id: number,
        userId: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            const course = await this.findById(id);
            if (!course) {
                throw new NotFoundException(`Course with ID ${id} not found`);
            }

            // Validate ownership
            await this.validateOwnership(id, userId);

            // Check if course has tests
            const testCount = await this.getCachedTestCount(id);
            if (testCount > 0) {
                throw new ForbiddenException(
                    'Cannot delete course that has tests',
                );
            }

            await this.courseRepository.remove(course);

            // Invalidate course cache
            await this.invalidateCourseCache(id, userId);
            await this.invalidateCourseListCaches();

            this.logger.log(
                `Course ${id} deleted successfully by user ${userId}`,
            );

            return {
                message: 'Course deleted successfully',
                status: 'success',
                code: 200,
            };
        });
    }

    async getStats(id: number): Promise<CourseStatsDto> {
        return this.retryOperation(async () => {
            // Check cache first
            const cacheKey = this.CACHE_KEYS.COURSE_STATS(id);

            const cachedStats =
                await this.cacheManager.get<CourseStatsDto>(cacheKey);

            if (cachedStats) {
                return cachedStats;
            }

            const course = await this.findById(id);
            if (!course) {
                throw new NotFoundException(`Course with ID ${id} not found`);
            }

            // Get tests for this course
            const tests = await this.testRepository.find({
                where: { courseId: id },
            });

            const totalTests = tests.length;
            const activeTests = tests.filter(test => test.isActive).length;

            let totalAttempts = 0;
            let uniqueStudents = 0;
            let averageScore = 0;
            let passRate = 0;
            let lastActivityAt: Date | undefined;

            if (totalTests > 0) {
                const testIds = tests.map(test => test.testId);

                // Get all attempts for these tests
                const attempts = await this.testAttemptRepository
                    .createQueryBuilder('attempt')
                    .where('attempt.testId IN (:...testIds)', { testIds })
                    .getMany();

                totalAttempts = attempts.length;

                if (totalAttempts > 0) {
                    // Count unique students
                    const uniqueUserIds = new Set(
                        attempts.map(attempt => attempt.userId),
                    );
                    uniqueStudents = uniqueUserIds.size;

                    // Get results for these attempts
                    const results = await this.resultRepository
                        .createQueryBuilder('result')
                        .innerJoin('result.testAttempt', 'attempt')
                        .where('attempt.testId IN (:...testIds)', { testIds })
                        .getMany();

                    if (results.length > 0) {
                        const totalScore = results.reduce(
                            (sum, result) => sum + result.score,
                            0,
                        );
                        averageScore = totalScore / results.length;

                        // Calculate pass rate (assuming 60% is passing)
                        const passedResults = results.filter(
                            result => result.score >= 60,
                        );
                        passRate =
                            (passedResults.length / results.length) * 100;
                    }

                    // Get last activity
                    const lastAttempt = attempts.sort(
                        (a, b) => b.createdAt.getTime() - a.createdAt.getTime(),
                    )[0];
                    lastActivityAt = lastAttempt?.createdAt;
                }
            }

            const result: CourseStatsDto = {
                courseId: id,
                totalTests,
                activeTests,
                totalAttempts,
                uniqueStudents,
                averageScore: Math.round(averageScore * 100) / 100,
                passRate: Math.round(passRate * 100) / 100,
                lastActivityAt,
            };

            // Cache the result
            await this.cacheManager.set(
                cacheKey,
                result,
                this.CACHE_TTL.STATS * 1000,
            );

            return result;
        });
    }

    async validateOwnership(courseId: number, userId: string): Promise<void> {
        const course = await this.findById(courseId);
        if (!course) {
            throw new NotFoundException(`Course with ID ${courseId} not found`);
        }

        if (course.createdBy !== userId) {
            throw new ForbiddenException(
                'You are not authorized to modify this course',
            );
        }
    }

    async findById(id: number): Promise<Course | null> {
        return this.retryOperation(async () => {
            // Check cache first
            const cacheKey = this.CACHE_KEYS.COURSE_BY_ID(id);

            const cachedCourse = await this.cacheManager.get<Course>(cacheKey);

            if (cachedCourse) {
                return cachedCourse;
            }

            const course = await this.courseRepository.findOne({
                where: { courseId: id },
                relations: ['creator', 'orgId', 'branchId', 'courseMaterials'],
            });

            if (course) {
                // Cache the result
                await this.cacheManager.set(
                    cacheKey,
                    course,
                    this.CACHE_TTL.COURSE * 1000, // Convert to milliseconds
                );
            }

            return course;
        });
    }

    async exists(id: number): Promise<boolean> {
        const course = await this.findById(id);
        return !!course;
    }

    async findByOrganization(orgId: string): Promise<Course[]> {
        return this.retryOperation(async () => {
            return this.courseRepository.find({
                where: { orgId: { id: orgId } },
                relations: ['creator', 'orgId', 'branchId'],
            });
        });
    }

    async findByBranch(branchId: string): Promise<Course[]> {
        return this.retryOperation(async () => {
            return this.courseRepository.find({
                where: { branchId: { id: branchId } },
                relations: ['creator', 'orgId', 'branchId'],
            });
        });
    }

    // Helper methods for cached counts
    private async getCachedTestCount(courseId: number): Promise<number> {
        const cacheKey = this.CACHE_KEYS.COURSE_TESTS_COUNT(courseId);

        const cachedCount = await this.cacheManager.get<number>(cacheKey);
        if (cachedCount !== undefined && cachedCount !== null) {
            return cachedCount;
        }

        const count = await this.testRepository.count({
            where: { courseId },
        });

        await this.cacheManager.set(
            cacheKey,
            count,
            this.CACHE_TTL.COUNTS * 1000,
        );

        return count;
    }

    private async getCachedStudentCount(courseId: number): Promise<number> {
        const cacheKey = this.CACHE_KEYS.COURSE_STUDENTS_COUNT(courseId);

        const cachedCount = await this.cacheManager.get<number>(cacheKey);
        if (cachedCount !== undefined && cachedCount !== null) {
            return cachedCount;
        }

        const count = await this.testAttemptRepository
            .createQueryBuilder('attempt')
            .innerJoin('attempt.test', 'test')
            .where('test.courseId = :courseId', { courseId })
            .select('COUNT(DISTINCT attempt.userId)', 'count')
            .getRawOne()
            .then((result: { count: string }) => parseInt(result.count) || 0);

        await this.cacheManager.set(
            cacheKey,
            count,
            this.CACHE_TTL.COUNTS * 1000,
        );

        return count;
    }

    // Legacy methods with deprecation notice - keeping for backward compatibility
    async findAllScoped(
        filters: CourseFilterDto,
        orgId?: string,
        branchId?: string,
    ): Promise<CourseListResponseDto> {
        const scope: OrgBranchScope = {
            userId: '',
            orgId,
            branchId,
        };
        return this.findAll(filters, scope);
    }

    async findOneScoped(
        id: number,
        orgId?: string,
        branchId?: string,
    ): Promise<CourseDetailDto | null> {
        const scope: OrgBranchScope = {
            userId: '',
            orgId,
            branchId,
        };
        return this.findOne(id, scope);
    }

    async createScoped(
        createCourseDto: CreateCourseDto,
        userId: string,
        orgId?: string,
        branchId?: string,
    ): Promise<StandardOperationResponse> {
        const scope: OrgBranchScope = {
            userId,
            orgId,
            branchId,
        };
        return this.create(createCourseDto, scope);
    }
}

/*
 * Class #59: CourseFilterDto
 * Source: course/dto/course-filter.dto.ts:11
 * Type: Exported Class
 * Methods: 0
 * Properties: 20
 * Decorators: 28
 * Complexity: 69
 * Size: 1885 characters (82 lines)
 */
export class CourseFilterDto {
    @ApiProperty({
        description: 'Filter courses by title (partial match)',
        example: 'Computer Science',
        required: false,
    })
    @IsOptional()
    @IsString()
    title?: string;

    @ApiProperty({
        description: 'Filter courses by creator user ID',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
        required: false,
    })
    @IsOptional()
    @IsString()
    createdBy?: string;

    @ApiProperty({
        description: 'Filter courses created after this date',
        example: '2024-01-01',
        required: false,
    })
    @IsOptional()
    @IsDateString()
    createdAfter?: string;

    @ApiProperty({
        description: 'Filter courses created before this date',
        example: '2024-12-31',
        required: false,
    })
    @IsOptional()
    @IsDateString()
    createdBefore?: string;

    @ApiProperty({
        description: 'Page number for pagination',
        example: 1,
        required: false,
        minimum: 1,
    })
    @IsOptional()
    @Transform(({ value }) => parseInt(value))
    @IsNumber()
    @Min(1)
    page?: number = 1;

    @ApiProperty({
        description: 'Number of courses per page',
        example: 10,
        required: false,
        minimum: 1,
        maximum: 100,
    })
    @IsOptional()
    @Transform(({ value }) => parseInt(value))
    @IsNumber()
    @Min(1)
    limit?: number = 10;

    @ApiProperty({
        description: 'Sort field',
        example: 'createdAt',
        required: false,
        enum: ['title', 'createdAt', 'updatedAt'],
    })
    @IsOptional()
    @IsString()
    sortBy?: string = 'createdAt';

    @ApiProperty({
        description: 'Sort order',
        example: 'DESC',
        required: false,
        enum: ['ASC', 'DESC'],
    })
    @IsOptional()
    @IsString()
    sortOrder?: 'ASC' | 'DESC' = 'DESC';
}

/*
 * Class #60: CourseCreatorDto
 * Source: course/dto/course-response.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 5
 * Complexity: 13
 * Size: 682 characters (32 lines)
 */
export class CourseCreatorDto {
    @ApiProperty({
        description: 'Creator unique identifier',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    id: string;

    @ApiProperty({
        description: 'Creator email address',
        example: 'john.doe@example.com',
    })
    email: string;

    @ApiProperty({
        description: 'Creator first name',
        example: 'John',
    })
    firstName: string;

    @ApiProperty({
        description: 'Creator last name',
        example: 'Doe',
    })
    lastName: string;

    @ApiProperty({
        description: 'Creator role',
        example: 'admin',
        required: false,
    })
    role?: string;
}

/*
 * Class #61: CourseResponseDto
 * Source: course/dto/course-response.dto.ts:37
 * Type: Exported Class
 * Methods: 0
 * Properties: 12
 * Decorators: 9
 * Complexity: 24
 * Size: 1465 characters (60 lines)
 */
export class CourseResponseDto {
    @ApiProperty({
        description: 'Course unique identifier',
        example: 1,
    })
    courseId: number;

    @ApiProperty({
        description: 'Course title',
        example: 'Introduction to Computer Science',
    })
    title: string;

    @ApiProperty({
        description: 'Course description',
        example:
            'A comprehensive introduction to computer science fundamentals',
        required: false,
    })
    description?: string;

    @ApiProperty({
        description: 'ID of the user who created this course',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    createdBy: string;

    @ApiProperty({
        description: 'Course creation timestamp',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @ApiProperty({
        description: 'Course last update timestamp',
        example: '2024-01-15T10:30:45.123Z',
    })
    updatedAt: Date;

    @ApiProperty({
        description: 'Course creator information (simplified)',
        type: () => CourseCreatorDto,
        required: false,
    })
    creator?: CourseCreatorDto;

    @ApiProperty({
        description: 'Number of tests in this course',
        example: 5,
        required: false,
    })
    testCount?: number;

    @ApiProperty({
        description: 'Number of students enrolled in this course',
        example: 23,
        required: false,
    })
    studentCount?: number;
}

/*
 * Class #62: CourseListResponseDto
 * Source: course/dto/course-response.dto.ts:98
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 5
 * Complexity: 11
 * Size: 634 characters (31 lines)
 */
export class CourseListResponseDto {
    @ApiProperty({
        description: 'List of courses',
        type: [CourseResponseDto],
    })
    courses: CourseResponseDto[];

    @ApiProperty({
        description: 'Total number of courses',
        example: 100,
    })
    total: number;

    @ApiProperty({
        description: 'Current page number',
        example: 1,
    })
    page: number;

    @ApiProperty({
        description: 'Number of courses per page',
        example: 10,
    })
    limit: number;

    @ApiProperty({
        description: 'Total number of pages',
        example: 10,
    })
    totalPages: number;
}

/*
 * Class #63: CourseDetailDto
 * Source: course/dto/course-response.dto.ts:130
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 1
 * Complexity: 5
 * Size: 571 characters (18 lines)
 * Extends: CourseResponseDto
 */
export class CourseDetailDto extends CourseResponseDto {
    @ApiProperty({
        description: 'Detailed course statistics',
        type: 'object',
        properties: {
            totalTests: { type: 'number', example: 5 },
            activeTests: { type: 'number', example: 3 },
            totalAttempts: { type: 'number', example: 127 },
            averageScore: { type: 'number', example: 85.6 },
        },
    })
    statistics?: {
        totalTests: number;
        activeTests: number;
        totalAttempts: number;
        averageScore: number;
    };
}

/*
 * Class #64: CourseStatsDto
 * Source: course/dto/course-response.dto.ts:149
 * Type: Exported Class
 * Methods: 0
 * Properties: 8
 * Decorators: 8
 * Complexity: 18
 * Size: 1130 characters (50 lines)
 */
export class CourseStatsDto {
    @ApiProperty({
        description: 'Course unique identifier',
        example: 1,
    })
    courseId: number;

    @ApiProperty({
        description: 'Total number of tests in the course',
        example: 8,
    })
    totalTests: number;

    @ApiProperty({
        description: 'Number of active tests',
        example: 5,
    })
    activeTests: number;

    @ApiProperty({
        description: 'Total number of test attempts across all tests',
        example: 245,
    })
    totalAttempts: number;

    @ApiProperty({
        description: 'Number of unique students who attempted tests',
        example: 34,
    })
    uniqueStudents: number;

    @ApiProperty({
        description: 'Average score across all test attempts',
        example: 78.5,
    })
    averageScore: number;

    @ApiProperty({
        description: 'Pass rate percentage',
        example: 72.3,
    })
    passRate: number;

    @ApiProperty({
        description: 'Most recent test attempt timestamp',
        example: '2024-01-15T10:30:45.123Z',
        required: false,
    })
    lastActivityAt?: Date;
}

/*
 * Class #65: StandardApiResponse
 * Source: course/dto/course-response.dto.ts:201
 * Type: Exported Class
 * Methods: 0
 * Properties: 11
 * Decorators: 4
 * Complexity: 15
 * Size: 810 characters (34 lines)
 */
export class StandardApiResponse<T = unknown> {
    @ApiProperty({
        description: 'Indicates if the operation was successful',
        example: true,
    })
    success: boolean;

    @ApiProperty({
        description: 'Human-readable message about the operation result',
        example: 'Operation completed successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Response data payload',
        required: false,
    })
    data?: T;

    @ApiProperty({
        description: 'Additional metadata about the response',
        required: false,
    })
    meta?: {
        timestamp?: string;
        requestId?: string;
        pagination?: {
            page: number;
            limit: number;
            total: number;
            totalPages: number;
        };
    };
}

/*
 * Class #66: StandardOperationResponse
 * Source: course/dto/course-response.dto.ts:236
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 7
 * Size: 509 characters (20 lines)
 */
export class StandardOperationResponse {
    @ApiProperty({
        description: 'Human-readable message about the operation result',
        example: 'Course created successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status indicator',
        example: 'success',
        enum: ['success', 'error', 'warning', 'info', 'debug'],
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #67: CourseApiResponse
 * Source: course/dto/course-response.dto.ts:257
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 1
 * Complexity: 4
 * Size: 228 characters (7 lines)
 * Extends: StandardApiResponse<CourseResponseDto>
 */
export class CourseApiResponse extends StandardApiResponse<CourseResponseDto> {
    @ApiProperty({
        description: 'Course data retrieved successfully',
        type: CourseResponseDto,
    })
    data: CourseResponseDto;
}

/*
 * Class #68: CourseListApiResponse
 * Source: course/dto/course-response.dto.ts:265
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 1
 * Complexity: 4
 * Size: 243 characters (7 lines)
 * Extends: StandardApiResponse<CourseListResponseDto>
 */
export class CourseListApiResponse extends StandardApiResponse<CourseListResponseDto> {
    @ApiProperty({
        description: 'Courses list data with pagination',
        type: CourseListResponseDto,
    })
    data: CourseListResponseDto;
}

/*
 * Class #69: CourseDetailApiResponse
 * Source: course/dto/course-response.dto.ts:273
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 1
 * Complexity: 4
 * Size: 231 characters (7 lines)
 * Extends: StandardApiResponse<CourseDetailDto>
 */
export class CourseDetailApiResponse extends StandardApiResponse<CourseDetailDto> {
    @ApiProperty({
        description: 'Course details retrieved successfully',
        type: CourseDetailDto,
    })
    data: CourseDetailDto;
}

/*
 * Class #70: CourseStatsApiResponse
 * Source: course/dto/course-response.dto.ts:281
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 1
 * Complexity: 4
 * Size: 230 characters (7 lines)
 * Extends: StandardApiResponse<CourseStatsDto>
 */
export class CourseStatsApiResponse extends StandardApiResponse<CourseStatsDto> {
    @ApiProperty({
        description: 'Course statistics retrieved successfully',
        type: CourseStatsDto,
    })
    data: CourseStatsDto;
}

/*
 * Class #71: CourseCreatedResponse
 * Source: course/dto/course-response.dto.ts:290
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 447 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class CourseCreatedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: 'Course creation success message',
        example: 'Course created successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 201,
    })
    code: number;
}

/*
 * Class #72: CourseUpdatedResponse
 * Source: course/dto/course-response.dto.ts:310
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 445 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class CourseUpdatedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: 'Course update success message',
        example: 'Course updated successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #73: CourseDeletedResponse
 * Source: course/dto/course-response.dto.ts:330
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 447 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class CourseDeletedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: 'Course deletion success message',
        example: 'Course deleted successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #74: CreateCourseDto
 * Source: course/dto/create-course.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 2
 * Decorators: 7
 * Complexity: 18
 * Size: 1117 characters (30 lines)
 */
export class CreateCourseDto {
    @ApiProperty({
        description: 'Course title - clear and descriptive name for the course',
        example: 'Introduction to Computer Science',
        type: String,
        title: 'Course Title',
        minLength: 3,
        maxLength: 200,
    })
    @IsString({ message: 'Course title must be a string' })
    @IsNotEmpty({ message: 'Course title is required' })
    @MinLength(3, {
        message: 'Course title must be at least 3 characters long',
    })
    title: string;

    @ApiProperty({
        description:
            'Detailed description of the course content, objectives, and prerequisites',
        example:
            'A comprehensive introduction to computer science fundamentals including programming, algorithms, data structures, and problem-solving techniques. Suitable for beginners with no prior programming experience.',
        required: false,
        type: String,
        title: 'Course Description',
        maxLength: 5000,
    })
    @IsOptional()
    @IsString({ message: 'Course description must be a string' })
    description?: string;
}

/*
 * Class #75: UpdateCourseDto
 * Source: course/dto/update-course.dto.ts:6
 * Type: Exported Class
 * Methods: 1
 * Properties: 2
 * Decorators: 7
 * Complexity: 19
 * Size: 983 characters (30 lines)
 * Extends: PartialType(CreateCourseDto)
 */
export class UpdateCourseDto extends PartialType(CreateCourseDto) {
    @ApiProperty({
        description: 'Updated course title',
        example: 'Advanced Computer Science Concepts',
        required: false,
        type: String,
        title: 'Course Title',
        minLength: 3,
        maxLength: 200,
    })
    @IsOptional()
    @IsString({ message: 'Course title must be a string' })
    @MinLength(3, {
        message: 'Course title must be at least 3 characters long',
    })
    title?: string;

    @ApiProperty({
        description: 'Updated course description',
        example:
            'An advanced course covering complex computer science topics including advanced algorithms, system design, and software architecture patterns.',
        required: false,
        type: String,
        title: 'Course Description',
        maxLength: 5000,
    })
    @IsOptional()
    @IsString({ message: 'Course description must be a string' })
    description?: string;
}

/*
 * Class #76: Course
 * Source: course/entities/course.entity.ts:23
 * Type: Exported Class
 * Methods: 1
 * Properties: 23
 * Decorators: 29
 * Complexity: 63
 * Size: 2253 characters (90 lines)
 */
export class Course {
    @PrimaryGeneratedColumn()
    @ApiProperty({
        description: 'Course unique identifier',
        example: 1,
    })
    courseId: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Course title',
        example: 'Introduction to Computer Science',
    })
    @IsString()
    @IsNotEmpty()
    title: string;

    @Column('text', { nullable: true })
    @ApiProperty({
        description: 'Course description',
        example:
            'A comprehensive introduction to computer science fundamentals',
        required: false,
    })
    @IsString()
    @IsOptional()
    description?: string;

    @Column()
    @ApiProperty({
        description: 'ID of the user who created this course',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    @IsString()
    @IsNotEmpty()
    createdBy: string;

    @CreateDateColumn()
    @ApiProperty({
        description: 'Course creation timestamp',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @UpdateDateColumn()
    @ApiProperty({
        description: 'Course last update timestamp',
        example: '2024-01-15T10:30:45.123Z',
    })
    updatedAt: Date;

    @ManyToOne(() => Organization, { nullable: false })
    @ApiProperty({
        description: 'Organization this course belongs to',
        type: () => Organization,
    })
    orgId: Organization;

    @ManyToOne(() => Branch, { nullable: true })
    @ApiProperty({
        description: 'Branch this course belongs to',
        type: () => Branch,
        required: false,
    })
    branchId?: Branch;

    // Relations
    @ManyToOne(() => User, { onDelete: 'RESTRICT' })
    creator: User;

    @OneToMany(() => Test, 'course')
    tests: Test[];

    @OneToMany(() => Result, result => result.course)
    results: Result[];

    @OneToMany(() => Leaderboard, leaderboard => leaderboard.course)
    leaderboards: Leaderboard[];

    @OneToMany(() => TrainingProgress, progress => progress.course)
    trainingProgress: TrainingProgress[];

    @OneToMany(() => CourseMaterial, material => material.course)
    courseMaterials: CourseMaterial[];

    constructor(partial: Partial<Course>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #77: CourseMaterialsController
 * Source: course-materials/course-materials.controller.ts:55
 * Type: Exported Class
 * Methods: 15
 * Properties: 440
 * Decorators: 75
 * Complexity: 250
 * Size: 35139 characters (1020 lines)
 */
export class CourseMaterialsController {
    private readonly logger = new Logger(CourseMaterialsController.name);

    constructor(
        private readonly courseMaterialsService: CourseMaterialsService,
    ) {}

    @Post()
    @HttpCode(HttpStatus.CREATED)
    @ApiOperation({
        summary: '📝 Create New Course Material',
        description: `
      **Creates a new course material with comprehensive validation and caching**
      
      This endpoint allows authenticated users to create new course materials with:
      - Material title and URL validation
      - Multiple material type support (PDF, Video, Document, etc.)
      - Automatic creator assignment from JWT context
      - Organization/branch scope validation
      - Comprehensive caching invalidation
      - Input validation and sanitization
      - Sort order management
      
      **Security Features:**
      - Requires valid JWT authentication
      - Organization/branch scope validation
      - Automatic creator ownership tracking
      - Input validation and sanitization
      - Course access validation
      
      **Business Rules:**
      - Material title must be at least 3 characters
      - URL must be valid and accessible
      - Creator must have access to the target course
      - Sort order is automatically assigned if not provided
      - Material inherits organization/branch from course context
      
      **Material Types Supported:**
      - 📄 PDF Documents
      - 🎥 Video Content
      - 📊 Presentations
      - 🔗 External Links
      - 📋 Text Documents
      - 🎨 Images
      
      **Use Cases:**
      - Adding reading materials to courses
      - Uploading video lectures
      - Linking external resources
      - Organizing learning content
      - Building resource libraries
    `,
        operationId: 'createCourseMaterial',
    })
    @ApiBody({
        type: CreateCourseMaterialDto,
        description: 'Course material creation data',
        examples: {
            'pdf-document': {
                summary: '📄 PDF Learning Material',
                description: 'Example of a PDF document material',
                value: {
                    title: 'Introduction to Data Structures - Chapter 1',
                    description:
                        'Comprehensive guide to fundamental data structures including arrays, linked lists, stacks, and queues. Essential reading for computer science students.',
                    url: 'https://storage.example.com/courses/cs101/chapter1-data-structures.pdf',
                    type: 'PDF',
                    courseId: 1,
                    sortOrder: 1,
                    isActive: true,
                },
            },
            'video-lecture': {
                summary: '🎥 Video Lecture',
                description: 'Example of a video lecture material',
                value: {
                    title: 'Binary Search Algorithm Explained',
                    description:
                        'Step-by-step video explanation of binary search algorithm with visual examples and code implementation.',
                    url: 'https://videos.example.com/algorithms/binary-search-tutorial.mp4',
                    type: 'VIDEO',
                    courseId: 1,
                    sortOrder: 2,
                    isActive: true,
                },
            },
            'external-link': {
                summary: '🔗 External Resource',
                description: 'Example of an external link material',
                value: {
                    title: 'Interactive Algorithm Visualizer',
                    description:
                        'External tool for visualizing sorting and searching algorithms with interactive examples.',
                    url: 'https://algorithm-visualizer.org',
                    type: 'LINK',
                    courseId: 1,
                    sortOrder: 3,
                    isActive: true,
                },
            },
            minimal: {
                summary: '📝 Minimal Material',
                description: 'Minimal required fields only',
                value: {
                    title: 'Quick Reference Guide',
                    url: 'https://docs.example.com/quick-ref.html',
                    type: 'LINK',
                    courseId: 1,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description: '✅ Course material created successfully',
        type: CourseMaterialCreatedResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data or validation errors',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    examples: [
                        'Material title must be at least 3 characters long',
                        'Material title is required',
                        'Invalid URL format',
                        'Course ID is required',
                        'Material type must be valid',
                    ],
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 400 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description:
            '🔒 Forbidden - Insufficient permissions to create material for this course',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example:
                        'Access denied - You do not have permission to create materials for this course',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 403 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course or user not found',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    examples: [
                        'Course with ID xxx not found',
                        'User not found',
                    ],
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 404 },
            },
        },
    })
    async create(
        @Body() createCourseMaterialDto: CreateCourseMaterialDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(
                `Creating course material "${createCourseMaterialDto.title}" for course ${createCourseMaterialDto.courseId} by user: ${scope.userId}`,
            );

            return await this.courseMaterialsService.create(
                createCourseMaterialDto,
                {
                    orgId: scope.orgId,
                    branchId: scope.branchId,
                },
            );
        } catch (error) {
            this.logger.error(
                `Error creating course material for user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Get('course/:courseId')
    @ApiOperation({
        summary: '📋 Get All Materials for Course',
        description: `
      **Retrieves all course materials for a specific course with advanced filtering**
      
      This endpoint provides comprehensive access to course materials with:
      - Advanced filtering and sorting options
      - Optional inclusion of inactive materials
      - Detailed material metadata
      - Course context information
      - Creator and relationship data
      - Performance optimized queries
      
      **Filtering Options:**
      - Active/Inactive status filtering
      - Material type filtering
      - Date range filtering
      - Search by title/description
      
      **Sorting Options:**
      - Sort by title (alphabetical)
      - Sort by creation date
      - Sort by custom sort order
      - Ascending/Descending order
      
      **Security Features:**
      - Organization/branch scope validation
      - User access verification
      - Course permission checking
      
      **Use Cases:**
      - Displaying course content to students
      - Managing course materials for instructors
      - Building course navigation interfaces
      - Generating material reports
    `,
        operationId: 'getCourseMaterials',
    })
    @ApiParam({
        name: 'courseId',
        description: '🎯 Course ID to retrieve materials for',
        type: 'number',
        example: 1,
    })
    @ApiQuery({
        name: 'includeInactive',
        description:
            '👁️ Include inactive materials in the response (default: false)',
        required: false,
        type: 'boolean',
        example: false,
    })
    @ApiQuery({
        name: 'sortBy',
        description: '📊 Field to sort materials by',
        required: false,
        enum: ['title', 'createdAt', 'sortOrder'],
        example: 'sortOrder',
    })
    @ApiQuery({
        name: 'sortOrder',
        description: '🔄 Sort order direction',
        required: false,
        enum: ['ASC', 'DESC'],
        example: 'ASC',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course materials retrieved successfully',
        type: CourseMaterialListApiResponse,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description:
            '🔒 Forbidden - Insufficient permissions to access course materials',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example:
                        'Access denied - You do not have permission to view materials for this course',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 403 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course not found',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'Course with ID xxx not found',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 404 },
            },
        },
    })
    async findByCourse(
        @Param('courseId', ParseIntPipe) courseId: number,
        @OrgBranchScope() scope: OrgBranchScope,
        @Query('includeInactive') includeInactive?: boolean,
        @Query('sortBy') sortBy?: 'title' | 'createdAt' | 'sortOrder',
        @Query('sortOrder') sortOrder?: 'ASC' | 'DESC',
    ): Promise<CourseMaterialListApiResponse> {
        try {
            this.logger.log(
                `Retrieving materials for course ${courseId} by user: ${scope.userId}`,
            );

            return await this.courseMaterialsService.findByCourse(
                courseId,
                { orgId: scope.orgId, branchId: scope.branchId },
                scope.userId,
                { includeInactive, sortBy, sortOrder },
            );
        } catch (error) {
            this.logger.error(
                `Error retrieving materials for course ${courseId}:`,
                error,
            );
            throw error;
        }
    }

    @Get(':id')
    @ApiOperation({
        summary: '🔍 Get Course Material Details',
        description: `
      **Retrieves detailed information for a specific course material**
      
      This endpoint provides comprehensive material details including:
      - Complete material metadata
      - Course context and relationship data
      - Creator information and permissions
      - Access statistics and usage data
      - File metadata and download information
      - Related materials suggestions
      
      **Returned Information:**
      - Material title, description, and URL
      - File type, size, and format details
      - Creation and modification timestamps
      - Creator and updater information
      - Course association data
      - Access permissions and restrictions
      
      **Security Features:**
      - Organization/branch scope validation
      - User access verification
      - Material permission checking
      - Activity logging and audit trail
      
      **Use Cases:**
      - Displaying material details to students
      - Material management for instructors
      - Generating access reports
      - Building material preview interfaces
      - Content validation workflows
    `,
        operationId: 'getCourseMaterialById',
    })
    @ApiParam({
        name: 'id',
        description: '🎯 Course material unique identifier',
        type: 'number',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course material retrieved successfully',
        type: CourseMaterialApiResponse,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description:
            '🔒 Forbidden - Insufficient permissions to access this material',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example:
                        'Access denied - You do not have permission to view this material',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 403 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course material not found',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'Course material with ID xxx not found',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 404 },
            },
        },
    })
    async findOne(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<CourseMaterialResponseDto> {
        try {
            this.logger.log(
                `Retrieving course material ${id} for user: ${scope.userId}`,
            );

            return await this.courseMaterialsService.findOne(
                id,
                { orgId: scope.orgId, branchId: scope.branchId },
                scope.userId,
            );
        } catch (error) {
            this.logger.error(`Error retrieving course material ${id}:`, error);
            throw error;
        }
    }

    @Patch(':id')
    @ApiOperation({
        summary: '✏️ Update Course Material',
        description: `
      **Updates an existing course material with comprehensive validation**
      
      This endpoint allows authorized users to update course materials with:
      - Selective field updates (partial updates supported)
      - Comprehensive validation and sanitization
      - Version control and audit tracking
      - Automatic timestamp management
      - Permission-based access control
      - Cache invalidation and optimization
      
      **Updatable Fields:**
      - Material title and description
      - URL and file references
      - Material type and format
      - Sort order and positioning
      - Active/inactive status
      - Custom metadata fields
      
      **Security Features:**
      - Creator or admin permission required
      - Organization/branch scope validation
      - Input validation and sanitization
      - Change audit logging
      - Rollback capability support
      
      **Business Rules:**
      - Only material creator or course admin can update
      - Title must remain at least 3 characters
      - URL changes require validation
      - Sort order conflicts are auto-resolved
      - Status changes affect student visibility
      
      **Use Cases:**
      - Updating material content and links
      - Reorganizing course material order
      - Correcting material information
      - Managing material visibility
      - Maintaining content freshness
    `,
        operationId: 'updateCourseMaterial',
    })
    @ApiParam({
        name: 'id',
        description: '🎯 Course material unique identifier to update',
        type: 'number',
        example: 1,
    })
    @ApiBody({
        type: UpdateCourseMaterialDto,
        description: 'Course material update data (partial updates supported)',
        examples: {
            'title-update': {
                summary: '📝 Update Title and Description',
                description:
                    'Example of updating material title and description',
                value: {
                    title: 'Advanced Data Structures - Chapter 1 (Updated)',
                    description:
                        'Comprehensive guide to advanced data structures including trees, graphs, and hash tables. Updated with new examples and exercises.',
                },
            },
            'url-update': {
                summary: '🔗 Update Material URL',
                description: 'Example of updating material URL',
                value: {
                    url: 'https://storage.example.com/courses/cs101/updated-chapter1.pdf',
                },
            },
            reorder: {
                summary: '🔄 Reorder Material',
                description: 'Example of changing material sort order',
                value: {
                    sortOrder: 5,
                },
            },
            deactivate: {
                summary: '⏸️ Deactivate Material',
                description: 'Example of deactivating a material',
                value: {
                    isActive: false,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course material updated successfully',
        type: CourseMaterialUpdatedResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data or validation errors',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    examples: [
                        'Material title must be at least 3 characters long',
                        'Invalid URL format',
                        'Sort order must be a positive number',
                    ],
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 400 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description:
            '🔒 Forbidden - Insufficient permissions to update this material',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example:
                        'Access denied - You do not have permission to update this material',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 403 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course material not found',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'Course material with ID xxx not found',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 404 },
            },
        },
    })
    async update(
        @Param('id', ParseIntPipe) id: number,
        @Body() updateCourseMaterialDto: UpdateCourseMaterialDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(
                `Updating course material ${id} by user: ${scope.userId}`,
            );

            return await this.courseMaterialsService.update(
                id,
                updateCourseMaterialDto,
                { orgId: scope.orgId, branchId: scope.branchId },
                scope.userId,
            );
        } catch (error) {
            this.logger.error(`Error updating course material ${id}:`, error);
            throw error;
        }
    }

    @Delete(':id')
    @ApiOperation({
        summary: '🗑️ Delete Course Material',
        description: `
      **Permanently deletes a course material with comprehensive validation**
      
      This endpoint allows authorized users to delete course materials with:
      - Comprehensive permission validation
      - Cascade deletion handling
      - Audit trail and logging
      - Student access impact assessment
      - Soft delete option support
      - Recovery mechanism availability
      
      **Security Features:**
      - Creator or admin permission required
      - Organization/branch scope validation
      - Deletion confirmation required
      - Activity logging and audit trail
      - Recovery tracking for accidental deletions
      
      **Business Rules:**
      - Only material creator or course admin can delete
      - Deletion affects student material access immediately
      - Related analytics and progress data is preserved
      - Soft delete option preserves data for recovery
      - Hard delete permanently removes all traces
      
      **Impact Assessment:**
      - Student access to material is revoked
      - Course structure and navigation updated
      - Analytics and progress tracking preserved
      - Related materials remain unaffected
      - Backup copies may be retained for audit
      
      **Use Cases:**
      - Removing outdated or incorrect materials
      - Cleaning up duplicate content
      - Managing course content lifecycle
      - Responding to copyright issues
      - Streamlining course organization
    `,
        operationId: 'deleteCourseMaterial',
    })
    @ApiParam({
        name: 'id',
        description: '🎯 Course material unique identifier to delete',
        type: 'number',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course material deleted successfully',
        type: CourseMaterialDeletedResponse,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description:
            '🔒 Forbidden - Insufficient permissions to delete this material',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example:
                        'Access denied - You do not have permission to delete this material',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 403 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course material not found',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'Course material with ID xxx not found',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 404 },
            },
        },
    })
    async remove(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(
                `Deleting course material ${id} by user: ${scope.userId}`,
            );

            return await this.courseMaterialsService.remove(
                id,
                { orgId: scope.orgId, branchId: scope.branchId },
                scope.userId,
            );
        } catch (error) {
            this.logger.error(`Error deleting course material ${id}:`, error);
            throw error;
        }
    }

    @Get('course/:courseId/count')
    @ApiOperation({
        summary: '📊 Get Course Material Count',
        description: `
      **Retrieves statistical information about course materials**
      
      This endpoint provides comprehensive material statistics including:
      - Total material count per course
      - Active vs inactive material counts
      - Material type distribution
      - Creator statistics
      - Usage and access metrics
      
      **Statistical Information:**
      - Total materials in course
      - Active materials available to students
      - Inactive/draft materials
      - Materials by type (PDF, Video, Links, etc.)
      - Recent additions and updates
      
      **Use Cases:**
      - Course dashboard analytics
      - Material management overview
      - Progress tracking for course development
      - Quality assurance metrics
      - Student engagement insights
    `,
        operationId: 'getCourseMaterialCount',
    })
    @ApiParam({
        name: 'courseId',
        description: '🎯 Course ID to get material count for',
        type: 'number',
        example: 1,
    })
    @ApiQuery({
        name: 'includeInactive',
        description: '👁️ Include inactive materials in count (default: false)',
        required: false,
        type: 'boolean',
        example: false,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Material count retrieved successfully',
        type: CourseMaterialCountResponse,
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course not found',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'Course with ID xxx not found',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 404 },
            },
        },
    })
    async getMaterialCount(
        @Param('courseId', ParseIntPipe) courseId: number,
        @Query('includeInactive') includeInactive?: boolean,
    ): Promise<CourseMaterialCountResponse> {
        try {
            this.logger.log(`Getting material count for course ${courseId}`);

            const count = await this.courseMaterialsService.getMaterialCount(
                courseId,
                includeInactive,
            );

            return {
                success: true,
                message: 'Material count retrieved successfully',
                data: {
                    count,
                    details: {
                        courseId,
                        totalMaterials: count,
                        activeMaterials: includeInactive ? count : count,
                        inactiveMaterials: 0,
                        materialsByType: {},
                    },
                },
            };
        } catch (error) {
            this.logger.error(
                `Error getting material count for course ${courseId}:`,
                error,
            );
            throw error;
        }
    }

    @Patch('course/:courseId/reorder')
    @ApiOperation({
        summary: '🔄 Reorder Course Materials',
        description: `
      **Bulk reorders course materials with comprehensive validation**
      
      This endpoint allows authorized users to reorder course materials with:
      - Bulk material reordering in single operation
      - Automatic conflict resolution
      - Validation of material ownership
      - Transaction-based updates
      - Cache invalidation and optimization
      
      **Reordering Features:**
      - Batch update of sort orders
      - Automatic gap filling and normalization
      - Conflict detection and resolution
      - Rollback capability on errors
      - Optimistic locking for concurrency
      
      **Security Features:**
      - Course admin or creator permission required
      - Material ownership validation
      - Organization/branch scope validation
      - Audit logging of changes
      
      **Business Rules:**
      - Only course materials can be reordered
      - Sort orders must be unique within course
      - Invalid material IDs are rejected
      - Minimum sort order is 1
      - Gaps in numbering are automatically filled
      
      **Use Cases:**
      - Reorganizing course content flow
      - Adjusting learning progression
      - Optimizing student experience
      - Managing content dependencies
      - Implementing pedagogical sequences
    `,
        operationId: 'reorderCourseMaterials',
    })
    @ApiParam({
        name: 'courseId',
        description: '🎯 Course ID to reorder materials for',
        type: 'number',
        example: 1,
    })
    @ApiBody({
        description: 'Array of material ID and new sort order pairs',
        schema: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    materialId: {
                        type: 'number',
                        description: 'Material unique identifier',
                        example: 1,
                    },
                    sortOrder: {
                        type: 'number',
                        description: 'New sort order position',
                        example: 1,
                    },
                },
                required: ['materialId', 'sortOrder'],
            },
        },
        examples: {
            'reorder-example': {
                summary: '🔄 Reorder Three Materials',
                description: 'Example of reordering three course materials',
                value: [
                    { materialId: 3, sortOrder: 1 },
                    { materialId: 1, sortOrder: 2 },
                    { materialId: 2, sortOrder: 3 },
                ],
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course materials reordered successfully',
        type: CourseMaterialReorderResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid reorder data or validation errors',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    examples: [
                        'Material ID xxx does not belong to this course',
                        'Duplicate sort order values detected',
                        'Sort order must be a positive number',
                        'Invalid material ID format',
                    ],
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 400 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description:
            '🔒 Forbidden - Insufficient permissions to reorder course materials',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example:
                        'Access denied - You do not have permission to reorder materials for this course',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 403 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course or materials not found',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    examples: [
                        'Course with ID xxx not found',
                        'Material with ID xxx not found',
                    ],
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 404 },
            },
        },
    })
    async reorderMaterials(
        @Param('courseId', ParseIntPipe) courseId: number,
        @Body() materialOrders: { materialId: number; sortOrder: number }[],
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(
                `Reordering ${materialOrders.length} materials for course ${courseId} by user: ${scope.userId}`,
            );

            return await this.courseMaterialsService.reorderMaterials(
                courseId,
                materialOrders,
                { orgId: scope.orgId, branchId: scope.branchId },
                scope.userId,
            );
        } catch (error) {
            this.logger.error(
                `Error reordering materials for course ${courseId}:`,
                error,
            );
            throw error;
        }
    }
}

/*
 * Class #78: CourseMaterialsModule
 * Source: course-materials/course-materials.module.ts:25
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 37 characters (1 lines)
 */
export class CourseMaterialsModule {}

/*
 * Class #79: CourseMaterialsService
 * Source: course-materials/course-materials.service.ts:35
 * Type: Exported Class
 * Methods: 48
 * Properties: 176
 * Decorators: 6
 * Complexity: 329
 * Size: 28746 characters (831 lines)
 */
export class CourseMaterialsService {
    private readonly logger = new Logger(CourseMaterialsService.name);

    private readonly CACHE_KEYS = {
        MATERIAL_BY_ID: (id: number) => `course-material:${id}`,
        MATERIALS_BY_COURSE: (courseId: number) =>
            `course-materials:course:${courseId}`,
        MATERIALS_COUNT: (courseId: number) =>
            `course-materials:count:${courseId}`,
        MATERIALS_BY_ORG: (orgId: string) => `course-materials:org:${orgId}`,
        MATERIALS_BY_BRANCH: (branchId: string) =>
            `course-materials:branch:${branchId}`,
        MEDIA_FILE_VARIANTS: (mediaFileId: number) =>
            `course-material:media:${mediaFileId}`,
    };

    private readonly CACHE_TTL = {
        MATERIAL: 60 * 60 * 24, // 24 hours
        MATERIALS_LIST: 60 * 60 * 12, // 12 hours
        COUNT: 60 * 60 * 6, // 6 hours
        MEDIA_VARIANTS: 60 * 60 * 10, // 10 hours
    };

    constructor(
        @InjectRepository(CourseMaterial)
        private readonly courseMaterialRepository: Repository<CourseMaterial>,
        @InjectRepository(Course)
        private readonly courseRepository: Repository<Course>,
        @InjectRepository(User)
        private readonly userRepository: Repository<User>,
        @InjectRepository(MediaFile)
        private readonly mediaRepository: Repository<MediaFile>,
        @Inject(CACHE_MANAGER)
        private readonly cacheManager: Cache,
        private readonly eventEmitter: EventEmitter2,
    ) {}

    private async retryOperation<T>(
        operation: () => Promise<T>,
        maxRetries = 3,
        delay = 1000,
    ): Promise<T> {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                const isConnectionError =
                    error instanceof Error &&
                    (error.message.includes('ECONNRESET') ||
                        error.message.includes('Connection lost') ||
                        error.message.includes('connect ETIMEDOUT'));

                if (isConnectionError && attempt < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                    continue;
                }
                throw error;
            }
        }
        throw new Error('Max retries exceeded');
    }

    /**
     * Load media file variants for a course material
     */
    private async loadMediaFileVariants(
        material: CourseMaterial,
    ): Promise<CourseMaterial> {
        if (material.mediaFile?.id) {
            try {
                // Check cache first for media file variants
                const cacheKey = this.CACHE_KEYS.MEDIA_FILE_VARIANTS(
                    material.mediaFile.id,
                );
                const cachedVariants =
                    await this.cacheManager.get<any[]>(cacheKey);

                if (cachedVariants) {
                    material.mediaFile.variants = cachedVariants;
                } else {
                    // Fetch from database if not cached
                    const variants = await this.mediaRepository.find({
                        where: {
                            originalFileId: material.mediaFile.id,
                            isActive: true,
                        },
                        order: { variant: 'ASC' },
                    });

                    if (variants.length > 0) {
                        material.mediaFile.variants = variants;
                        // Cache the variants
                        await this.cacheManager.set(
                            cacheKey,
                            variants,
                            this.CACHE_TTL.MEDIA_VARIANTS * 1000,
                        );
                    }
                }
            } catch (error) {
                this.logger.warn('Failed to load media file variants:', error);
            }
        }
        return material;
    }

    /**
     * Cache helper methods
     */
    private async invalidateMaterialCache(
        materialId: number,
        courseId?: number,
    ): Promise<void> {
        const keysToDelete = [this.CACHE_KEYS.MATERIAL_BY_ID(materialId)];

        if (courseId) {
            keysToDelete.push(
                this.CACHE_KEYS.MATERIALS_BY_COURSE(courseId),
                this.CACHE_KEYS.MATERIALS_COUNT(courseId),
            );
        }

        await Promise.all(
            keysToDelete.map(key =>
                this.cacheManager
                    .del(key)
                    .catch(error =>
                        this.logger.warn(
                            `Cache deletion failed for key ${key}:`,
                            error,
                        ),
                    ),
            ),
        );
    }

    private async invalidateCourseListCaches(courseId: number): Promise<void> {
        const keysToDelete = [
            this.CACHE_KEYS.MATERIALS_BY_COURSE(courseId),
            this.CACHE_KEYS.MATERIALS_COUNT(courseId),
        ];

        await Promise.all(
            keysToDelete.map(key =>
                this.cacheManager
                    .del(key)
                    .catch(error =>
                        this.logger.warn(
                            `Cache deletion failed for key ${key}:`,
                            error,
                        ),
                    ),
            ),
        );
    }

    /**
     * Validate course access with scope
     */
    private async validateCourseAccessWithScope(
        courseId: number,
        scope: OrgBranchScope,
        // userId is kept for potential future access control logic
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        userId?: string,
    ): Promise<Course> {
        const course = await this.courseRepository.findOne({
            where: { courseId },
            relations: ['orgId', 'branchId'],
        });

        if (!course) {
            throw new NotFoundException(`Course with ID ${courseId} not found`);
        }

        // Validate organization access if orgId provided
        if (scope.orgId && course.orgId?.id !== scope.orgId) {
            throw new ForbiddenException(
                'Access denied: Course belongs to different organization',
            );
        }

        // Validate branch access if branchId provided
        if (scope.branchId && course.branchId?.id !== scope.branchId) {
            throw new ForbiddenException(
                'Access denied: Course belongs to different branch',
            );
        }

        return course;
    }

    /**
     * Map entity to response DTO
     */
    private mapToResponseDto(
        material: CourseMaterial,
    ): CourseMaterialResponseDto {
        return {
            materialId: material.materialId,
            title: material.title,
            description: material.description,
            mediaFile: material.mediaFile
                ? {
                      id: material.mediaFile.id,
                      originalName: material.mediaFile.originalName,
                      url: material.mediaFile.url,
                      thumbnail: material.mediaFile.variants?.find(
                          v => v?.variant === ImageVariant.THUMBNAIL,
                      )?.url,
                      medium: material.mediaFile.variants?.find(
                          v => v?.variant === ImageVariant.MEDIUM,
                      )?.url,
                      original:
                          material.mediaFile.variants?.find(
                              v => v.variant === ImageVariant.ORIGINAL,
                          )?.url || material.mediaFile.url,
                      type: material.mediaFile.type,
                      size: material.mediaFile.size,
                      mimeType: material.mediaFile.mimeType,
                      variants: material.mediaFile.variants,
                  }
                : undefined,
            externalUrl: material.externalUrl,
            type: material.type,
            sortOrder: material.sortOrder,
            isActive: material.isActive,
            courseId: material.courseId,
            createdBy: material.createdBy,
            updatedBy: material.updatedBy,
            createdAt: material.createdAt,
            updatedAt: material.updatedAt,
            course: material.course
                ? {
                      courseId: material.course.courseId,
                      title: material.course.title,
                      description: material.course.description,
                      orgId: material.course.orgId?.id,
                      branchId: material.course.branchId?.id,
                  }
                : undefined,
            creator: material.creator
                ? {
                      id: material.creator.id,
                      firstName: material.creator.firstName,
                      lastName: material.creator.lastName,
                      email: material.creator.email,
                  }
                : undefined,
        };
    }

    /**
     * Create a new course material
     */
    async create(
        createCourseMaterialDto: CreateCourseMaterialDto,
        scope: OrgBranchScope,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            // Validate course access
            const course = await this.validateCourseAccessWithScope(
                createCourseMaterialDto.courseId,
                scope,
                createCourseMaterialDto.createdBy,
            );

            // Validate creator exists
            const creator = await this.userRepository.findOne({
                where: { id: createCourseMaterialDto.createdBy },
            });

            if (!creator) {
                throw new NotFoundException(
                    `User with ID ${createCourseMaterialDto.createdBy} not found`,
                );
            }

            // Validate media file if provided
            let mediaFile: MediaFile | undefined;
            if (createCourseMaterialDto.mediaFileId) {
                mediaFile =
                    (await this.mediaRepository.findOne({
                        where: { id: createCourseMaterialDto.mediaFileId },
                    })) || undefined;

                if (!mediaFile) {
                    throw new NotFoundException(
                        `Media file with ID ${createCourseMaterialDto.mediaFileId} not found`,
                    );
                }
            }

            // Create the material
            const material = this.courseMaterialRepository.create({
                title: createCourseMaterialDto.title,
                description: createCourseMaterialDto.description,
                mediaFile,
                externalUrl: createCourseMaterialDto.externalUrl,
                type: createCourseMaterialDto.type,
                sortOrder: createCourseMaterialDto.sortOrder,
                isActive: createCourseMaterialDto.isActive,
                courseId: createCourseMaterialDto.courseId,
                createdBy: createCourseMaterialDto.createdBy,
                orgId: course.orgId,
                branchId: course.branchId,
            });

            const savedMaterial =
                await this.courseMaterialRepository.save(material);

            // Invalidate related caches
            await this.invalidateCourseListCaches(
                createCourseMaterialDto.courseId,
            );

            // Emit event for logging/analytics
            this.eventEmitter.emit('course-material.created', {
                materialId: savedMaterial.materialId,
                courseId: savedMaterial.courseId,
                title: savedMaterial.title,
                type: savedMaterial.type,
                createdBy: savedMaterial.createdBy,
                orgId: course.orgId?.id,
                branchId: course.branchId?.id,
            });

            this.logger.log(
                `Course material created: ${savedMaterial.materialId} by user ${savedMaterial.createdBy}`,
            );

            return {
                message: 'Course material created successfully',
                status: 'success',
                code: 201,
            };
        });
    }

    /**
     * Find all materials for a course with caching
     */
    async findByCourse(
        courseId: number,
        scope: OrgBranchScope,
        userId?: string,
        options: {
            includeInactive?: boolean;
            sortBy?: 'title' | 'createdAt' | 'sortOrder';
            sortOrder?: 'ASC' | 'DESC';
        } = {},
    ): Promise<CourseMaterialListApiResponse> {
        return this.retryOperation(async () => {
            // Check cache first
            const cacheKey = this.CACHE_KEYS.MATERIALS_BY_COURSE(courseId);

            try {
                const cachedResult =
                    await this.cacheManager.get<CourseMaterialListApiResponse>(
                        cacheKey,
                    );

                if (cachedResult && !options.includeInactive) {
                    this.logger.debug(
                        `Cache hit for course materials: ${cacheKey}`,
                    );
                    return cachedResult;
                }
            } catch (error) {
                this.logger.warn(
                    `Cache get failed for key ${cacheKey}:`,
                    error,
                );
            }

            // Validate course access
            const course = await this.validateCourseAccessWithScope(
                courseId,
                scope,
                userId,
            );

            // Build query
            const queryBuilder = this.courseMaterialRepository
                .createQueryBuilder('material')
                .leftJoinAndSelect('material.course', 'course')
                .leftJoinAndSelect('material.creator', 'creator')
                .leftJoinAndSelect('material.mediaFile', 'mediaFile')
                .where('material.courseId = :courseId', { courseId });

            // Filter by active status if needed
            if (!options.includeInactive) {
                queryBuilder.andWhere('material.isActive = :isActive', {
                    isActive: true,
                });
            }

            // Apply sorting
            const sortBy = options.sortBy || 'sortOrder';
            const sortOrder = options.sortOrder || 'ASC';
            queryBuilder.orderBy(`material.${sortBy}`, sortOrder);

            // If secondary sort needed
            if (sortBy !== 'sortOrder') {
                queryBuilder.addOrderBy('material.sortOrder', 'ASC');
            }

            const [materials, total] = await queryBuilder.getManyAndCount();

            // Load media file variants for each material
            const materialsWithVariants = await Promise.all(
                materials.map(material => this.loadMediaFileVariants(material)),
            );

            const result: CourseMaterialListApiResponse = {
                success: true,
                message: 'Course materials retrieved successfully',
                data: {
                    materials: materialsWithVariants.map(material =>
                        this.mapToResponseDto(material),
                    ),
                    total,
                    course: {
                        courseId: course.courseId,
                        title: course.title,
                        description: course.description,
                    },
                },
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };

            // Cache the result if not including inactive materials
            if (!options.includeInactive) {
                try {
                    await this.cacheManager.set(
                        cacheKey,
                        result,
                        this.CACHE_TTL.MATERIALS_LIST * 1000,
                    );
                    this.logger.debug(
                        `Cache set for course materials: ${cacheKey}`,
                    );
                } catch (error) {
                    this.logger.warn(
                        `Cache set failed for key ${cacheKey}:`,
                        error,
                    );
                }
            }

            return result;
        });
    }

    /**
     * Find a single material by ID with caching
     */
    async findOne(
        id: number,
        scope: OrgBranchScope,
        userId?: string,
    ): Promise<CourseMaterialResponseDto> {
        return this.retryOperation(async () => {
            // Check cache first
            const cacheKey = this.CACHE_KEYS.MATERIAL_BY_ID(id);

            try {
                const cachedMaterial =
                    await this.cacheManager.get<CourseMaterialResponseDto>(
                        cacheKey,
                    );

                if (cachedMaterial) {
                    this.logger.debug(`Cache hit for material: ${cacheKey}`);
                    return cachedMaterial;
                }
            } catch (error) {
                this.logger.warn(
                    `Cache get failed for key ${cacheKey}:`,
                    error,
                );
            }

            const material = await this.courseMaterialRepository.findOne({
                where: { materialId: id },
                relations: [
                    'course',
                    'course.orgId',
                    'course.branchId',
                    'creator',
                    'mediaFile',
                ],
            });

            if (!material) {
                throw new NotFoundException(
                    `Course material with ID ${id} not found`,
                );
            }

            // Validate course access
            await this.validateCourseAccessWithScope(
                material.courseId,
                scope,
                userId,
            );

            // Load media file variants
            const materialWithVariants =
                await this.loadMediaFileVariants(material);

            const result = this.mapToResponseDto(materialWithVariants);

            // Cache the result
            try {
                await this.cacheManager.set(
                    cacheKey,
                    result,
                    this.CACHE_TTL.MATERIAL * 1000,
                );
                this.logger.debug(`Cache set for material: ${cacheKey}`);
            } catch (error) {
                this.logger.warn(
                    `Cache set failed for key ${cacheKey}:`,
                    error,
                );
            }

            return result;
        });
    }

    /**
     * Update a course material
     */
    async update(
        id: number,
        updateCourseMaterialDto: UpdateCourseMaterialDto,
        scope: OrgBranchScope,
        userId?: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            const material = await this.courseMaterialRepository.findOne({
                where: { materialId: id },
                relations: ['course'],
            });

            if (!material) {
                throw new NotFoundException(
                    `Course material with ID ${id} not found`,
                );
            }

            // Validate course access
            await this.validateCourseAccessWithScope(
                material.courseId,
                scope,
                userId,
            );

            // If courseId is being changed, validate new course access
            if (
                updateCourseMaterialDto.courseId &&
                updateCourseMaterialDto.courseId !== material.courseId
            ) {
                await this.validateCourseAccessWithScope(
                    updateCourseMaterialDto.courseId,
                    scope,
                    userId,
                );
            }

            // Validate media file if provided
            let mediaFile: MediaFile | undefined;
            if (updateCourseMaterialDto.mediaFileId) {
                mediaFile =
                    (await this.mediaRepository.findOne({
                        where: { id: updateCourseMaterialDto.mediaFileId },
                    })) || undefined;

                if (!mediaFile) {
                    throw new NotFoundException(
                        `Media file with ID ${updateCourseMaterialDto.mediaFileId} not found`,
                    );
                }
            }

            // Update the material
            if (updateCourseMaterialDto.title !== undefined) {
                material.title = updateCourseMaterialDto.title;
            }
            if (updateCourseMaterialDto.description !== undefined) {
                material.description = updateCourseMaterialDto.description;
            }
            if (updateCourseMaterialDto.mediaFileId !== undefined) {
                material.mediaFile = mediaFile;
            }
            if (updateCourseMaterialDto.externalUrl !== undefined) {
                material.externalUrl = updateCourseMaterialDto.externalUrl;
            }
            if (updateCourseMaterialDto.type !== undefined) {
                material.type = updateCourseMaterialDto.type;
            }
            if (updateCourseMaterialDto.sortOrder !== undefined) {
                material.sortOrder = updateCourseMaterialDto.sortOrder;
            }
            if (updateCourseMaterialDto.isActive !== undefined) {
                material.isActive = updateCourseMaterialDto.isActive;
            }
            if (updateCourseMaterialDto.updatedBy) {
                material.updatedBy = updateCourseMaterialDto.updatedBy;
            }

            const updatedMaterial =
                await this.courseMaterialRepository.save(material);

            // Invalidate caches
            await this.invalidateMaterialCache(id, material.courseId);
            if (
                updateCourseMaterialDto.courseId &&
                updateCourseMaterialDto.courseId !== material.courseId
            ) {
                await this.invalidateCourseListCaches(
                    updateCourseMaterialDto.courseId,
                );
            }

            // Emit event
            this.eventEmitter.emit('course-material.updated', {
                materialId: updatedMaterial.materialId,
                courseId: updatedMaterial.courseId,
                title: updatedMaterial.title,
                updatedBy: updatedMaterial.updatedBy,
                changes: updateCourseMaterialDto,
            });

            this.logger.log(
                `Course material updated: ${updatedMaterial.materialId} by user ${updatedMaterial.updatedBy || userId}`,
            );

            return {
                message: 'Course material updated successfully',
                status: 'success',
                code: 200,
            };
        });
    }

    /**
     * Delete a course material
     */
    async remove(
        id: number,
        scope: OrgBranchScope,
        userId?: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            const material = await this.courseMaterialRepository.findOne({
                where: { materialId: id },
                relations: ['course'],
            });

            if (!material) {
                throw new NotFoundException(
                    `Course material with ID ${id} not found`,
                );
            }

            // Validate course access
            await this.validateCourseAccessWithScope(
                material.courseId,
                scope,
                userId,
            );

            const materialInfo = {
                materialId: material.materialId,
                courseId: material.courseId,
                title: material.title,
                type: material.type,
                deletedBy: userId,
            };

            await this.courseMaterialRepository.remove(material);

            // Invalidate caches
            await this.invalidateMaterialCache(id, material.courseId);

            // Emit event
            this.eventEmitter.emit('course-material.deleted', materialInfo);

            this.logger.log(
                `Course material deleted: ${materialInfo.materialId} by user ${userId}`,
            );

            return {
                message: 'Course material deleted successfully',
                status: 'success',
                code: 200,
            };
        });
    }

    /**
     * Get material count for a course with caching
     */
    async getMaterialCount(
        courseId: number,
        includeInactive = false,
    ): Promise<number> {
        return this.retryOperation(async () => {
            const cacheKey = this.CACHE_KEYS.MATERIALS_COUNT(courseId);

            try {
                const cachedCount =
                    await this.cacheManager.get<number>(cacheKey);
                if (
                    cachedCount !== undefined &&
                    cachedCount !== null &&
                    !includeInactive
                ) {
                    this.logger.debug(
                        `Cache hit for material count: ${cacheKey}`,
                    );
                    return cachedCount;
                }
            } catch (error) {
                this.logger.warn(
                    `Cache get failed for key ${cacheKey}:`,
                    error,
                );
            }

            const whereClause: {
                courseId: number;
                isActive?: boolean;
            } = { courseId };
            if (!includeInactive) {
                whereClause.isActive = true;
            }

            const count = await this.courseMaterialRepository.count({
                where: whereClause,
            });

            if (!includeInactive) {
                try {
                    await this.cacheManager.set(
                        cacheKey,
                        count,
                        this.CACHE_TTL.COUNT * 1000,
                    );
                    this.logger.debug(
                        `Cache set for material count: ${cacheKey}`,
                    );
                } catch (error) {
                    this.logger.warn(
                        `Cache set failed for key ${cacheKey}:`,
                        error,
                    );
                }
            }

            return count;
        });
    }

    /**
     * Reorder materials within a course
     */
    async reorderMaterials(
        courseId: number,
        materialOrders: { materialId: number; sortOrder: number }[],
        scope: OrgBranchScope,
        userId?: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            // Validate course access
            await this.validateCourseAccessWithScope(courseId, scope, userId);

            // Validate all materials belong to the course
            const materials = await this.courseMaterialRepository.find({
                where: {
                    courseId,
                    materialId: In(
                        materialOrders.map(order => order.materialId),
                    ),
                },
            });

            if (materials.length !== materialOrders.length) {
                throw new ConflictException(
                    'Some materials do not belong to the specified course',
                );
            }

            // Update sort orders
            await Promise.all(
                materialOrders.map(({ materialId, sortOrder }) =>
                    this.courseMaterialRepository.update(
                        { materialId },
                        { sortOrder, updatedBy: userId },
                    ),
                ),
            );

            // Invalidate caches
            await this.invalidateCourseListCaches(courseId);

            // Emit event
            this.eventEmitter.emit('course-materials.reordered', {
                courseId,
                materialOrders,
                reorderedBy: userId,
            });

            this.logger.log(
                `Course materials reordered for course ${courseId} by user ${userId}`,
            );

            return {
                message: 'Course materials reordered successfully',
                status: 'success',
                code: 200,
            };
        });
    }
}

/*
 * Class #80: CourseMaterialResponseDto
 * Source: course-materials/dto/course-material-response.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 37
 * Decorators: 15
 * Complexity: 51
 * Size: 3651 characters (134 lines)
 */
export class CourseMaterialResponseDto {
    @ApiProperty({
        description: '🆔 Course material unique identifier',
        example: 1,
    })
    materialId: number;

    @ApiProperty({
        description: '📝 Material title',
        example: 'Introduction to Programming Concepts',
    })
    title: string;

    @ApiProperty({
        description: '📄 Detailed material description',
        example:
            'A comprehensive guide covering basic programming concepts and fundamentals',
        required: false,
    })
    description?: string;

    @ApiProperty({
        description:
            '📎 Media file containing the course material content with multiple format variants',
        example: {
            id: 1,
            originalName: 'programming-guide.pdf',
            url: 'https://storage.googleapis.com/bucket/media/programming-guide.pdf',
            thumbnail:
                'https://storage.googleapis.com/bucket/media/programming-guide-thumbnail.jpg',
            medium: 'https://storage.googleapis.com/bucket/media/programming-guide-medium.jpg',
            original:
                'https://storage.googleapis.com/bucket/media/programming-guide.pdf',
            type: 'document',
            size: 2048576,
            mimeType: 'application/pdf',
        },
        required: false,
    })
    mediaFile?: {
        id: number;
        originalName?: string;
        url?: string;
        thumbnail?: string;
        medium?: string;
        original?: string;
        type?: string;
        size?: number;
        mimeType?: string;
        variants?: any[];
    };

    @ApiProperty({
        description:
            '🔗 External URL for materials not stored in media manager (e.g., YouTube videos, external documents)',
        example: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',
        required: false,
    })
    externalUrl?: string;

    @ApiProperty({
        description: '🎯 Type of the material',
        enum: MaterialType,
        example: MaterialType.PDF,
    })
    type: MaterialType;

    @ApiProperty({
        description: '🔢 Display order of the material within the course',
        example: 1,
    })
    sortOrder: number;

    @ApiProperty({
        description:
            '✅ Whether the material is currently available to students',
        example: true,
    })
    isActive: boolean;

    @ApiProperty({
        description: '🎓 ID of the course this material belongs to',
        example: 1,
    })
    courseId: number;

    @ApiProperty({
        description: '👤 ID of the user who created this material',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    createdBy: string;

    @ApiProperty({
        description: '👤 ID of the user who last updated this material',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
        required: false,
    })
    updatedBy?: string;

    @ApiProperty({
        description: '📅 Material creation timestamp',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @ApiProperty({
        description: '📅 Material last update timestamp',
        example: '2024-01-15T10:30:45.123Z',
    })
    updatedAt: Date;

    @ApiProperty({
        description: '🎓 Course information',
        required: false,
    })
    course?: {
        courseId: number;
        title: string;
        description?: string;
        orgId: string;
        branchId?: string;
    };

    @ApiProperty({
        description: '👤 Creator information',
        required: false,
    })
    creator?: {
        id: string;
        firstName: string;
        lastName: string;
        email: string;
    };
}

/*
 * Class #81: CourseMaterialListDto
 * Source: course-materials/dto/course-material-response.dto.ts:139
 * Type: Exported Class
 * Methods: 0
 * Properties: 10
 * Decorators: 4
 * Complexity: 13
 * Size: 796 characters (35 lines)
 */
export class CourseMaterialListDto {
    @ApiProperty({
        description: '📚 List of course materials',
        type: [CourseMaterialResponseDto],
    })
    materials: CourseMaterialResponseDto[];

    @ApiProperty({
        description: '🔢 Total number of materials',
        example: 15,
    })
    total: number;

    @ApiProperty({
        description: '🎓 Course context information',
        required: false,
    })
    course?: {
        courseId: number;
        title: string;
        description?: string;
    };

    @ApiProperty({
        description: '📊 Material statistics by type',
        required: false,
    })
    statistics?: {
        totalActive: number;
        totalInactive: number;
        byType: {
            [key in MaterialType]?: number;
        };
    };
}

/*
 * Class #82: CourseMaterialStatsDto
 * Source: course-materials/dto/course-material-response.dto.ts:175
 * Type: Exported Class
 * Methods: 0
 * Properties: 7
 * Decorators: 7
 * Complexity: 17
 * Size: 1328 characters (54 lines)
 */
export class CourseMaterialStatsDto {
    @ApiProperty({
        description: '🎓 Course unique identifier',
        example: 1,
    })
    courseId: number;

    @ApiProperty({
        description: '📚 Total number of materials in the course',
        example: 15,
    })
    totalMaterials: number;

    @ApiProperty({
        description: '✅ Number of active materials available to students',
        example: 12,
    })
    activeMaterials: number;

    @ApiProperty({
        description: '⏸️ Number of inactive/draft materials',
        example: 3,
    })
    inactiveMaterials: number;

    @ApiProperty({
        description: '📊 Material distribution by type',
        type: 'object',
        additionalProperties: {
            type: 'number',
        },
        example: {
            PDF: 5,
            VIDEO: 3,
            LINK: 4,
            DOCUMENT: 3,
        },
    })
    materialsByType: Record<string, number>;

    @ApiProperty({
        description: '📅 Most recent material addition timestamp',
        example: '2024-01-15T10:30:45.123Z',
        required: false,
    })
    lastMaterialAddedAt?: Date;

    @ApiProperty({
        description: '📅 Most recent material update timestamp',
        example: '2024-01-15T10:30:45.123Z',
        required: false,
    })
    lastMaterialUpdatedAt?: Date;
}

/*
 * Class #83: StandardApiResponse
 * Source: course-materials/dto/course-material-response.dto.ts:231
 * Type: Exported Class
 * Methods: 0
 * Properties: 11
 * Decorators: 4
 * Complexity: 15
 * Size: 817 characters (34 lines)
 */
export class StandardApiResponse<T = any> {
    @ApiProperty({
        description: '✅ Indicates if the operation was successful',
        example: true,
    })
    success: boolean;

    @ApiProperty({
        description: '💬 Human-readable message about the operation result',
        example: 'Operation completed successfully',
    })
    message: string;

    @ApiProperty({
        description: '📦 Response data payload',
        required: false,
    })
    data?: T;

    @ApiProperty({
        description: '📊 Additional metadata about the response',
        required: false,
    })
    meta?: {
        timestamp?: string;
        requestId?: string;
        pagination?: {
            page: number;
            limit: number;
            total: number;
            totalPages: number;
        };
    };
}

/*
 * Class #84: StandardOperationResponse
 * Source: course-materials/dto/course-material-response.dto.ts:266
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 7
 * Size: 527 characters (20 lines)
 */
export class StandardOperationResponse {
    @ApiProperty({
        description: '💬 Human-readable message about the operation result',
        example: 'Course material created successfully',
    })
    message: string;

    @ApiProperty({
        description: '🔖 Operation status indicator',
        example: 'success',
        enum: ['success', 'error', 'warning', 'info', 'debug'],
    })
    status: string;

    @ApiProperty({
        description: '🔢 HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #85: CourseMaterialApiResponse
 * Source: course-materials/dto/course-material-response.dto.ts:288
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 1
 * Complexity: 4
 * Size: 249 characters (7 lines)
 * Extends: StandardApiResponse<CourseMaterialResponseDto>
 */
export class CourseMaterialApiResponse extends StandardApiResponse<CourseMaterialResponseDto> {
    @ApiProperty({
        description: '📚 Course material data',
        type: CourseMaterialResponseDto,
    })
    data: CourseMaterialResponseDto;
}

/*
 * Class #86: CourseMaterialListApiResponse
 * Source: course-materials/dto/course-material-response.dto.ts:296
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 1
 * Complexity: 4
 * Size: 259 characters (7 lines)
 * Extends: StandardApiResponse<CourseMaterialListDto>
 */
export class CourseMaterialListApiResponse extends StandardApiResponse<CourseMaterialListDto> {
    @ApiProperty({
        description: '📚 List of course materials with metadata',
        type: CourseMaterialListDto,
    })
    data: CourseMaterialListDto;
}

/*
 * Class #87: CourseMaterialStatsResponse
 * Source: course-materials/dto/course-material-response.dto.ts:304
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 1
 * Complexity: 4
 * Size: 248 characters (7 lines)
 * Extends: StandardApiResponse<CourseMaterialStatsDto>
 */
export class CourseMaterialStatsResponse extends StandardApiResponse<CourseMaterialStatsDto> {
    @ApiProperty({
        description: '📊 Course material statistics',
        type: CourseMaterialStatsDto,
    })
    data: CourseMaterialStatsDto;
}

/*
 * Class #88: CourseMaterialCreatedResponse
 * Source: course-materials/dto/course-material-response.dto.ts:313
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 481 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class CourseMaterialCreatedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: '✅ Course material creation success message',
        example: 'Course material created successfully',
    })
    message: string;

    @ApiProperty({
        description: '🔖 Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: '🔢 HTTP status code',
        example: 201,
    })
    code: number;
}

/*
 * Class #89: CourseMaterialUpdatedResponse
 * Source: course-materials/dto/course-material-response.dto.ts:333
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 479 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class CourseMaterialUpdatedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: '✅ Course material update success message',
        example: 'Course material updated successfully',
    })
    message: string;

    @ApiProperty({
        description: '🔖 Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: '🔢 HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #90: CourseMaterialDeletedResponse
 * Source: course-materials/dto/course-material-response.dto.ts:353
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 481 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class CourseMaterialDeletedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: '✅ Course material deletion success message',
        example: 'Course material deleted successfully',
    })
    message: string;

    @ApiProperty({
        description: '🔖 Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: '🔢 HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #91: CourseMaterialCountResponse
 * Source: course-materials/dto/course-material-response.dto.ts:373
 * Type: Exported Class
 * Methods: 0
 * Properties: 2
 * Decorators: 0
 * Complexity: 2
 * Size: 128 characters (4 lines)
 * Extends: StandardApiResponse<
 */
export class CourseMaterialCountResponse extends StandardApiResponse<{
    count: number;
    details: CourseMaterialStatsDto;
}

/*
 * Class #92: CourseMaterialReorderResponse
 * Source: course-materials/dto/course-material-response.dto.ts:386
 * Type: Exported Class
 * Methods: 0
 * Properties: 7
 * Decorators: 4
 * Complexity: 11
 * Size: 698 characters (29 lines)
 * Extends: StandardOperationResponse
 */
export class CourseMaterialReorderResponse extends StandardOperationResponse {
    @ApiProperty({
        description: '✅ Material reorder success message',
        example: 'Course materials reordered successfully',
    })
    message: string;

    @ApiProperty({
        description: '🔖 Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: '🔢 HTTP status code',
        example: 200,
    })
    code: number;

    @ApiProperty({
        description: '📊 Reorder operation metadata',
        required: false,
    })
    meta?: {
        materialsUpdated: number;
        conflictsResolved: number;
        timestamp: string;
    };
}

/*
 * Class #93: CreateCourseMaterialDto
 * Source: course-materials/dto/create-course-material.dto.ts:17
 * Type: Exported Class
 * Methods: 1
 * Properties: 32
 * Decorators: 36
 * Complexity: 90
 * Size: 3223 characters (108 lines)
 */
export class CreateCourseMaterialDto {
    @ApiProperty({
        description: 'Material title',
        example: 'Introduction to Programming Concepts',
        maxLength: 255,
    })
    @IsString()
    @IsNotEmpty()
    @MaxLength(255, { message: 'Title cannot exceed 255 characters' })
    title: string;

    @ApiProperty({
        description: 'Material description',
        example:
            'A comprehensive guide covering basic programming concepts and fundamentals',
        required: false,
        maxLength: 2000,
    })
    @IsString()
    @IsOptional()
    @MaxLength(2000, { message: 'Description cannot exceed 2000 characters' })
    description?: string;

    @ApiProperty({
        description:
            'Media file ID from media library for uploaded course materials (documents, videos, images, etc.)',
        example: 1,
        required: false,
        type: Number,
        title: 'Media File ID',
    })
    @IsOptional()
    @IsNumber(
        { allowNaN: false, allowInfinity: false },
        { message: 'Media file ID must be a valid number' },
    )
    @ValidateIf(o => !('externalUrl' in o))
    mediaFileId?: number;

    @ApiProperty({
        description:
            'External URL for materials not stored in media manager (e.g., YouTube videos, external documents, web links)',
        example: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',
        required: false,
    })
    @IsString()
    @IsOptional()
    @IsUrl({}, { message: 'Please provide a valid URL' })
    @ValidateIf(o => !('mediaFileId' in o))
    externalUrl?: string;

    @ApiProperty({
        description: 'Type of the material',
        enum: MaterialType,
        example: MaterialType.PDF,
        default: MaterialType.DOCUMENT,
    })
    @IsEnum(MaterialType, {
        message:
            'Type must be one of: pdf, video, audio, document, link, image, presentation, spreadsheet, other',
    })
    @IsOptional()
    type?: MaterialType = MaterialType.DOCUMENT;

    @ApiProperty({
        description: 'Display order of the material within the course',
        example: 1,
        minimum: 0,
        default: 0,
    })
    @IsNumber({}, { message: 'Sort order must be a number' })
    @Min(0, { message: 'Sort order must be 0 or greater' })
    @Transform(({ value }) => parseInt(value, 10))
    @IsOptional()
    sortOrder?: number = 0;

    @ApiProperty({
        description: 'Whether the material is currently available to students',
        example: true,
        default: true,
    })
    @IsBoolean()
    @Transform(({ value }) => {
        if (typeof value === 'string') {
            return value.toLowerCase() === 'true';
        }
        return Boolean(value);
    })
    @IsOptional()
    isActive?: boolean = true;

    @ApiProperty({
        description: 'ID of the course this material belongs to',
        example: 1,
    })
    @IsNumber({}, { message: 'Course ID must be a number' })
    @IsNotEmpty()
    @Transform(({ value }) => parseInt(value, 10))
    courseId: number;

    @ApiProperty({
        description: 'ID of the user creating this material',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    @IsString()
    @IsNotEmpty()
    createdBy: string;
}

/*
 * Class #94: UpdateCourseMaterialDto
 * Source: course-materials/dto/update-course-material.dto.ts:19
 * Type: Exported Class
 * Methods: 2
 * Properties: 28
 * Decorators: 34
 * Complexity: 88
 * Size: 3017 characters (105 lines)
 * Extends: PartialType(
    CreateCourseMaterialDto,
)
 */
export class UpdateCourseMaterialDto extends PartialType(
    CreateCourseMaterialDto,
) {
    @ApiProperty({
        description: 'Updated material title',
        example: 'Advanced Programming Concepts',
        maxLength: 255,
        required: false,
    })
    @IsOptional()
    @IsString()
    @IsNotEmpty()
    @MaxLength(255, { message: 'Title cannot exceed 255 characters' })
    title?: string;

    @ApiProperty({
        description: 'Updated material description',
        example:
            'An advanced guide covering complex programming concepts and best practices',
        required: false,
        maxLength: 2000,
    })
    @IsOptional()
    @IsString()
    @MaxLength(2000, { message: 'Description cannot exceed 2000 characters' })
    description?: string;

    @ApiProperty({
        description:
            'Updated media file ID from media library for uploaded course materials',
        example: 2,
        required: false,
        type: Number,
        title: 'Media File ID',
    })
    @IsOptional()
    @IsNumber(
        { allowNaN: false, allowInfinity: false },
        { message: 'Media file ID must be a valid number' },
    )
    @ValidateIf(o => !('externalUrl' in o))
    mediaFileId?: number;

    @ApiProperty({
        description:
            'Updated external URL for materials not stored in media manager',
        example: 'https://www.youtube.com/watch?v=updated-video-id',
        required: false,
    })
    @IsOptional()
    @IsString()
    @IsUrl({}, { message: 'Please provide a valid URL' })
    @ValidateIf(o => !('mediaFileId' in o))
    externalUrl?: string;

    @ApiProperty({
        description: 'Updated type of the material',
        enum: MaterialType,
        example: MaterialType.VIDEO,
        required: false,
    })
    @IsOptional()
    @IsEnum(MaterialType, {
        message:
            'Type must be one of: pdf, video, audio, document, link, image, presentation, spreadsheet, other',
    })
    type?: MaterialType;

    @ApiProperty({
        description: 'Updated display order of the material within the course',
        example: 2,
        minimum: 0,
        required: false,
    })
    @IsOptional()
    @IsNumber({}, { message: 'Sort order must be a number' })
    @Min(0, { message: 'Sort order must be 0 or greater' })
    @Transform(({ value }) => parseInt(value, 10))
    sortOrder?: number;

    @ApiProperty({
        description: 'Updated availability status of the material for students',
        example: false,
        required: false,
    })
    @IsOptional()
    @IsBoolean()
    @Transform(({ value }) => {
        if (typeof value === 'string') {
            return value.toLowerCase() === 'true';
        }
        return Boolean(value);
    })
    isActive?: boolean;

    @ApiProperty({
        description: 'ID of the user updating this material',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
        required: false,
    })
    @IsOptional()
    @IsString()
    @IsNotEmpty()
    updatedBy?: string;
}

/*
 * Class #95: CourseMaterial
 * Source: course-materials/entities/course-material.entity.ts:32
 * Type: Exported Class
 * Methods: 1
 * Properties: 42
 * Decorators: 53
 * Complexity: 121
 * Size: 4117 characters (157 lines)
 */
export class CourseMaterial {
    @PrimaryGeneratedColumn()
    @ApiProperty({
        description: 'Course material unique identifier',
        example: 1,
    })
    materialId: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Material title',
        example: 'Introduction to Programming Concepts',
    })
    @IsString()
    @IsNotEmpty()
    title: string;

    @Column('text', { nullable: true })
    @ApiProperty({
        description: 'Material description',
        example:
            'A comprehensive guide covering basic programming concepts and fundamentals',
        required: false,
    })
    @IsString()
    @IsOptional()
    description?: string;

    @ManyToOne(() => MediaFile, { nullable: true })
    @ApiProperty({
        description: 'Media file containing the course material content',
        type: () => MediaFile,
        required: false,
    })
    mediaFile?: MediaFile;

    @Column('text', { nullable: true })
    @ApiProperty({
        description:
            'External URL for materials not stored in media manager (e.g., external links, embedded videos)',
        example: 'https://www.youtube.com/watch?v=example',
        required: false,
    })
    @IsString()
    @IsOptional()
    externalUrl?: string;

    @Column({
        type: 'enum',
        enum: MaterialType,
        default: MaterialType.DOCUMENT,
    })
    @Index()
    @ApiProperty({
        description: 'Type of the material',
        enum: MaterialType,
        example: MaterialType.PDF,
    })
    @IsEnum(MaterialType)
    type: MaterialType;

    @Column({ default: 0 })
    @ApiProperty({
        description: 'Display order of the material within the course',
        example: 1,
    })
    sortOrder: number;

    @Column({ default: true })
    @ApiProperty({
        description: 'Whether the material is currently available to students',
        example: true,
    })
    isActive: boolean;

    @Column()
    @ApiProperty({
        description: 'ID of the course this material belongs to',
        example: 1,
    })
    @IsNotEmpty()
    courseId: number;

    @Column()
    @ApiProperty({
        description: 'ID of the user who created this material',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    @IsString()
    @IsNotEmpty()
    createdBy: string;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'ID of the user who last updated this material',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
        required: false,
    })
    @IsString()
    @IsOptional()
    updatedBy?: string;

    @CreateDateColumn()
    @ApiProperty({
        description: 'Material creation timestamp',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @UpdateDateColumn()
    @ApiProperty({
        description: 'Material last update timestamp',
        example: '2024-01-15T10:30:45.123Z',
    })
    updatedAt: Date;

    // Relations
    @ManyToOne(() => Course, course => course.courseId, { onDelete: 'CASCADE' })
    @JoinColumn({ name: 'courseId' })
    @ApiProperty({
        description: 'Course this material belongs to',
        type: () => Course,
    })
    course: Course;

    @ManyToOne(() => User, { onDelete: 'RESTRICT' })
    @JoinColumn({ name: 'createdBy' })
    creator: User;

    @ManyToOne(() => User, { nullable: true })
    @JoinColumn({ name: 'updatedBy' })
    updater?: User;

    // Derived from course relations for caching purposes
    @ManyToOne(() => Organization, { nullable: false })
    @JoinColumn({ name: 'orgId' })
    @ApiProperty({
        description:
            'Organization this material belongs to (derived from course)',
        type: () => Organization,
    })
    orgId: Organization;

    @ManyToOne(() => Branch, { nullable: true })
    @JoinColumn({ name: 'branchId' })
    @ApiProperty({
        description: 'Branch this material belongs to (derived from course)',
        type: () => Branch,
        required: false,
    })
    branchId?: Branch;

    constructor(partial: Partial<CourseMaterial>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #96: CreateLeaderboardDto
 * Source: leaderboard/dto/create-leaderboard.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 6
 * Decorators: 12
 * Complexity: 27
 * Size: 1077 characters (48 lines)
 */
export class CreateLeaderboardDto {
    @ApiProperty({
        description: 'Course ID for this leaderboard entry',
        example: 1,
    })
    @IsNumber()
    courseId: number;

    @ApiProperty({
        description: 'User ID for this leaderboard entry',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @IsUUID()
    userId: string;

    @ApiProperty({
        description: 'User rank in the course leaderboard',
        example: 1,
        minimum: 1,
    })
    @IsNumber()
    rank: number;

    @ApiProperty({
        description: 'Average score across all tests in the course',
        example: 92.5,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    averageScore: number;

    @ApiProperty({
        description: 'Total number of tests completed in the course',
        example: 5,
        minimum: 0,
    })
    @IsNumber()
    testsCompleted: number;

    @ApiProperty({
        description: 'Total points earned across all tests',
        example: 462.5,
        minimum: 0,
    })
    @IsNumber()
    totalPoints: number;
}

/*
 * Class #97: LeaderboardFilterDto
 * Source: leaderboard/dto/leaderboard-filter.dto.ts:32
 * Type: Exported Class
 * Methods: 0
 * Properties: 47
 * Decorators: 66
 * Complexity: 155
 * Size: 3738 characters (164 lines)
 */
export class LeaderboardFilterDto {
    @ApiPropertyOptional({
        description: 'Page number for pagination',
        example: 1,
        minimum: 1,
    })
    @IsOptional()
    @IsNumber()
    @Min(1)
    @Type(() => Number)
    page?: number = 1;

    @ApiPropertyOptional({
        description: 'Number of items per page',
        example: 20,
        minimum: 1,
        maximum: 100,
    })
    @IsOptional()
    @IsNumber()
    @Min(1)
    @Max(100)
    @Type(() => Number)
    limit?: number = 20;

    @ApiPropertyOptional({
        description: 'Time period for leaderboard',
        enum: LeaderboardPeriod,
        example: LeaderboardPeriod.ALL_TIME,
    })
    @IsOptional()
    @IsEnum(LeaderboardPeriod)
    period?: LeaderboardPeriod = LeaderboardPeriod.ALL_TIME;

    @ApiPropertyOptional({
        description: 'Sort by field',
        enum: LeaderboardSortBy,
        example: LeaderboardSortBy.RANK,
    })
    @IsOptional()
    @IsEnum(LeaderboardSortBy)
    sortBy?: LeaderboardSortBy = LeaderboardSortBy.RANK;

    @ApiPropertyOptional({
        description: 'Sort order',
        enum: SortOrder,
        example: SortOrder.ASC,
    })
    @IsOptional()
    @IsEnum(SortOrder)
    sortOrder?: SortOrder = SortOrder.ASC;

    @ApiPropertyOptional({
        description: 'Filter by minimum score',
        example: 50,
        minimum: 0,
    })
    @IsOptional()
    @IsNumber()
    @Min(0)
    @Type(() => Number)
    minScore?: number;

    @ApiPropertyOptional({
        description: 'Filter by maximum score',
        example: 100,
        minimum: 0,
    })
    @IsOptional()
    @IsNumber()
    @Min(0)
    @Type(() => Number)
    maxScore?: number;

    @ApiPropertyOptional({
        description: 'Filter by minimum rank',
        example: 1,
        minimum: 1,
    })
    @IsOptional()
    @IsNumber()
    @Min(1)
    @Type(() => Number)
    minRank?: number;

    @ApiPropertyOptional({
        description: 'Filter by maximum rank',
        example: 50,
        minimum: 1,
    })
    @IsOptional()
    @IsNumber()
    @Min(1)
    @Type(() => Number)
    maxRank?: number;

    @ApiPropertyOptional({
        description: 'Filter by minimum number of tests completed',
        example: 3,
        minimum: 0,
    })
    @IsOptional()
    @IsNumber()
    @Min(0)
    @Type(() => Number)
    minTestsCompleted?: number;

    @ApiPropertyOptional({
        description: 'Search by user name (first or last name)',
        example: 'John',
    })
    @IsOptional()
    @IsString()
    searchName?: string;

    @ApiPropertyOptional({
        description: 'Search by user email',
        example: 'john@example.com',
    })
    @IsOptional()
    @IsString()
    searchEmail?: string;

    @ApiPropertyOptional({
        description: 'Filter by achievement level',
        enum: ['beginner', 'intermediate', 'advanced', 'expert'],
        example: 'intermediate',
    })
    @IsOptional()
    @IsString()
    achievementLevel?: string;

    @ApiPropertyOptional({
        description: 'Filter by activity after date',
        example: '2024-01-01T00:00:00.000Z',
    })
    @IsOptional()
    @IsDate()
    @Type(() => Date)
    activeAfter?: Date;

    @ApiPropertyOptional({
        description: 'Filter by activity before date',
        example: '2024-01-31T23:59:59.999Z',
    })
    @IsOptional()
    @IsDate()
    @Type(() => Date)
    activeBefore?: Date;

    @ApiPropertyOptional({
        description: 'Show only users with rank changes',
        example: true,
    })
    @IsOptional()
    showRankChangesOnly?: boolean;

    @ApiPropertyOptional({
        description: 'Show only active users (recent activity)',
        example: true,
    })
    @IsOptional()
    activeUsersOnly?: boolean;
}

/*
 * Class #98: LeaderboardEntryDto
 * Source: leaderboard/dto/leaderboard-list.dto.ts:5
 * Type: Exported Class
 * Methods: 0
 * Properties: 22
 * Decorators: 27
 * Complexity: 60
 * Size: 1975 characters (95 lines)
 */
export class LeaderboardEntryDto {
    @ApiProperty({
        description: 'Leaderboard entry ID',
        example: 1,
    })
    @IsNumber()
    leaderboardId: number;

    @ApiProperty({
        description: 'User ID',
        example: 'user-123',
    })
    @IsString()
    userId: string;

    @ApiProperty({
        description: 'User first name',
        example: 'John',
    })
    @IsString()
    firstName: string;

    @ApiProperty({
        description: 'User last name',
        example: 'Doe',
    })
    @IsString()
    lastName: string;

    @ApiProperty({
        description: 'User email',
        example: 'john.doe@example.com',
    })
    @IsString()
    email: string;

    @ApiProperty({
        description: 'Total score accumulated',
        example: 450,
    })
    @IsNumber()
    totalScore: number;

    @ApiProperty({
        description: 'Current rank in the course',
        example: 3,
    })
    @IsNumber()
    rank: number;

    @ApiProperty({
        description: 'Previous rank (for comparison)',
        example: 5,
    })
    @IsNumber()
    previousRank: number;

    @ApiProperty({
        description: 'Rank change (+/- from previous)',
        example: 2,
    })
    @IsNumber()
    rankChange: number;

    @ApiProperty({
        description: 'Number of tests completed',
        example: 8,
    })
    @IsNumber()
    testsCompleted: number;

    @ApiProperty({
        description: 'Average score across all tests',
        example: 85.5,
    })
    @IsNumber()
    averageScore: number;

    @ApiProperty({
        description: 'Last activity date',
        example: '2024-01-15T14:30:00.000Z',
    })
    @IsDate()
    @Type(() => Date)
    lastUpdated: Date;

    @ApiProperty({
        description:
            'Achievement level (beginner/intermediate/advanced/expert)',
        example: 'intermediate',
        enum: ['beginner', 'intermediate', 'advanced', 'expert'],
    })
    @IsString()
    achievementLevel: string;
}

/*
 * Class #99: LeaderboardMetaDto
 * Source: leaderboard/dto/leaderboard-list.dto.ts:101
 * Type: Exported Class
 * Methods: 0
 * Properties: 15
 * Decorators: 17
 * Complexity: 37
 * Size: 1291 characters (59 lines)
 */
export class LeaderboardMetaDto {
    @ApiProperty({
        description: 'Course ID',
        example: 1,
    })
    @IsNumber()
    courseId: number;

    @ApiProperty({
        description: 'Course title',
        example: 'Web Development Bootcamp',
    })
    @IsString()
    courseTitle: string;

    @ApiProperty({
        description: 'Total number of participants',
        example: 150,
    })
    @IsNumber()
    totalParticipants: number;

    @ApiProperty({
        description: 'Number of active participants (recent activity)',
        example: 120,
    })
    @IsNumber()
    activeParticipants: number;

    @ApiProperty({
        description: 'Average score across all participants',
        example: 75.2,
    })
    @IsNumber()
    averageScore: number;

    @ApiProperty({
        description: 'Highest score achieved',
        example: 98.5,
    })
    @IsNumber()
    topScore: number;

    @ApiProperty({
        description: 'Last leaderboard update',
        example: '2024-01-16T02:00:00.000Z',
    })
    @IsDate()
    @Type(() => Date)
    lastUpdated: Date;

    @ApiProperty({
        description: 'Competition period (week/month/all-time)',
        example: 'all-time',
        enum: ['week', 'month', 'all-time'],
    })
    @IsString()
    period: string;
}

/*
 * Class #100: LeaderboardListDto
 * Source: leaderboard/dto/leaderboard-list.dto.ts:161
 * Type: Exported Class
 * Methods: 0
 * Properties: 13
 * Decorators: 16
 * Complexity: 33
 * Size: 1241 characters (57 lines)
 */
export class LeaderboardListDto {
    @ApiProperty({
        description: 'Array of leaderboard entries',
        type: [LeaderboardEntryDto],
    })
    @ValidateNested({ each: true })
    @Type(() => LeaderboardEntryDto)
    entries: LeaderboardEntryDto[];

    @ApiProperty({
        description: 'Leaderboard metadata',
        type: LeaderboardMetaDto,
    })
    @ValidateNested()
    @Type(() => LeaderboardMetaDto)
    metadata: LeaderboardMetaDto;

    @ApiProperty({
        description: 'Total number of entries',
        example: 150,
    })
    @IsNumber()
    total: number;

    @ApiProperty({
        description: 'Current page number',
        example: 1,
    })
    @IsNumber()
    page: number;

    @ApiProperty({
        description: 'Number of entries per page',
        example: 20,
    })
    @IsNumber()
    limit: number;

    @ApiProperty({
        description: 'Total number of pages',
        example: 8,
    })
    @IsNumber()
    totalPages: number;

    @ApiProperty({
        description: 'Whether there is a next page',
        example: true,
    })
    hasNext: boolean;

    @ApiProperty({
        description: 'Whether there is a previous page',
        example: false,
    })
    hasPrevious: boolean;
}

/*
 * Class #101: UserInfo
 * Source: leaderboard/dto/leaderboard-response.dto.ts:4
 * Type: Internal Class
 * Methods: 0
 * Properties: 3
 * Decorators: 6
 * Complexity: 13
 * Size: 418 characters (22 lines)
 */
class UserInfo {
    @ApiProperty({
        description: 'User ID',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @Expose()
    id: string;

    @ApiProperty({
        description: 'Username',
        example: 'johndoe',
    })
    @Expose()
    username: string;

    @ApiProperty({
        description: 'User full name',
        example: 'John Doe',
    })
    @Expose()
    fullName: string;
}

/*
 * Class #102: CourseInfo
 * Source: leaderboard/dto/leaderboard-response.dto.ts:27
 * Type: Internal Class
 * Methods: 0
 * Properties: 3
 * Decorators: 6
 * Complexity: 13
 * Size: 461 characters (22 lines)
 */
class CourseInfo {
    @ApiProperty({
        description: 'Course ID',
        example: 1,
    })
    @Expose()
    courseId: number;

    @ApiProperty({
        description: 'Course title',
        example: 'Advanced Mathematics',
    })
    @Expose()
    title: string;

    @ApiProperty({
        description: 'Course description',
        example: 'Advanced mathematics course covering calculus and algebra',
    })
    @Expose()
    description: string;
}

/*
 * Class #103: LeaderboardResponseDto
 * Source: leaderboard/dto/leaderboard-response.dto.ts:50
 * Type: Exported Class
 * Methods: 0
 * Properties: 12
 * Decorators: 24
 * Complexity: 51
 * Size: 1993 characters (90 lines)
 */
export class LeaderboardResponseDto {
    @ApiProperty({
        description: 'Leaderboard entry unique identifier',
        example: 1,
    })
    @Expose()
    leaderboardId: number;

    @ApiProperty({
        description: 'Course ID for this leaderboard entry',
        example: 1,
    })
    @Expose()
    courseId: number;

    @ApiProperty({
        description: 'User ID for this leaderboard entry',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @Expose()
    userId: string;

    @ApiProperty({
        description: 'User rank in the course leaderboard',
        example: 1,
        minimum: 1,
    })
    @Expose()
    rank: number;

    @ApiProperty({
        description: 'Average score across all tests in the course',
        example: 92.5,
        minimum: 0,
        maximum: 100,
    })
    @Expose()
    averageScore: number;

    @ApiProperty({
        description: 'Total number of tests completed in the course',
        example: 5,
        minimum: 0,
    })
    @Expose()
    testsCompleted: number;

    @ApiProperty({
        description: 'Total points earned across all tests',
        example: 462.5,
        minimum: 0,
    })
    @Expose()
    totalPoints: number;

    @ApiProperty({
        description: 'When the leaderboard entry was last updated',
        example: '2024-01-01T12:00:00.000Z',
    })
    @Expose()
    lastUpdated: Date;

    @ApiProperty({
        description: 'Leaderboard entry creation timestamp',
        example: '2024-01-01T09:00:00.000Z',
    })
    @Expose()
    createdAt: Date;

    @ApiProperty({
        description: 'Leaderboard entry last update timestamp',
        example: '2024-01-01T12:00:00.000Z',
    })
    @Expose()
    updatedAt: Date;

    @ApiProperty({
        description: 'User information',
        type: UserInfo,
    })
    @Expose()
    user: UserInfo;

    @ApiProperty({
        description: 'Course information',
        type: CourseInfo,
    })
    @Expose()
    course: CourseInfo;
}

/*
 * Class #104: UpdateLeaderboardDto
 * Source: leaderboard/dto/update-leaderboard.dto.ts:4
 * Type: Exported Class
 * Methods: 1
 * Properties: 0
 * Decorators: 0
 * Complexity: 3
 * Size: 78 characters (1 lines)
 * Extends: PartialType(CreateLeaderboardDto)
 */
export class UpdateLeaderboardDto extends PartialType(CreateLeaderboardDto) {}

/*
 * Class #105: UserStatsResponseDto
 * Source: leaderboard/dto/user-stats-response.dto.ts:5
 * Type: Exported Class
 * Methods: 0
 * Properties: 6
 * Decorators: 12
 * Complexity: 25
 * Size: 1180 characters (51 lines)
 */
export class UserStatsResponseDto {
    @ApiProperty({
        description: 'Total points earned across all courses',
        example: 1250.75,
        minimum: 0,
    })
    @Expose()
    totalPoints: number;

    @ApiProperty({
        description: 'Total number of tests completed across all courses',
        example: 15,
        minimum: 0,
    })
    @Expose()
    totalTestsCompleted: number;

    @ApiProperty({
        description: 'Overall average score across all tests',
        example: 88.5,
        minimum: 0,
        maximum: 100,
    })
    @Expose()
    averageScore: number;

    @ApiProperty({
        description: 'Number of courses the user is enrolled in',
        example: 3,
        minimum: 0,
    })
    @Expose()
    coursesEnrolled: number;

    @ApiProperty({
        description: 'Best rank achieved across all courses',
        example: 2,
        minimum: 1,
        nullable: true,
    })
    @Expose()
    bestRank: number | null;

    @ApiProperty({
        description: 'Recent activity in the last 5 courses',
        type: [LeaderboardResponseDto],
        isArray: true,
    })
    @Expose()
    recentActivity: LeaderboardResponseDto[];
}

/*
 * Class #106: Leaderboard
 * Source: leaderboard/entities/leaderboard.entity.ts:24
 * Type: Exported Class
 * Methods: 0
 * Properties: 25
 * Decorators: 36
 * Complexity: 79
 * Size: 2691 characters (112 lines)
 */
export class Leaderboard {
    @PrimaryGeneratedColumn()
    @ApiProperty({
        description: 'Leaderboard entry unique identifier',
        example: 1,
    })
    leaderboardId: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Course ID for this leaderboard entry',
        example: 1,
    })
    @IsNumber()
    courseId: number;

    @Column('uuid')
    @Index()
    @ApiProperty({
        description: 'User ID for this leaderboard entry',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @IsUUID()
    userId: string;

    @Column()
    @Index()
    @ApiProperty({
        description: 'User rank in the course leaderboard',
        example: 1,
        minimum: 1,
    })
    @IsNumber()
    rank: number;

    @Column({ type: 'decimal', precision: 5, scale: 2 })
    @ApiProperty({
        description: 'Average score across all tests in the course',
        example: 92.5,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    averageScore: number;

    @Column()
    @ApiProperty({
        description: 'Total number of tests completed in the course',
        example: 5,
        minimum: 0,
    })
    @IsNumber()
    testsCompleted: number;

    @Column()
    @ApiProperty({
        description: 'Total points earned across all tests',
        example: 462.5,
        minimum: 0,
    })
    @IsNumber()
    totalPoints: number;

    @Column({ type: 'timestamp', default: () => 'NOW()' })
    @ApiProperty({
        description: 'When the leaderboard entry was last updated',
        example: '2024-01-01T12:00:00.000Z',
    })
    @IsDateString()
    lastUpdated: Date;

    @CreateDateColumn()
    @ApiProperty({
        description: 'Leaderboard entry creation timestamp',
        example: '2024-01-01T09:00:00.000Z',
    })
    createdAt: Date;

    @UpdateDateColumn()
    @ApiProperty({
        description: 'Leaderboard entry last update timestamp',
        example: '2024-01-01T12:00:00.000Z',
    })
    updatedAt: Date;

    @ManyToOne(() => Organization, { nullable: false })
    @ApiProperty({
        description: 'Organization this leaderboard entry belongs to',
        type: () => Organization,
    })
    orgId: Organization;

    @ManyToOne(() => Branch, { nullable: true })
    @ApiProperty({
        description: 'Branch this leaderboard entry belongs to',
        type: () => Branch,
        required: false,
    })
    branchId?: Branch;

    // Relations
    @ManyToOne(() => Course, { onDelete: 'CASCADE' })
    course: Course;

    @ManyToOne(() => User, { onDelete: 'RESTRICT' })
    user: User;

    constructor(partial: Partial<Leaderboard>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #107: LeaderboardController
 * Source: leaderboard/leaderboard.controller.ts:43
 * Type: Exported Class
 * Methods: 8
 * Properties: 231
 * Decorators: 31
 * Complexity: 102
 * Size: 17335 characters (461 lines)
 */
export class LeaderboardController {
    private readonly logger = new Logger(LeaderboardController.name);

    constructor(private readonly leaderboardService: LeaderboardService) {}

    @Get('course/:courseId')
    @ApiOperation({
        summary: '🥇 Get Course Leaderboard',
        description: `
        **Retrieves comprehensive leaderboard rankings for a specific course**
        
        This endpoint provides detailed competitive analytics and rankings including:
        - Student performance rankings
        - Score comparisons and statistics
        - Achievement levels and badges
        - Performance trends and insights
        - Participation metrics
        
        **Features:**
        - Paginated results for efficient loading
        - Real-time ranking calculations
        - Multiple sorting and filtering options
        - Performance analytics and insights
        - Achievement recognition system
        
        **Gamification Elements:**
        - Rank changes and improvements
        - Achievement levels (beginner to expert)
        - Performance badges and recognition
        - Competition periods and cycles
        - Social learning insights
        
        **Use Cases:**
        - Student motivation and engagement
        - Competitive learning environments
        - Performance tracking and analytics
        - Course effectiveness measurement
        - Social learning features
        `,
        operationId: 'getCourseLeaderboard',
    })
    @ApiParam({
        name: 'courseId',
        type: Number,
        description: 'Course identifier to retrieve leaderboard rankings',
        example: 1,
    })
    @ApiQuery({
        name: 'page',
        type: Number,
        description: 'Page number for pagination (starting from 1)',
        required: false,
        example: 1,
    })
    @ApiQuery({
        name: 'limit',
        type: Number,
        description: 'Number of leaderboard entries per page (max 100)',
        required: false,
        example: 20,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course leaderboard retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: {
                    type: 'string',
                    example: 'Leaderboard retrieved successfully',
                },
                data: {
                    type: 'object',
                    properties: {
                        entries: {
                            type: 'array',
                            description: 'Leaderboard entries with rankings',
                            items: {
                                type: 'object',
                                properties: {
                                    leaderboardId: {
                                        type: 'number',
                                        example: 1,
                                    },
                                    userId: {
                                        type: 'string',
                                        example: 'user-123',
                                    },
                                    firstName: {
                                        type: 'string',
                                        example: 'John',
                                    },
                                    lastName: {
                                        type: 'string',
                                        example: 'Doe',
                                    },
                                    email: {
                                        type: 'string',
                                        example: 'brandon@orrbit.co.za',
                                    },
                                    totalScore: {
                                        type: 'number',
                                        example: 450,
                                    },
                                    rank: { type: 'number', example: 3 },
                                    previousRank: {
                                        type: 'number',
                                        example: 5,
                                    },
                                    rankChange: { type: 'number', example: 2 },
                                    testsCompleted: {
                                        type: 'number',
                                        example: 8,
                                    },
                                    averageScore: {
                                        type: 'number',
                                        example: 85.5,
                                    },
                                    achievementLevel: {
                                        type: 'string',
                                        example: 'intermediate',
                                    },
                                },
                            },
                        },
                        metadata: {
                            type: 'object',
                            properties: {
                                courseId: { type: 'number', example: 1 },
                                courseTitle: {
                                    type: 'string',
                                    example: 'Web Development Bootcamp',
                                },
                                totalParticipants: {
                                    type: 'number',
                                    example: 150,
                                },
                                activeParticipants: {
                                    type: 'number',
                                    example: 120,
                                },
                                averageScore: { type: 'number', example: 75.2 },
                                topScore: { type: 'number', example: 98.5 },
                            },
                        },
                        total: { type: 'number', example: 150 },
                        page: { type: 'number', example: 1 },
                        limit: { type: 'number', example: 20 },
                        totalPages: { type: 'number', example: 8 },
                    },
                },
            },
        },
    })
    @ApiUnauthorizedResponse({
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiBadRequestResponse({
        description: '❌ Invalid course ID or pagination parameters',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: { type: 'string', example: 'Invalid course ID' },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiNotFoundResponse({
        description: '❌ Course not found or no leaderboard data available',
    })
    async getCourseLeaderboard(
        @Param('courseId', ParseIntPipe) courseId: number,
        @Query('page') page: number = 1,
        @Query('limit') limit: number = 10,
        @OrgBranchScope() scope: OrgBranchScope,
    ) {
        this.logger.log(
            `Getting leaderboard for course: ${courseId}, page: ${page}, limit: ${limit}, user: ${scope.userId}`,
        );

        if (!courseId || courseId <= 0) {
            throw new BadRequestException('Invalid course ID');
        }

        if (limit > 100) {
            limit = 100;
        }

        return this.leaderboardService.getCourseLeaderboard(
            courseId,
            page,
            limit,
        );
    }

    @Get('my-rank/:courseId')
    @ApiOperation({
        summary: '🎯 Get My Course Rank',
        description: `
        **Retrieves the authenticated user's current ranking and performance in a course**
        
        This endpoint provides personalized ranking information including:
        - Current position in course leaderboard
        - Performance metrics and statistics
        - Rank change history and trends
        - Achievement level and progress
        - Comparative performance analysis
        
        **Personal Analytics:**
        - Individual rank and position
        - Score progression over time
        - Performance compared to course average
        - Achievement milestones reached
        - Areas for improvement identification
        
        **Motivational Features:**
        - Rank improvement tracking
        - Achievement recognition
        - Goal setting and progress monitoring
        - Peer comparison insights
        - Personalized recommendations
        
        **Use Cases:**
        - Personal progress tracking
        - Motivation and goal setting
        - Performance self-assessment
        - Learning path optimization
        - Achievement recognition
        `,
        operationId: 'getMyRankInCourse',
    })
    @ApiParam({
        name: 'courseId',
        type: Number,
        description: 'Course identifier to get user ranking',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ User rank retrieved successfully',
        type: LeaderboardResponseDto,
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: {
                    type: 'string',
                    example: 'User rank retrieved successfully',
                },
                data: {
                    type: 'object',
                    properties: {
                        leaderboardId: { type: 'number', example: 1 },
                        courseId: { type: 'number', example: 1 },
                        userId: { type: 'string', example: 'user-123' },
                        rank: { type: 'number', example: 15 },
                        totalScore: { type: 'number', example: 420 },
                        averageScore: { type: 'number', example: 84.0 },
                        testsCompleted: { type: 'number', example: 5 },
                        totalPoints: { type: 'number', example: 420 },
                        lastUpdated: {
                            type: 'string',
                            example: '2024-01-15T14:30:00.000Z',
                        },
                        user: {
                            type: 'object',
                            properties: {
                                id: { type: 'string', example: 'user-123' },
                                username: {
                                    type: 'string',
                                    example: 'johndoe',
                                },
                                fullName: {
                                    type: 'string',
                                    example: 'John Doe',
                                },
                            },
                        },
                        course: {
                            type: 'object',
                            properties: {
                                courseId: { type: 'number', example: 1 },
                                title: {
                                    type: 'string',
                                    example: 'Web Development Bootcamp',
                                },
                                description: {
                                    type: 'string',
                                    example: 'Complete web development course',
                                },
                            },
                        },
                    },
                },
            },
        },
    })
    @ApiUnauthorizedResponse({
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiBadRequestResponse({
        description: '❌ Invalid course ID',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: { type: 'string', example: 'Invalid course ID' },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiNotFoundResponse({
        description:
            '❌ User not found in course leaderboard or course does not exist',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: false },
                message: {
                    type: 'string',
                    example: 'User not found in course leaderboard',
                },
            },
        },
    })
    async getUserRank(
        @Param('courseId', ParseIntPipe) courseId: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<LeaderboardResponseDto | null> {
        this.logger.log(
            `Getting user rank for course: ${courseId}, user: ${scope.userId}`,
        );

        if (!courseId || courseId <= 0) {
            throw new BadRequestException('Invalid course ID');
        }

        return this.leaderboardService.getUserRank(courseId, scope.userId);
    }

    @Post('refresh/:courseId')
    @ApiOperation({
        summary: '🔄 Refresh Course Leaderboard',
        description: `
        **Recalculates and updates the leaderboard rankings for a specific course**
        
        This endpoint handles comprehensive leaderboard refresh including:
        - Real-time score recalculation
        - Rank position updates
        - Performance statistics refresh
        - Achievement level reassessment
        - Historical data consistency
        
        **Administrative Features:**
        - Manual leaderboard refresh triggers
        - Data consistency maintenance
        - Performance recalculation
        - Ranking algorithm updates
        - System maintenance support
        
        **Technical Operations:**
        - Aggregated score calculations
        - Rank position algorithms
        - Achievement level determination
        - Performance metrics updates
        - Cache invalidation and refresh
        
        **Access Control:**
        - Restricted to administrators and instructors
        - Course ownership validation
        - Permission-based access control
        - Audit logging for changes
        
        **Use Cases:**
        - Administrative maintenance
        - Data consistency fixes
        - Performance optimization
        - System updates and patches
        - Manual ranking corrections
        `,
        operationId: 'refreshCourseLeaderboard',
    })
    @ApiParam({
        name: 'courseId',
        type: Number,
        description: 'Course identifier for leaderboard refresh',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Leaderboard refreshed successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: {
                    type: 'string',
                    example: 'Leaderboard refreshed successfully',
                },
                data: {
                    type: 'object',
                    properties: {
                        courseId: { type: 'number', example: 1 },
                        updatedEntries: { type: 'number', example: 45 },
                        refreshedAt: {
                            type: 'string',
                            example: '2024-01-15T14:30:00.000Z',
                        },
                        processingTime: { type: 'number', example: 1.25 },
                    },
                },
            },
        },
    })
    @ApiUnauthorizedResponse({
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiForbiddenResponse({
        description:
            '🚷 Forbidden - Insufficient permissions to refresh leaderboard',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 403 },
                message: {
                    type: 'string',
                    example: 'Insufficient permissions',
                },
                error: { type: 'string', example: 'Forbidden' },
            },
        },
    })
    @ApiBadRequestResponse({
        description: '❌ Invalid course ID',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: { type: 'string', example: 'Invalid course ID' },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    async refreshLeaderboard(
        @Param('courseId', ParseIntPipe) courseId: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<{ message: string }> {
        this.logger.log(
            `Refreshing leaderboard for course: ${courseId} by user: ${scope.userId}`,
        );

        if (!courseId || courseId <= 0) {
            throw new BadRequestException('Invalid course ID');
        }

        await this.leaderboardService.updateLeaderboard(courseId);
        return { message: 'Leaderboard refreshed successfully' };
    }
}

/*
 * Class #108: LeaderboardModule
 * Source: leaderboard/leaderboard.module.ts:14
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 33 characters (1 lines)
 */
export class LeaderboardModule {}

/*
 * Class #109: LeaderboardService
 * Source: leaderboard/leaderboard.service.ts:11
 * Type: Exported Class
 * Methods: 18
 * Properties: 50
 * Decorators: 2
 * Complexity: 132
 * Size: 10991 characters (299 lines)
 */
export class LeaderboardService {
    constructor(
        @InjectRepository(Leaderboard)
        private readonly leaderboardRepository: Repository<Leaderboard>,
        @InjectRepository(Result)
        private readonly resultRepository: Repository<Result>,
    ) {}

    async getCourseLeaderboard(
        courseId: number,
        page: number = 1,
        limit: number = 10,
    ): Promise<{
        leaderboard: LeaderboardResponseDto[];
        total: number;
        page: number;
        limit: number;
    }> {
        try {
            const skip = (page - 1) * limit;

            const [leaderboardEntries, total] = await this.leaderboardRepository
                .createQueryBuilder('leaderboard')
                .leftJoinAndSelect('leaderboard.user', 'user')
                .leftJoinAndSelect('leaderboard.course', 'course')
                .where('leaderboard.courseId = :courseId', { courseId })
                .orderBy('leaderboard.rank', 'ASC')
                .skip(skip)
                .take(limit)
                .getManyAndCount();

            const responseLeaderboard = leaderboardEntries.map(entry =>
                plainToClass(LeaderboardResponseDto, entry, {
                    excludeExtraneousValues: true,
                }),
            );

            return {
                leaderboard: responseLeaderboard,
                total,
                page,
                limit,
            };
        } catch (_error) {
            throw new InternalServerErrorException(
                'Failed to fetch course leaderboard',
            );
        }
    }

    async getUserRank(
        courseId: number,
        userId: string,
    ): Promise<LeaderboardResponseDto | null> {
        try {
            const leaderboardEntry = await this.leaderboardRepository
                .createQueryBuilder('leaderboard')
                .leftJoinAndSelect('leaderboard.user', 'user')
                .leftJoinAndSelect('leaderboard.course', 'course')
                .where('leaderboard.courseId = :courseId', { courseId })
                .andWhere('leaderboard.userId = :userId', { userId })
                .getOne();

            if (!leaderboardEntry) {
                return null;
            }

            return plainToClass(LeaderboardResponseDto, leaderboardEntry, {
                excludeExtraneousValues: true,
            });
        } catch (_error) {
            throw new InternalServerErrorException('Failed to fetch user rank');
        }
    }

    async updateLeaderboard(courseId: number): Promise<void> {
        try {
            // Get all results for the course
            const results = await this.resultRepository
                .createQueryBuilder('result')
                .where('result.courseId = :courseId', { courseId })
                .getMany();

            // Group results by user
            const userStats = new Map<
                string,
                {
                    totalPoints: number;
                    testsCompleted: number;
                    averageScore: number;
                }
            >();

            results.forEach(result => {
                const userId = result.userId;
                const existing = userStats.get(userId) || {
                    totalPoints: 0,
                    testsCompleted: 0,
                    averageScore: 0,
                };

                existing.totalPoints += Number(result.score);
                existing.testsCompleted += 1;
                existing.averageScore =
                    existing.totalPoints / existing.testsCompleted;

                userStats.set(userId, existing);
            });

            // Sort users by average score (descending)
            const sortedUsers = Array.from(userStats.entries()).sort(
                (a, b) => b[1].averageScore - a[1].averageScore,
            );

            // Clear existing leaderboard for this course
            await this.leaderboardRepository.delete({ courseId });

            // Create new leaderboard entries
            const leaderboardEntries: CreateLeaderboardDto[] = sortedUsers.map(
                ([userId, stats], index) => ({
                    courseId,
                    userId,
                    rank: index + 1,
                    averageScore: Math.round(stats.averageScore * 100) / 100,
                    testsCompleted: stats.testsCompleted,
                    totalPoints: Math.round(stats.totalPoints * 100) / 100,
                }),
            );

            if (leaderboardEntries.length > 0) {
                const entities = leaderboardEntries.map(dto =>
                    this.leaderboardRepository.create(dto),
                );
                await this.leaderboardRepository.save(entities);
            }
        } catch (error) {
            throw new InternalServerErrorException(
                'Failed to update leaderboard',
            );
        }
    }

    async updateUserScore(courseId: number, userId: string): Promise<void> {
        try {
            // Get user's results for the course
            const userResults = await this.resultRepository
                .createQueryBuilder('result')
                .where('result.courseId = :courseId', { courseId })
                .andWhere('result.userId = :userId', { userId })
                .getMany();

            if (userResults.length === 0) {
                // Remove user from leaderboard if no results
                await this.leaderboardRepository.delete({ courseId, userId });
                return;
            }

            // Calculate user stats
            const totalPoints = userResults.reduce(
                (sum, result) => sum + Number(result.score),
                0,
            );
            const testsCompleted = userResults.length;
            const averageScore = totalPoints / testsCompleted;

            // Find or create leaderboard entry
            let leaderboardEntry = await this.leaderboardRepository.findOne({
                where: { courseId, userId },
                relations: ['user', 'course'],
            });

            if (leaderboardEntry) {
                // Update existing entry
                leaderboardEntry.averageScore =
                    Math.round(averageScore * 100) / 100;
                leaderboardEntry.testsCompleted = testsCompleted;
                leaderboardEntry.totalPoints =
                    Math.round(totalPoints * 100) / 100;
                leaderboardEntry.lastUpdated = new Date();
            } else {
                // Create new entry with temporary rank
                const createDto: CreateLeaderboardDto = {
                    courseId,
                    userId,
                    rank: 999999, // Temporary rank, will be updated when recalculating ranks
                    averageScore: Math.round(averageScore * 100) / 100,
                    testsCompleted,
                    totalPoints: Math.round(totalPoints * 100) / 100,
                };
                leaderboardEntry = this.leaderboardRepository.create(createDto);
            }

            await this.leaderboardRepository.save(leaderboardEntry);

            // Recalculate ranks for the course
            await this.recalculateRanks(courseId);
        } catch (error) {
            throw new InternalServerErrorException(
                'Failed to update user score',
            );
        }
    }

    private async recalculateRanks(courseId: number): Promise<void> {
        // Get all leaderboard entries for the course, sorted by average score
        const entries = await this.leaderboardRepository
            .createQueryBuilder('leaderboard')
            .where('leaderboard.courseId = :courseId', { courseId })
            .orderBy('leaderboard.averageScore', 'DESC')
            .addOrderBy('leaderboard.totalPoints', 'DESC')
            .getMany();

        // Update ranks
        for (let i = 0; i < entries.length; i++) {
            entries[i].rank = i + 1;
        }

        if (entries.length > 0) {
            await this.leaderboardRepository.save(entries);
        }
    }

    async getUserOverallStats(userId: string): Promise<{
        totalPoints: number;
        totalTestsCompleted: number;
        averageScore: number;
        coursesEnrolled: number;
        bestRank: number | null;
        recentActivity: LeaderboardResponseDto[];
    }> {
        try {
            // Get all leaderboard entries for the user
            const userLeaderboardEntries = await this.leaderboardRepository
                .createQueryBuilder('leaderboard')
                .leftJoinAndSelect('leaderboard.user', 'user')
                .leftJoinAndSelect('leaderboard.course', 'course')
                .where('leaderboard.userId = :userId', { userId })
                .orderBy('leaderboard.lastUpdated', 'DESC')
                .getMany();

            if (userLeaderboardEntries.length === 0) {
                return {
                    totalPoints: 0,
                    totalTestsCompleted: 0,
                    averageScore: 0,
                    coursesEnrolled: 0,
                    bestRank: null,
                    recentActivity: [],
                };
            }

            // Calculate overall stats
            const totalPoints = userLeaderboardEntries.reduce(
                (sum, entry) => sum + Number(entry.totalPoints),
                0,
            );
            const totalTestsCompleted = userLeaderboardEntries.reduce(
                (sum, entry) => sum + entry.testsCompleted,
                0,
            );
            const averageScore =
                totalTestsCompleted > 0
                    ? userLeaderboardEntries.reduce(
                          (sum, entry) =>
                              sum +
                              Number(entry.averageScore) * entry.testsCompleted,
                          0,
                      ) / totalTestsCompleted
                    : 0;

            const coursesEnrolled = userLeaderboardEntries.length;
            const bestRank = Math.min(
                ...userLeaderboardEntries.map(entry => entry.rank),
            );

            // Get recent activity (last 5 courses with activity)
            const recentActivity = userLeaderboardEntries
                .slice(0, 5)
                .map(entry =>
                    plainToClass(LeaderboardResponseDto, entry, {
                        excludeExtraneousValues: true,
                    }),
                );

            return {
                totalPoints: Math.round(totalPoints * 100) / 100,
                totalTestsCompleted,
                averageScore: Math.round(averageScore * 100) / 100,
                coursesEnrolled,
                bestRank,
                recentActivity,
            };
        } catch (error) {
            throw new InternalServerErrorException(
                'Failed to fetch user overall stats',
            );
        }
    }
}

/*
 * Class #110: MediaFileResponseDto
 * Source: media-manager/dto/media-response.dto.ts:5
 * Type: Exported Class
 * Methods: 0
 * Properties: 54
 * Decorators: 20
 * Complexity: 72
 * Size: 6606 characters (224 lines)
 */
/**
 * Response DTO representing a complete media file with all associated metadata and processing information
 * Used in all API responses that return file data, including upload confirmations and file listings
 */
export class MediaFileResponseDto {
    @ApiProperty({
        description: 'Unique identifier for the media file in the database',
        example: 1,
        type: Number,
        title: 'File ID',
        minimum: 1,
    })
    id: number;

    @ApiProperty({
        description:
            'Original filename as uploaded by the user, preserved for reference and display purposes',
        example: 'course-introduction-image.jpg',
        type: String,
        title: 'Original Filename',
        maxLength: 255,
    })
    originalName: string;

    @ApiProperty({
        description:
            'Processed filename stored in Google Cloud Storage with organization, date, and UUID for uniqueness',
        example:
            'media/org-123/branch-456/2024/01/15/a1b2c3d4-e5f6-course-introduction-image.jpg',
        type: String,
        title: 'Stored Filename',
        maxLength: 500,
    })
    filename: string;

    @ApiProperty({
        description:
            'Full public URL for direct access to the file in Google Cloud Storage',
        example:
            'https://storage.googleapis.com/crmapplications/media/org-123/branch-456/2024/01/15/a1b2c3d4-e5f6-course-introduction-image.jpg',
        type: String,
        title: 'File URL',
        format: 'url',
    })
    url: string;

    @ApiProperty({
        description:
            'MIME type of the file for proper browser handling and content type detection',
        example: 'image/jpeg',
        type: String,
        title: 'MIME Type',
        pattern:
            '^[a-zA-Z0-9][a-zA-Z0-9!#$&\\-\\^_]*/[a-zA-Z0-9][a-zA-Z0-9!#$&\\-\\^_.]*$',
    })
    mimeType: string;

    @ApiProperty({
        description:
            'File size in bytes for storage tracking and download estimates',
        example: 2048576,
        type: Number,
        title: 'File Size (bytes)',
        minimum: 0,
        maximum: 52428800, // 50MB
    })
    size: number;

    @ApiProperty({
        description:
            'Categorized media type for organization and processing logic',
        enum: MediaType,
        example: MediaType.IMAGE,
        type: String,
        title: 'Media Type',
        enumName: 'MediaType',
    })
    type: MediaType;

    @ApiProperty({
        description:
            'Specific variant of the image for different display contexts and sizes',
        enum: ImageVariant,
        example: ImageVariant.ORIGINAL,
        required: false,
        type: String,
        title: 'Image Variant',
        enumName: 'ImageVariant',
    })
    variant?: ImageVariant;

    @ApiProperty({
        description:
            'Reference to the original file ID for image variants and thumbnails',
        example: 1,
        required: false,
        type: Number,
        title: 'Original File Reference',
        minimum: 1,
    })
    originalFileId?: number;

    @ApiProperty({
        description:
            'Image width in pixels for layout planning and responsive design',
        example: 1920,
        required: false,
        type: Number,
        title: 'Image Width (px)',
        minimum: 1,
        maximum: 10000,
    })
    width?: number;

    @ApiProperty({
        description:
            'Image height in pixels for layout planning and responsive design',
        example: 1080,
        required: false,
        type: Number,
        title: 'Image Height (px)',
        minimum: 1,
        maximum: 10000,
    })
    height?: number;

    @ApiProperty({
        description:
            'Indicates if the file is active and available for access (soft delete mechanism)',
        example: true,
        type: Boolean,
        title: 'Active Status',
        default: true,
    })
    isActive: boolean;

    @ApiProperty({
        description:
            'Alternative text for images to improve accessibility compliance and SEO',
        example:
            'Computer Science course introduction showing programming concepts and student collaboration',
        required: false,
        type: String,
        title: 'Alt Text',
        maxLength: 255,
    })
    altText?: string;

    @ApiProperty({
        description:
            'Detailed description or caption for the file, used in content management and search',
        example:
            'Introduction image for Computer Science fundamentals course showing key programming concepts',
        required: false,
        type: String,
        title: 'File Description',
        maxLength: 1000,
    })
    description?: string;

    @ApiProperty({
        description:
            'Additional metadata including EXIF data, processing information, and custom properties',
        example: {
            exif: { camera: 'Canon EOS R5', iso: 100 },
            processing: { quality: 85, format: 'jpeg' },
            custom: { tags: ['course', 'education'] },
        },
        required: false,
        type: Object,
        title: 'File Metadata',
    })
    metadata?: Record<string, any>;

    @ApiProperty({
        description:
            'UUID of the user who uploaded this file for ownership tracking and permissions',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
        type: String,
        title: 'Uploader ID',
        format: 'uuid',
        minLength: 36,
        maxLength: 36,
    })
    uploadedBy: string;

    @ApiProperty({
        description:
            'Timestamp when the file was originally uploaded to the system',
        example: '2024-01-01T00:00:00.000Z',
        type: String,
        title: 'Upload Date',
        format: 'date-time',
    })
    createdAt: Date;

    @ApiProperty({
        description: 'Timestamp when the file metadata was last updated',
        example: '2024-01-15T10:30:45.123Z',
        type: String,
        title: 'Last Updated',
        format: 'date-time',
    })
    updatedAt: Date;

    @ApiProperty({
        description:
            'Complete user profile information of the person who uploaded this file',
        type: () => User,
        required: false,
        title: 'Uploader Details',
    })
    uploader?: User;

    @ApiProperty({
        description:
            'All available image variants (thumbnails, different sizes) generated from the original image',
        type: [MediaFileResponseDto],
        required: false,
        title: 'Image Variants',
        isArray: true,
    })
    variants?: MediaFileResponseDto[];
}

/*
 * Class #111: MediaFileListResponseDto
 * Source: media-manager/dto/media-response.dto.ts:230
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 5
 * Complexity: 11
 * Size: 640 characters (31 lines)
 */
export class MediaFileListResponseDto {
    @ApiProperty({
        description: 'List of media files',
        type: [MediaFileResponseDto],
    })
    files: MediaFileResponseDto[];

    @ApiProperty({
        description: 'Total number of files',
        example: 100,
    })
    total: number;

    @ApiProperty({
        description: 'Current page number',
        example: 1,
    })
    page: number;

    @ApiProperty({
        description: 'Number of files per page',
        example: 20,
    })
    limit: number;

    @ApiProperty({
        description: 'Total number of pages',
        example: 5,
    })
    totalPages: number;
}

/*
 * Class #112: UploadResponseDto
 * Source: media-manager/dto/media-response.dto.ts:262
 * Type: Exported Class
 * Methods: 0
 * Properties: 2
 * Decorators: 2
 * Complexity: 8
 * Size: 748 characters (23 lines)
 */
/**
 * Response DTO for successful file upload containing the main file and any generated variants
 * Used as the primary response for single file upload operations
 */
export class UploadResponseDto {
    @ApiProperty({
        description:
            'The main uploaded file with complete metadata and processing information',
        type: MediaFileResponseDto,
        title: 'Uploaded File',
    })
    file: MediaFileResponseDto;

    @ApiProperty({
        description:
            'Automatically generated image variants including thumbnails, medium, and large sizes',
        type: [MediaFileResponseDto],
        required: false,
        title: 'Generated Variants',
        isArray: true,
    })
    variants?: MediaFileResponseDto[];
}

/*
 * Class #113: BulkUploadResponseDto
 * Source: media-manager/dto/media-response.dto.ts:286
 * Type: Exported Class
 * Methods: 0
 * Properties: 7
 * Decorators: 5
 * Complexity: 11
 * Size: 864 characters (39 lines)
 */
export class BulkUploadResponseDto {
    @ApiProperty({
        description: 'Successfully uploaded files',
        type: [UploadResponseDto],
    })
    uploaded: UploadResponseDto[];

    @ApiProperty({
        description: 'Failed uploads with error messages',
        example: [
            {
                filename: 'invalid-file.txt',
                error: 'Unsupported file type',
            },
        ],
    })
    errors: Array<{
        filename: string;
        error: string;
    }>;

    @ApiProperty({
        description: 'Total number of files processed',
        example: 5,
    })
    total: number;

    @ApiProperty({
        description: 'Number of successful uploads',
        example: 4,
    })
    successful: number;

    @ApiProperty({
        description: 'Number of failed uploads',
        example: 1,
    })
    failed: number;
}

/*
 * Class #114: MediaStatsDto
 * Source: media-manager/dto/media-response.dto.ts:326
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 5
 * Complexity: 12
 * Size: 838 characters (38 lines)
 */
export class MediaStatsDto {
    @ApiProperty({
        description: 'Total number of files',
        example: 150,
    })
    totalFiles: number;

    @ApiProperty({
        description: 'Total storage used in bytes',
        example: 52428800,
    })
    totalSize: number;

    @ApiProperty({
        description: 'Number of files by type',
        example: {
            image: 120,
            document: 25,
            video: 3,
            audio: 1,
            other: 1,
        },
    })
    byType: Record<MediaType, number>;

    @ApiProperty({
        description: 'Average file size in bytes',
        example: 349525,
    })
    averageSize: number;

    @ApiProperty({
        description: 'Most recent upload timestamp',
        example: '2024-01-15T10:30:45.123Z',
        required: false,
    })
    lastUpload?: Date;
}

/*
 * Class #115: UploadFileDto
 * Source: media-manager/dto/upload-file.dto.ts:14
 * Type: Exported Class
 * Methods: 1
 * Properties: 20
 * Decorators: 20
 * Complexity: 66
 * Size: 3513 characters (94 lines)
 */
/**
 * Data Transfer Object for single file upload with comprehensive metadata and processing options
 * Used for uploading files to Google Cloud Storage with automatic processing and variant generation
 */
export class UploadFileDto {
    @ApiProperty({
        description:
            'Alternative text description for images to improve accessibility and SEO compliance. This text is used by screen readers and when images fail to load.',
        example:
            'Computer Science course introduction illustration showing students learning programming concepts',
        required: false,
        type: String,
        title: 'Alt Text',
        maxLength: 255,
        minLength: 3,
    })
    @IsOptional()
    @IsString({ message: 'Alt text must be a valid string' })
    @MaxLength(255, { message: 'Alt text must not exceed 255 characters' })
    altText?: string;

    @ApiProperty({
        description:
            'Detailed description or caption for the uploaded file. Used for content management, search, and file organization purposes.',
        example:
            'Introduction image for Computer Science fundamentals course showing key programming concepts and methodologies',
        required: false,
        type: String,
        title: 'File Description',
        maxLength: 1000,
        minLength: 5,
    })
    @IsOptional()
    @IsString({ message: 'Description must be a valid string' })
    @MaxLength(1000, { message: 'Description must not exceed 1000 characters' })
    description?: string;

    @ApiProperty({
        description:
            'Media type classification for automatic processing and organization. If not specified, type will be auto-detected from file MIME type.',
        enum: MediaType,
        example: MediaType.IMAGE,
        required: false,
        type: String,
        title: 'Media Type',
        enumName: 'MediaType',
    })
    @IsOptional()
    @IsEnum(MediaType, {
        message:
            'Invalid media type. Must be one of: image, document, video, audio, other',
    })
    type?: MediaType;

    @ApiProperty({
        description:
            'Enable automatic thumbnail and variant generation for images. When enabled, creates optimized versions suitable for different display contexts.',
        example: true,
        required: false,
        default: true,
        type: Boolean,
        title: 'Generate Thumbnails',
    })
    @IsOptional()
    @IsBoolean({ message: 'Generate thumbnails must be a boolean value' })
    @Transform(({ value }) => {
        if (typeof value === 'string') {
            return value.toLowerCase() === 'true';
        }
        return Boolean(value);
    })
    generateThumbnails?: boolean = true;

    @ApiProperty({
        description:
            'Specific image variants to generate. Each variant is optimized for different use cases: thumbnail (150x150) for lists, medium (500x500) for content, large (1200x1200) for detailed viewing.',
        enum: ImageVariant,
        isArray: true,
        example: [ImageVariant.THUMBNAIL, ImageVariant.MEDIUM],
        required: false,
        type: [String],
        title: 'Image Variants',
        enumName: 'ImageVariant',
    })
    @IsOptional()
    @IsArray({ message: 'Variants must be an array' })
    @IsEnum(ImageVariant, {
        each: true,
        message:
            'Invalid image variant. Must be one of: original, thumbnail, medium, large',
    })
    @ValidateIf(obj => obj.type === MediaType.IMAGE)
    variants?: ImageVariant[];
}

/*
 * Class #116: BulkUploadDto
 * Source: media-manager/dto/upload-file.dto.ts:109
 * Type: Exported Class
 * Methods: 1
 * Properties: 10
 * Decorators: 12
 * Complexity: 38
 * Size: 2192 characters (60 lines)
 */
/**
 * Data Transfer Object for bulk file upload with shared metadata across multiple files
 * Used for uploading multiple files simultaneously with common processing options
 */
export class BulkUploadDto {
    @ApiProperty({
        description:
            'Common alternative text applied to all uploaded images in the batch. Improves accessibility and provides consistent metadata across related files.',
        example:
            'Course materials and resources for Computer Science fundamentals',
        required: false,
        type: String,
        title: 'Common Alt Text',
        maxLength: 255,
        minLength: 3,
    })
    @IsOptional()
    @IsString({ message: 'Common alt text must be a valid string' })
    @MaxLength(255, {
        message: 'Common alt text must not exceed 255 characters',
    })
    commonAltText?: string;

    @ApiProperty({
        description:
            'Common description applied to all uploaded files in the batch. Used for organizing and categorizing related file uploads.',
        example:
            'Comprehensive course resource materials including presentations, diagrams, and reference documents for Computer Science fundamentals',
        required: false,
        type: String,
        title: 'Common Description',
        maxLength: 1000,
        minLength: 5,
    })
    @IsOptional()
    @IsString({ message: 'Common description must be a valid string' })
    @MaxLength(1000, {
        message: 'Common description must not exceed 1000 characters',
    })
    commonDescription?: string;

    @ApiProperty({
        description:
            'Enable automatic thumbnail and variant generation for all image uploads in the batch. Applies consistent processing across all files.',
        example: true,
        required: false,
        default: true,
        type: Boolean,
        title: 'Generate Thumbnails',
    })
    @IsOptional()
    @IsBoolean({ message: 'Generate thumbnails must be a boolean value' })
    @Transform(({ value }) => {
        if (typeof value === 'string') {
            return value.toLowerCase() === 'true';
        }
        return Boolean(value);
    })
    generateThumbnails?: boolean = true;
}

/*
 * Class #117: FileFilterDto
 * Source: media-manager/dto/upload-file.dto.ts:170
 * Type: Exported Class
 * Methods: 0
 * Properties: 25
 * Decorators: 27
 * Complexity: 87
 * Size: 4571 characters (140 lines)
 */
/**
 * Data Transfer Object for filtering and searching media files with comprehensive query options
 * Used for advanced file discovery, pagination, and organization-based file management
 */
export class FileFilterDto {
    @ApiProperty({
        description:
            'Filter files by media type classification. Useful for browsing specific content types like images for galleries or documents for resources.',
        enum: MediaType,
        example: MediaType.IMAGE,
        required: false,
        type: String,
        title: 'Media Type Filter',
        enumName: 'MediaType',
    })
    @IsOptional()
    @IsEnum(MediaType, {
        message:
            'Invalid media type filter. Must be one of: image, document, video, audio, other',
    })
    type?: MediaType;

    @ApiProperty({
        description:
            'Filter images by specific variant size. Useful for finding thumbnails for lists or original images for detailed viewing.',
        enum: ImageVariant,
        example: ImageVariant.THUMBNAIL,
        required: false,
        type: String,
        title: 'Image Variant Filter',
        enumName: 'ImageVariant',
    })
    @IsOptional()
    @IsEnum(ImageVariant, {
        message:
            'Invalid image variant filter. Must be one of: original, thumbnail, medium, large',
    })
    variant?: ImageVariant;

    @ApiProperty({
        description:
            'Filter files by the specific user who uploaded them. Use for personal file management or administrative oversight.',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
        required: false,
        type: String,
        title: 'Uploader User ID',
        format: 'uuid',
        minLength: 36,
        maxLength: 36,
    })
    @IsOptional()
    @IsString({ message: 'Uploader ID must be a valid string' })
    uploadedBy?: string;

    @ApiProperty({
        description:
            'Search within stored filenames in Google Cloud Storage. Useful for finding files by their processed names.',
        example: 'course-image-2024',
        required: false,
        type: String,
        title: 'Filename Search',
        minLength: 2,
        maxLength: 100,
    })
    @IsOptional()
    @IsString({ message: 'Filename search must be a valid string' })
    filename?: string;

    @ApiProperty({
        description:
            'Search within original uploaded filenames. Useful for finding files by their original names before processing.',
        example: 'presentation-final',
        required: false,
        type: String,
        title: 'Original Name Search',
        minLength: 2,
        maxLength: 100,
    })
    @IsOptional()
    @IsString({ message: 'Original name search must be a valid string' })
    originalName?: string;

    @ApiProperty({
        description:
            'Page number for pagination starting from 1. Use with limit to navigate through large file collections efficiently.',
        example: 1,
        required: false,
        default: 1,
        type: Number,
        title: 'Page Number',
        minimum: 1,
        maximum: 1000,
    })
    @IsOptional()
    @Transform(({ value }) => parseInt(value) || 1)
    page?: number = 1;

    @ApiProperty({
        description:
            'Number of files to return per page. Maximum 100 files per request to ensure optimal performance.',
        example: 20,
        required: false,
        default: 20,
        type: Number,
        title: 'Results Per Page',
        minimum: 1,
        maximum: 100,
    })
    @IsOptional()
    @Transform(({ value }) => Math.min(parseInt(value) || 20, 100))
    limit?: number = 20;

    @ApiProperty({
        description:
            'Field to sort results by. Choose based on your use case: createdAt for recent files, originalName for alphabetical, size for file management.',
        example: 'createdAt',
        required: false,
        enum: ['createdAt', 'originalName', 'size', 'type'],
        default: 'createdAt',
        type: String,
        title: 'Sort Field',
    })
    @IsOptional()
    @IsString({ message: 'Sort field must be a valid string' })
    sortBy?: string = 'createdAt';

    @ApiProperty({
        description:
            'Sort order direction. Use DESC for newest/largest first, ASC for oldest/smallest first.',
        example: 'DESC',
        required: false,
        enum: ['ASC', 'DESC'],
        default: 'DESC',
        type: String,
        title: 'Sort Order',
    })
    @IsOptional()
    @IsString({ message: 'Sort order must be a valid string' })
    sortOrder?: 'ASC' | 'DESC' = 'DESC';
}

/*
 * Class #118: MediaFile
 * Source: media-manager/entities/media-manager.entity.ts:39
 * Type: Exported Class
 * Methods: 1
 * Properties: 57
 * Decorators: 69
 * Complexity: 167
 * Size: 4773 characters (202 lines)
 */
export class MediaFile {
    @PrimaryGeneratedColumn()
    @ApiProperty({
        description: 'Media file unique identifier',
        example: 1,
    })
    id: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Original filename as uploaded',
        example: 'course-image.jpg',
    })
    @IsString()
    @IsNotEmpty()
    originalName: string;

    @Column()
    @ApiProperty({
        description: 'Stored filename in GCS',
        example: 'media/2024/01/15/uuid-course-image.jpg',
    })
    @IsString()
    @IsNotEmpty()
    filename: string;

    @Column()
    @ApiProperty({
        description: 'Full GCS URL for the file',
        example:
            'https://storage.googleapis.com/bucket-name/media/2024/01/15/uuid-course-image.jpg',
    })
    @IsString()
    @IsNotEmpty()
    url: string;

    @Column()
    @ApiProperty({
        description: 'MIME type of the file',
        example: 'image/jpeg',
    })
    @IsString()
    @IsNotEmpty()
    mimeType: string;

    @Column()
    @ApiProperty({
        description: 'File size in bytes',
        example: 2048576,
    })
    @IsNumber()
    size: number;

    @Column({
        type: 'enum',
        enum: MediaType,
        default: MediaType.OTHER,
    })
    @ApiProperty({
        description: 'Type of media file',
        enum: MediaType,
        example: MediaType.IMAGE,
    })
    @IsEnum(MediaType)
    type: MediaType;

    @Column({
        type: 'enum',
        enum: ImageVariant,
        nullable: true,
    })
    @ApiProperty({
        description: 'Image variant (for images only)',
        enum: ImageVariant,
        example: ImageVariant.ORIGINAL,
        required: false,
    })
    @IsOptional()
    @IsEnum(ImageVariant)
    variant?: ImageVariant;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Reference to original file (for thumbnails/variants)',
        example: 1,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    originalFileId?: number;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Image width in pixels (for images)',
        example: 1920,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    width?: number;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Image height in pixels (for images)',
        example: 1080,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    height?: number;

    @Column({ default: true })
    @ApiProperty({
        description: 'Whether the file is active/available',
        example: true,
    })
    @IsBoolean()
    isActive: boolean;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Alt text for images (accessibility)',
        example: 'Course introduction illustration',
        required: false,
    })
    @IsOptional()
    @IsString()
    altText?: string;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'File description or caption',
        example: 'Introduction image for Computer Science course',
        required: false,
    })
    @IsOptional()
    @IsString()
    description?: string;

    @Column('json', { nullable: true })
    @ApiProperty({
        description: 'Additional metadata for the file',
        example: { exif: {}, processing: {} },
        required: false,
    })
    @IsOptional()
    metadata?: Record<string, any>;

    @Column()
    @ApiProperty({
        description: 'ID of the user who uploaded this file',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    @IsString()
    @IsNotEmpty()
    uploadedBy: string;

    @CreateDateColumn()
    @ApiProperty({
        description: 'File upload timestamp',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @UpdateDateColumn()
    @ApiProperty({
        description: 'File last update timestamp',
        example: '2024-01-15T10:30:45.123Z',
    })
    updatedAt: Date;

    @ManyToOne(() => Organization, { nullable: true })
    @ApiProperty({
        description: 'Organization this file belongs to',
        type: () => Organization,
        required: false,
    })
    orgId?: Organization;

    @ManyToOne(() => Branch, { nullable: true })
    @ApiProperty({
        description: 'Branch this file belongs to',
        type: () => Branch,
        required: false,
    })
    branchId?: Branch;

    // Relations
    @ManyToOne(() => User, { onDelete: 'RESTRICT' })
    uploader: User;

    @ManyToOne(() => MediaFile, { nullable: true, onDelete: 'CASCADE' })
    originalFile?: MediaFile;

    // Transient property for loaded variants (not persisted to database)
    variants?: MediaFile[];

    constructor(partial: Partial<MediaFile>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #119: MediaManagerController
 * Source: media-manager/media-manager.controller.ts:61
 * Type: Exported Class
 * Methods: 18
 * Properties: 369
 * Decorators: 65
 * Complexity: 259
 * Size: 29816 characters (853 lines)
 */
export class MediaManagerController {
    private readonly logger = new Logger(MediaManagerController.name);

    constructor(private readonly mediaService: MediaManagerService) {}

    @Post('upload')
    @UseInterceptors(FileInterceptor('file'))
    @ApiOperation({
        summary: '📤 Upload Single File',
        description: `
      **Upload a single file to Google Cloud Storage with automatic processing**
      
      This endpoint handles secure file uploads with comprehensive features:
      - Direct upload to Google Cloud Storage
      - Automatic image thumbnail generation
      - File type validation and processing
      - Metadata extraction and storage
      
      **Supported File Types:**
      - **Images**: JPEG, PNG, WebP, GIF, SVG (auto-generates thumbnails)
      - **Documents**: PDF, Word, Excel, PowerPoint, Text
      - **Videos**: MP4, MPEG, QuickTime, AVI, WebM
      - **Audio**: MP3, WAV, OGG, M4A
      
      **Image Processing:**
      - Original image preserved at full resolution
      - Automatic thumbnail generation (150x150px)
      - Optional medium (500x500px) and large (1200x1200px) variants
      - Optimized JPEG compression for variants
      
      **Security Features:**
      - 50MB file size limit
      - File type validation
      - Virus scanning (if configured)
      - Organization/branch scoping
      
      **Use Cases:**
      - Course material uploads
      - Profile pictures and avatars
      - Document attachments
      - Media content for presentations
    `,
        operationId: 'uploadSingleFile',
    })
    @ApiConsumes('multipart/form-data')
    @ApiBody({
        type: UploadFileDto,
        description:
            'File upload with comprehensive metadata and processing options',
        examples: {
            'image-with-thumbnails': {
                summary: '🖼️ Image Upload with Thumbnails',
                description:
                    'Upload an image file with automatic thumbnail generation',
                value: {
                    file: '[binary image data]',
                    altText:
                        'Computer Science course introduction showing programming fundamentals',
                    description:
                        'Comprehensive introduction image for CS101 course covering basic programming concepts',
                    generateThumbnails: true,
                    variants: ['thumbnail', 'medium'],
                },
            },
            'document-upload': {
                summary: '📄 Document Upload',
                description: 'Upload a PDF document for course materials',
                value: {
                    file: '[binary PDF data]',
                    description:
                        'Course syllabus and curriculum overview for Computer Science fundamentals',
                    type: 'document',
                    generateThumbnails: false,
                },
            },
            'video-content': {
                summary: '🎥 Video Upload',
                description: 'Upload video content for online learning',
                value: {
                    file: '[binary video data]',
                    altText:
                        'Course lecture video on advanced programming concepts',
                    description:
                        'Detailed lecture covering object-oriented programming principles and best practices',
                    type: 'video',
                    generateThumbnails: false,
                },
            },
            'profile-picture': {
                summary: '👤 Profile Picture Upload',
                description: 'Upload user profile picture with variants',
                value: {
                    file: '[binary image data]',
                    altText: 'User profile picture',
                    description: 'Professional headshot for user profile',
                    generateThumbnails: true,
                    variants: ['thumbnail', 'medium', 'large'],
                },
            },
        },
        schema: {
            type: 'object',
            properties: {
                file: {
                    type: 'string',
                    format: 'binary',
                    description:
                        'File to upload (max 50MB). Supports images, documents, videos, and audio files.',
                },
                altText: {
                    type: 'string',
                    description:
                        'Alternative text for images to improve accessibility and SEO compliance',
                    example:
                        'Computer Science course introduction showing programming fundamentals',
                    maxLength: 255,
                    minLength: 3,
                },
                description: {
                    type: 'string',
                    description:
                        'Detailed description for content management and search optimization',
                    example:
                        'Comprehensive introduction image for CS101 course covering basic programming concepts',
                    maxLength: 1000,
                    minLength: 5,
                },
                type: {
                    type: 'string',
                    enum: ['image', 'document', 'video', 'audio', 'other'],
                    description:
                        'Media type classification (auto-detected if not specified)',
                    example: 'image',
                },
                generateThumbnails: {
                    type: 'boolean',
                    description:
                        'Enable automatic thumbnail generation for images',
                    default: true,
                    example: true,
                },
                variants: {
                    type: 'array',
                    items: {
                        type: 'string',
                        enum: ['thumbnail', 'medium', 'large'],
                    },
                    description:
                        'Specific image variants to generate for different display contexts',
                    example: ['thumbnail', 'medium'],
                },
            },
            required: ['file'],
        },
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description: '✅ File uploaded successfully with variants generated',
        schema: {
            type: 'object',
            properties: {
                file: {
                    type: 'object',
                    description: 'Main uploaded file information',
                    properties: {
                        id: { type: 'number', example: 1 },
                        originalName: {
                            type: 'string',
                            example: 'course-introduction.jpg',
                        },
                        filename: {
                            type: 'string',
                            example:
                                'media/org-123/2024/01/15/a1b2c3d4-course-introduction.jpg',
                        },
                        url: {
                            type: 'string',
                            example:
                                'https://storage.googleapis.com/crmapplications/media/org-123/2024/01/15/a1b2c3d4-course-introduction.jpg',
                        },
                        mimeType: { type: 'string', example: 'image/jpeg' },
                        size: { type: 'number', example: 2048576 },
                        type: { type: 'string', example: 'image' },
                        variant: { type: 'string', example: 'original' },
                        width: { type: 'number', example: 1920 },
                        height: { type: 'number', example: 1080 },
                        altText: {
                            type: 'string',
                            example: 'Computer Science course introduction',
                        },
                        description: {
                            type: 'string',
                            example: 'Introduction image for CS fundamentals',
                        },
                        uploadedBy: {
                            type: 'string',
                            example: '1',
                        },
                        createdAt: {
                            type: 'string',
                            example: '2024-01-15T10:30:45.123Z',
                        },
                    },
                },
                variants: {
                    type: 'array',
                    description: 'Generated image variants',
                    items: {
                        type: 'object',
                        properties: {
                            id: { type: 'number', example: 2 },
                            variant: { type: 'string', example: 'thumbnail' },
                            width: { type: 'number', example: 150 },
                            height: { type: 'number', example: 150 },
                            size: { type: 'number', example: 15000 },
                            url: {
                                type: 'string',
                                example:
                                    'https://storage.googleapis.com/crmapplications/media/org-123/2024/01/15/a1b2c3d4-course-introduction-thumbnail.jpg',
                            },
                        },
                    },
                    example: [
                        {
                            id: 2,
                            variant: 'thumbnail',
                            width: 150,
                            height: 150,
                            size: 15000,
                            url: 'https://storage.googleapis.com/crmapplications/media/org-123/2024/01/15/a1b2c3d4-course-introduction-thumbnail.jpg',
                        },
                        {
                            id: 3,
                            variant: 'medium',
                            width: 500,
                            height: 500,
                            size: 85000,
                            url: 'https://storage.googleapis.com/crmapplications/media/org-123/2024/01/15/a1b2c3d4-course-introduction-medium.jpg',
                        },
                    ],
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid file or request',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'string',
                    example: 'File size exceeds 50MB limit',
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    async uploadFile(
        @UploadedFile() file: Express.Multer.File,
        @Body() uploadDto: UploadFileDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<UploadResponseDto> {
        try {
            if (!file) {
                throw new BadRequestException('No file provided');
            }

            this.logger.log(
                `Uploading file "${file.originalname}" for user: ${scope.userId}`,
            );

            const result = await this.mediaService.uploadFile(
                {
                    buffer: file.buffer,
                    originalname: file.originalname,
                    mimetype: file.mimetype,
                    size: file.size,
                },
                uploadDto,
                scope,
            );

            this.logger.log(`File uploaded successfully: ${result.file.id}`);
            return result;
        } catch (error) {
            this.logger.error(`Error uploading file: ${error.message}`, error);
            throw error;
        }
    }

    @Post('upload/bulk')
    @UseInterceptors(FilesInterceptor('files', 10)) // Max 10 files
    @ApiOperation({
        summary: '📤 Upload Multiple Files',
        description: `
      **Upload multiple files simultaneously with batch processing**
      
      This endpoint handles bulk file uploads with comprehensive error handling:
      - Process up to 10 files in a single request
      - Individual file validation and processing
      - Partial success handling (some files succeed, others fail)
      - Detailed error reporting per file
      
      **Batch Processing Features:**
      - Parallel file processing for performance
      - Individual file error handling
      - Progress tracking and reporting
      - Automatic rollback on critical errors
      
      **Common Metadata:**
      - Apply same alt text to all images
      - Apply same description to all files
      - Unified thumbnail generation settings
      - Consistent organization/branch assignment
      
      **Error Handling:**
      - Continues processing even if some files fail
      - Detailed error messages per failed file
      - Success/failure statistics
      - No partial uploads (file is fully processed or not at all)
      
      **Use Cases:**
      - Course material batch uploads
      - Photo gallery uploads
      - Document collection uploads
      - Media library imports
    `,
        operationId: 'uploadMultipleFiles',
    })
    @ApiConsumes('multipart/form-data')
    @ApiBody({
        description: 'Multiple files upload with common metadata',
        schema: {
            type: 'object',
            properties: {
                files: {
                    type: 'array',
                    items: {
                        type: 'string',
                        format: 'binary',
                    },
                    description: 'Files to upload (max 10 files, 50MB each)',
                    maxItems: 10,
                },
                commonAltText: {
                    type: 'string',
                    description: 'Common alt text for all uploaded images',
                    example: 'Course materials',
                    maxLength: 255,
                },
                commonDescription: {
                    type: 'string',
                    description: 'Common description for all uploaded files',
                    example: 'Course resource materials',
                    maxLength: 1000,
                },
                generateThumbnails: {
                    type: 'boolean',
                    description: 'Generate thumbnails for image uploads',
                    default: true,
                },
            },
            required: ['files'],
        },
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description: '✅ Bulk upload completed (check individual file status)',
        type: BulkUploadResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid request or no files provided',
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    async uploadMultipleFiles(
        @UploadedFiles() files: Express.Multer.File[],
        @Body() uploadDto: BulkUploadDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<BulkUploadResponseDto> {
        try {
            if (!files || files.length === 0) {
                throw new BadRequestException('No files provided');
            }

            if (files.length > 10) {
                throw new BadRequestException(
                    'Maximum 10 files allowed per request',
                );
            }

            this.logger.log(
                `Uploading ${files.length} files for user: ${scope.userId}`,
            );

            const uploadedFiles = files.map(file => ({
                buffer: file.buffer,
                originalname: file.originalname,
                mimetype: file.mimetype,
                size: file.size,
            }));

            const result = await this.mediaService.uploadMultipleFiles(
                uploadedFiles,
                uploadDto,
                scope,
            );

            this.logger.log(
                `Bulk upload completed: ${result.successful}/${result.total} files successful`,
            );
            return result;
        } catch (error) {
            this.logger.error(`Error in bulk upload: ${error.message}`, error);
            throw error;
        }
    }

    @Get()
    @ApiOperation({
        summary: '📋 List Media Files',
        description: `
      **Retrieve a paginated list of media files with comprehensive filtering**
      
      This endpoint provides powerful media file discovery with:
      - Advanced filtering by type, variant, uploader, filename
      - Pagination support for large media libraries
      - Sorting capabilities by various fields
      - Organization/branch scoping for access control
      
      **Filtering Options:**
      - **Media Type**: Filter by image, document, video, audio, other
      - **Image Variant**: Filter by original, thumbnail, medium, large
      - **Uploader**: Filter by specific user who uploaded files
      - **Filename Search**: Partial match in stored filename
      - **Original Name Search**: Partial match in original filename
      
      **Response Features:**
      - Full file metadata including URLs
      - Image variants automatically loaded
      - Uploader information included
      - Pagination metadata
      
      **Access Control:**
      - Organization/branch scoping applied
      - Only active files returned
      - User permissions respected
      
      **Use Cases:**
      - Media library browsing
      - File search and discovery
      - Administrative file management
      - Content moderation
    `,
        operationId: 'listMediaFiles',
    })
    @ApiQuery({
        name: 'type',
        required: false,
        description: 'Filter by media type',
        enum: ['image', 'document', 'video', 'audio', 'other'],
        example: 'image',
    })
    @ApiQuery({
        name: 'variant',
        required: false,
        description: 'Filter by image variant',
        enum: ['original', 'thumbnail', 'medium', 'large'],
        example: 'original',
    })
    @ApiQuery({
        name: 'uploadedBy',
        required: false,
        description: 'Filter by uploader user ID',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    @ApiQuery({
        name: 'filename',
        required: false,
        description: 'Search in stored filename',
        example: 'course-image',
    })
    @ApiQuery({
        name: 'originalName',
        required: false,
        description: 'Search in original filename',
        example: 'presentation',
    })
    @ApiQuery({
        name: 'page',
        required: false,
        description: 'Page number (starts from 1)',
        example: 1,
    })
    @ApiQuery({
        name: 'limit',
        required: false,
        description: 'Number of files per page (1-100)',
        example: 20,
    })
    @ApiQuery({
        name: 'sortBy',
        required: false,
        description: 'Sort field',
        enum: ['createdAt', 'originalName', 'size', 'type'],
        example: 'createdAt',
    })
    @ApiQuery({
        name: 'sortOrder',
        required: false,
        description: 'Sort order',
        enum: ['ASC', 'DESC'],
        example: 'DESC',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Media files retrieved successfully',
        type: MediaFileListResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    async getFiles(
        @Query() filters: FileFilterDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<MediaFileListResponseDto> {
        try {
            this.logger.log(
                `Listing media files with filters: ${JSON.stringify(filters)} for org: ${scope.orgId}, branch: ${scope.branchId}`,
            );

            const result = await this.mediaService.getFiles(filters, scope);

            this.logger.log(
                `Retrieved ${result.files.length} files out of ${result.total} total`,
            );

            return result;
        } catch (error) {
            this.logger.error('Error listing media files:', error);
            throw error;
        }
    }

    @Get('my-files')
    @ApiOperation({
        summary: '👤 Get My Uploaded Files',
        description: `
      **Retrieve files uploaded by the authenticated user**
      
      This endpoint returns all files that the current user has uploaded with:
      - Personal file management
      - Upload history tracking
      - File ownership validation
      - Same filtering capabilities as general file list
      
      **Features:**
      - Only shows files uploaded by current user
      - Includes all file variants and metadata
      - Supports same filtering and pagination
      - Optimized for personal media management
      
      **Use Cases:**
      - Personal media dashboard
      - File management interface
      - Upload history review
      - Personal file cleanup
    `,
        operationId: 'getMyUploadedFiles',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ User files retrieved successfully',
        type: MediaFileListResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    async getMyFiles(
        @Query() filters: FileFilterDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<MediaFileListResponseDto> {
        try {
            this.logger.log(`Getting files uploaded by user: ${scope.userId}`);

            const result = await this.mediaService.getFiles(
                { ...filters, uploadedBy: scope.userId },
                scope,
            );

            this.logger.log(
                `Retrieved ${result.files.length} files uploaded by user: ${scope.userId}`,
            );

            return result;
        } catch (error) {
            this.logger.error(
                `Error getting files for user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Get('stats')
    @ApiOperation({
        summary: '📊 Get Media Statistics',
        description: `
      **Retrieve comprehensive media usage statistics**
      
      This endpoint provides detailed analytics about media usage including:
      - Total files and storage utilization
      - File type distribution
      - Average file sizes
      - Recent activity timestamps
      
      **Statistics Provided:**
      - Total number of files by type
      - Total storage used in bytes
      - Average file size calculations
      - File type distribution breakdown
      - Most recent upload activity
      
      **Scoping:**
      - Statistics respect organization/branch boundaries
      - Only includes active files
      - Real-time calculations
      
      **Use Cases:**
      - Storage quota monitoring
      - Usage analytics dashboard
      - Administrative reporting
      - Capacity planning
    `,
        operationId: 'getMediaStatistics',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Media statistics retrieved successfully',
        type: MediaStatsDto,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    async getStats(
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<MediaStatsDto> {
        try {
            this.logger.log(
                `Getting media statistics for org: ${scope.orgId}, branch: ${scope.branchId}`,
            );

            const stats = await this.mediaService.getStats(scope);

            this.logger.log('Media statistics retrieved successfully');

            return stats;
        } catch (error) {
            this.logger.error('Error getting media statistics:', error);
            throw error;
        }
    }

    @Get(':id')
    @ApiOperation({
        summary: '🔍 Get File Details',
        description: `
      **Retrieve detailed information about a specific media file**
      
      This endpoint provides comprehensive file data including:
      - Complete file metadata and URLs
      - Image variants and processing information
      - Uploader details and timestamps
      - Access URLs for direct download
      
      **Detailed Information:**
      - File metadata (size, type, dimensions)
      - All available variants for images
      - Uploader profile information
      - Creation and modification timestamps
      - Direct access URLs
      
      **Security:**
      - Organization/branch scoping applied
      - Only active files accessible
      - Access control validation
      
      **Use Cases:**
      - File detail pages
      - Media preview functionality
      - Download link generation
      - File properties display
    `,
        operationId: 'getFileDetails',
    })
    @ApiParam({
        name: 'id',
        description: 'Media file unique identifier',
        example: 1,
        type: 'number',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ File details retrieved successfully',
        type: MediaFileResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ File not found',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 404 },
                message: {
                    type: 'string',
                    example: 'File with ID 1 not found',
                },
                error: { type: 'string', example: 'Not Found' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    async getFileById(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<MediaFileResponseDto> {
        try {
            this.logger.log(
                `Getting file details for ID: ${id} with org/branch scope`,
            );

            const file = await this.mediaService.getFileById(id, scope);

            this.logger.log(`File details retrieved for ID: ${id}`);

            return file;
        } catch (error) {
            this.logger.error(`Error getting file ${id}:`, error);
            throw error;
        }
    }

    @Delete(':id')
    @ApiOperation({
        summary: '🗑️ Delete File',
        description: `
      **Permanently delete a media file with ownership validation**
      
      This endpoint allows file owners to delete their uploaded files with:
      - Ownership verification (only file uploader can delete)
      - Soft deletion (marks as inactive)
      - Variant cleanup (deletes all image variants)
      - Audit trail logging
      
      **Deletion Process:**
      - Validates user ownership
      - Marks file as inactive (soft delete)
      - Removes all image variants
      - Logs deletion for audit purposes
      
      **Safety Features:**
      - Only file uploaders can delete their files
      - Soft deletion allows recovery if needed
      - Cascade deletion of variants
      - Maintains referential integrity
      
      **Important Notes:**
      - Files are marked inactive, not physically deleted
      - All variants are also marked inactive
      - File URLs may remain accessible for a period
      - Consider archiving for important files
      
      **Use Cases:**
      - Personal file cleanup
      - Content moderation
      - Storage management
      - Privacy compliance
    `,
        operationId: 'deleteFile',
    })
    @ApiParam({
        name: 'id',
        description: 'Media file unique identifier',
        example: 1,
        type: 'number',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ File deleted successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: {
                    type: 'string',
                    example: 'File deleted successfully',
                },
                data: { type: 'null' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ File not found',
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Access denied - Not file owner',
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    async deleteFile(
        @Param('id', ParseIntPipe) id: number,
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardApiResponse> {
        try {
            this.logger.log(`Deleting file ${id} for user: ${req.user.id}`);

            await this.mediaService.deleteFile(id, req.user.id);

            this.logger.log(`File ${id} deleted successfully`);

            return {
                success: true,
                message: 'File deleted successfully',
                data: null,
            };
        } catch (error) {
            this.logger.error(
                `Error deleting file ${id} for user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }
}

/*
 * Class #120: MediaManagerModule
 * Source: media-manager/media-manager.module.ts:32
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 34 characters (1 lines)
 */
export class MediaManagerModule {}

/*
 * Class #121: MediaManagerService
 * Source: media-manager/media-manager.service.ts:52
 * Type: Exported Class
 * Methods: 70
 * Properties: 161
 * Decorators: 2
 * Complexity: 365
 * Size: 29975 characters (899 lines)
 */
export class MediaManagerService {
    private readonly logger = new Logger(MediaManagerService.name);
    private readonly storage: Storage;
    private readonly bucketName: string;
    private readonly baseUrl: string;

    // Cache keys
    private readonly CACHE_KEYS = {
        FILE_BY_ID: (id: number) => `media:file:${id}`,
        FILES_LIST: (filters: string, scope: string) =>
            `media:list:${scope}:${filters}`,
        STATS: (scope: string) => `media:stats:${scope}`,
        FILE_VARIANTS: (fileId: number) => `media:variants:${fileId}`,
        ORG_FILES: (orgId: string) => `media:org:${orgId}`,
        BRANCH_FILES: (branchId: string) => `media:branch:${branchId}`,
        USER_FILES: (userId: string) => `media:user:${userId}`,
    };

    // Cache TTL in seconds
    private readonly CACHE_TTL = {
        FILE: 300, // 5 minutes
        FILE_LIST: 180, // 3 minutes
        STATS: 600, // 10 minutes
        VARIANTS: 600, // 10 minutes
    };

    // Image processing configurations
    private readonly imageVariants: ImageVariantConfig = {
        [ImageVariant.THUMBNAIL]: { width: 150, height: 150 },
        [ImageVariant.MEDIUM]: { width: 500, height: 500 },
        [ImageVariant.LARGE]: { width: 1200, height: 1200 },
    };

    // Supported file types
    private readonly supportedMimeTypes = {
        image: [
            'image/jpeg',
            'image/jpg',
            'image/png',
            'image/webp',
            'image/gif',
            'image/svg+xml',
        ],
        document: [
            'application/pdf',
            'application/msword',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'application/vnd.ms-excel',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            'application/vnd.ms-powerpoint',
            'application/vnd.openxmlformats-officedocument.presentationml.presentation',
            'text/plain',
        ],
        video: [
            'video/mp4',
            'video/mpeg',
            'video/quicktime',
            'video/x-msvideo',
            'video/webm',
        ],
        audio: [
            'audio/mpeg',
            'audio/wav',
            'audio/mp3',
            'audio/ogg',
            'audio/x-m4a',
        ],
    };

    constructor(
        @InjectRepository(MediaFile)
        private readonly mediaRepository: Repository<MediaFile>,
        private readonly configService: ConfigService,
        private readonly userService: UserService,
        @Inject(CACHE_MANAGER) private readonly cacheManager: Cache,
    ) {
        // Initialize Google Cloud Storage
        const projectId = this.configService.get<string>(
            'GOOGLE_CLOUD_PROJECT_ID',
        );
        const privateKey = this.configService
            .get<string>('GOOGLE_CLOUD_PRIVATE_KEY')
            ?.replace(/\\n/g, '\n');
        const clientEmail = this.configService.get<string>(
            'GOOGLE_CLOUD_CLIENT_EMAIL',
        );
        this.bucketName =
            this.configService.get<string>('GOOGLE_CLOUD_PROJECT_BUCKET') ||
            'crmapplications';

        if (!projectId || !privateKey || !clientEmail || !this.bucketName) {
            throw new Error('Google Cloud Storage configuration is incomplete');
        }

        this.storage = new Storage({
            projectId,
            credentials: {
                private_key: privateKey,
                client_email: clientEmail,
            },
        });

        this.baseUrl = `https://storage.googleapis.com/${this.bucketName}`;

        // Test and log connection success
        this.testGCSConnection();
    }

    /**
     * Cache helper methods
     */
    private async invalidateFileCache(
        fileId: number,
        uploaderId?: string,
        orgId?: string,
        branchId?: string,
    ): Promise<void> {
        const keysToDelete = [this.CACHE_KEYS.FILE_BY_ID(fileId)];

        if (uploaderId) {
            keysToDelete.push(this.CACHE_KEYS.USER_FILES(uploaderId));
        }
        if (orgId) {
            keysToDelete.push(this.CACHE_KEYS.ORG_FILES(orgId));
        }
        if (branchId) {
            keysToDelete.push(this.CACHE_KEYS.BRANCH_FILES(branchId));
        }

        await Promise.all(keysToDelete.map(key => this.cacheManager.del(key)));
    }

    private async invalidateListCaches(scope?: OrgBranchScope): Promise<void> {
        const keysToDelete: string[] = [];

        if (scope?.orgId) {
            keysToDelete.push(this.CACHE_KEYS.ORG_FILES(scope.orgId));
            keysToDelete.push(this.CACHE_KEYS.STATS(scope.orgId));
        }
        if (scope?.branchId) {
            keysToDelete.push(this.CACHE_KEYS.BRANCH_FILES(scope.branchId));
            keysToDelete.push(this.CACHE_KEYS.STATS(scope.branchId));
        }
        if (scope?.userId) {
            keysToDelete.push(this.CACHE_KEYS.USER_FILES(scope.userId));
        }

        await Promise.all(keysToDelete.map(key => this.cacheManager.del(key)));
    }

    private generateCacheKey(
        filters: FileFilterDto,
        scope?: OrgBranchScope,
    ): string {
        const filterKey = JSON.stringify({
            type: filters.type,
            variant: filters.variant,
            uploadedBy: filters.uploadedBy,
            filename: filters.filename,
            originalName: filters.originalName,
            page: filters.page,
            limit: filters.limit,
            sortBy: filters.sortBy,
            sortOrder: filters.sortOrder,
        });

        const scopeKey = JSON.stringify({
            orgId: scope?.orgId,
            branchId: scope?.branchId,
            userId: scope?.userId,
        });

        return this.CACHE_KEYS.FILES_LIST(filterKey, scopeKey);
    }

    private generateStatsKey(scope?: OrgBranchScope): string {
        const scopeKey = JSON.stringify({
            orgId: scope?.orgId,
            branchId: scope?.branchId,
        });
        return this.CACHE_KEYS.STATS(scopeKey);
    }

    private async retryOperation<T>(
        operation: () => Promise<T>,
        maxRetries = 3,
        delay = 1000,
    ): Promise<T> {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                const isConnectionError =
                    error instanceof Error &&
                    (error.message.includes('ECONNRESET') ||
                        error.message.includes('Connection lost') ||
                        error.message.includes('connect ETIMEDOUT'));

                if (isConnectionError && attempt < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                    continue;
                }
                throw error;
            }
        }
        throw new Error('Max retries exceeded');
    }

    /**
     * Upload a single file
     */
    async uploadFile(
        file: UploadedFile,
        uploadDto: UploadFileDto,
        scope: OrgBranchScope,
    ): Promise<UploadResponseDto> {
        return this.retryOperation(async () => {
            try {
                this.logger.log(
                    `Uploading file: ${file.originalname} for user: ${scope.userId}`,
                );

                // Validate file
                this.validateFile(file);

                // Determine media type
                const mediaType =
                    uploadDto.type || this.detectMediaType(file.mimetype);

                // Generate unique filename
                const filename = this.generateFilename(
                    file.originalname,
                    scope,
                );

                // Upload original file to GCS
                const originalFile = await this.uploadToGCS(file, filename);

                // Extract variants from uploadDto to avoid type conflicts
                const { variants, ...uploadDataForDb } = uploadDto;

                // Save to database
                const savedFile = await this.saveToDatabase({
                    ...originalFile,
                    ...uploadDataForDb,
                    type: mediaType,
                    variant: ImageVariant.ORIGINAL,
                    uploadedBy: scope.userId,
                    orgId: scope.orgId
                        ? ({ id: scope.orgId } as any)
                        : undefined,
                    branchId: scope.branchId
                        ? ({ id: scope.branchId } as any)
                        : undefined,
                });

                const response: UploadResponseDto = {
                    file: savedFile,
                };

                // Generate image variants if requested and it's an image
                if (
                    mediaType === MediaType.IMAGE &&
                    uploadDto.generateThumbnails !== false
                ) {
                    const imageVariants = await this.generateImageVariants(
                        file,
                        savedFile,
                        variants || [ImageVariant.THUMBNAIL],
                        scope,
                    );
                    response.variants = imageVariants;
                }

                // Invalidate caches after successful upload
                await this.invalidateListCaches(scope);

                this.logger.log(`File uploaded successfully: ${savedFile.id}`);
                return response;
            } catch (error) {
                this.logger.error(
                    `Error uploading file ${file.originalname}:`,
                    error instanceof Error ? error.message : 'Unknown error',
                );
                throw error;
            }
        });
    }

    /**
     * Upload multiple files
     */
    async uploadMultipleFiles(
        files: UploadedFile[],
        uploadDto: BulkUploadDto,
        scope: OrgBranchScope,
    ): Promise<BulkUploadResponseDto> {
        const uploaded: UploadResponseDto[] = [];
        const errors: Array<{ filename: string; error: string }> = [];

        for (const file of files) {
            try {
                const fileUploadDto: UploadFileDto = {
                    altText: uploadDto.commonAltText,
                    description: uploadDto.commonDescription,
                    generateThumbnails: uploadDto.generateThumbnails,
                };

                const result = await this.uploadFile(
                    file,
                    fileUploadDto,
                    scope,
                );
                uploaded.push(result);
            } catch (error) {
                this.logger.error(
                    `Error uploading ${file.originalname}:`,
                    error,
                );
                errors.push({
                    filename: file.originalname,
                    error: error.message || 'Upload failed',
                });
            }
        }

        return {
            uploaded,
            errors,
            total: files.length,
            successful: uploaded.length,
            failed: errors.length,
        };
    }

    /**
     * Get files with filtering and pagination
     */
    async getFiles(
        filters: FileFilterDto,
        scope?: OrgBranchScope,
    ): Promise<MediaFileListResponseDto> {
        return this.retryOperation(async () => {
            try {
                // Check cache first
                const cacheKey = this.generateCacheKey(filters, scope);
                const cachedResult =
                    await this.cacheManager.get<MediaFileListResponseDto>(
                        cacheKey,
                    );

                if (cachedResult) {
                    return cachedResult;
                }

                const {
                    type,
                    variant,
                    uploadedBy,
                    filename,
                    originalName,
                    page = 1,
                    limit = 20,
                    sortBy = 'createdAt',
                    sortOrder = 'DESC',
                } = filters;

                const query = this.mediaRepository.createQueryBuilder('media');
                query.leftJoinAndSelect('media.uploader', 'uploader');
                query.leftJoinAndSelect('media.orgId', 'org');
                query.leftJoinAndSelect('media.branchId', 'branch');

                // Apply org/branch scoping
                if (scope?.orgId) {
                    query.andWhere('media.orgId = :orgId', {
                        orgId: scope.orgId,
                    });
                }
                if (scope?.branchId) {
                    query.andWhere('media.branchId = :branchId', {
                        branchId: scope.branchId,
                    });
                }

                // Apply filters
                query.andWhere('media.isActive = :isActive', {
                    isActive: true,
                });

                if (type) {
                    query.andWhere('media.type = :type', { type });
                }

                if (variant) {
                    query.andWhere('media.variant = :variant', { variant });
                }

                if (uploadedBy) {
                    query.andWhere('media.uploadedBy = :uploadedBy', {
                        uploadedBy,
                    });
                }

                if (filename) {
                    query.andWhere('media.filename LIKE :filename', {
                        filename: `%${filename}%`,
                    });
                }

                if (originalName) {
                    query.andWhere('media.originalName LIKE :originalName', {
                        originalName: `%${originalName}%`,
                    });
                }

                // Add sorting
                const validSortFields = [
                    'createdAt',
                    'originalName',
                    'size',
                    'type',
                ];
                const sortField = validSortFields.includes(sortBy)
                    ? sortBy
                    : 'createdAt';
                query.orderBy(`media.${sortField}`, sortOrder);

                // Add pagination
                const skip = (page - 1) * limit;
                query.skip(skip).take(limit);

                const [files, total] = await query.getManyAndCount();

                // Load variants for images
                const filesWithVariants = await Promise.all(
                    files.map(async file => {
                        if (
                            file.type === MediaType.IMAGE &&
                            file.variant === ImageVariant.ORIGINAL
                        ) {
                            const variants = await this.mediaRepository.find({
                                where: {
                                    originalFileId: file.id,
                                    isActive: true,
                                },
                                order: { variant: 'ASC' },
                            });
                            return { ...file, variants };
                        }
                        return file;
                    }),
                );

                const result = {
                    files: filesWithVariants,
                    total,
                    page,
                    limit,
                    totalPages: Math.ceil(total / limit),
                };

                // Cache the result
                await this.cacheManager.set(
                    cacheKey,
                    result,
                    this.CACHE_TTL.FILE_LIST * 1000,
                );

                return result;
            } catch (error) {
                this.logger.error('Error getting files:', error);
                throw error;
            }
        });
    }

    /**
     * Get a single file by ID
     */
    async getFileById(
        id: number,
        scope?: OrgBranchScope,
    ): Promise<MediaFileResponseDto> {
        return this.retryOperation(async () => {
            try {
                // Check cache first
                const cacheKey = this.CACHE_KEYS.FILE_BY_ID(id);
                const cachedFile =
                    await this.cacheManager.get<MediaFileResponseDto>(cacheKey);

                if (cachedFile) {
                    return cachedFile;
                }

                const whereCondition: any = { id, isActive: true };

                // Apply org/branch scoping
                if (scope?.orgId) {
                    whereCondition.orgId = { id: scope.orgId };
                }
                if (scope?.branchId) {
                    whereCondition.branchId = { id: scope.branchId };
                }

                const file = await this.mediaRepository.findOne({
                    where: whereCondition,
                    relations: ['uploader', 'orgId', 'branchId'],
                });

                if (!file) {
                    throw new NotFoundException(`File with ID ${id} not found`);
                }

                let result: MediaFileResponseDto;

                // Load variants if it's an original image
                if (
                    file.type === MediaType.IMAGE &&
                    file.variant === ImageVariant.ORIGINAL
                ) {
                    const variants = await this.mediaRepository.find({
                        where: { originalFileId: file.id, isActive: true },
                        order: { variant: 'ASC' },
                    });
                    result = { ...file, variants };
                } else {
                    result = file;
                }

                // Cache the result
                await this.cacheManager.set(
                    cacheKey,
                    result,
                    this.CACHE_TTL.FILE * 1000,
                );

                return result;
            } catch (error) {
                this.logger.error(`Error getting file ${id}:`, error);
                throw error;
            }
        });
    }

    /**
     * Delete a file
     */
    async deleteFile(id: number, userId: string): Promise<void> {
        return this.retryOperation(async () => {
            try {
                const file = await this.mediaRepository.findOne({
                    where: { id, isActive: true },
                    relations: ['orgId', 'branchId'],
                });

                if (!file) {
                    throw new NotFoundException(`File with ID ${id} not found`);
                }

                if (file.uploadedBy !== userId) {
                    throw new BadRequestException(
                        'You can only delete files you uploaded',
                    );
                }

                // Mark as inactive instead of hard delete
                await this.mediaRepository.update(id, { isActive: false });

                // Also mark variants as inactive
                await this.mediaRepository.update(
                    { originalFileId: id },
                    { isActive: false },
                );

                // Invalidate caches
                await this.invalidateFileCache(
                    id,
                    userId,
                    file.orgId?.id,
                    file.branchId?.id,
                );

                this.logger.log(
                    `File ${id} marked as deleted by user ${userId}`,
                );
            } catch (error) {
                this.logger.error(`Error deleting file ${id}:`, error);
                throw error;
            }
        });
    }

    /**
     * Get media statistics
     */
    async getStats(scope?: OrgBranchScope): Promise<MediaStatsDto> {
        return this.retryOperation(async () => {
            try {
                // Check cache first
                const cacheKey = this.generateStatsKey(scope);
                const cachedStats =
                    await this.cacheManager.get<MediaStatsDto>(cacheKey);

                if (cachedStats) {
                    return cachedStats;
                }

                const query = this.mediaRepository.createQueryBuilder('media');
                query.where('media.isActive = :isActive', { isActive: true });

                // Apply org/branch scoping
                if (scope?.orgId) {
                    query.andWhere('media.orgId = :orgId', {
                        orgId: scope.orgId,
                    });
                }
                if (scope?.branchId) {
                    query.andWhere('media.branchId = :branchId', {
                        branchId: scope.branchId,
                    });
                }

                const [files, totalFiles] = await query.getManyAndCount();

                const totalSize = files.reduce(
                    (sum, file) => sum + file.size,
                    0,
                );
                const averageSize = totalFiles > 0 ? totalSize / totalFiles : 0;

                const byType = files.reduce(
                    (acc, file) => {
                        acc[file.type] = (acc[file.type] || 0) + 1;
                        return acc;
                    },
                    {} as Record<MediaType, number>,
                );

                const lastUpload =
                    files.length > 0
                        ? files.sort(
                              (a, b) =>
                                  b.createdAt.getTime() - a.createdAt.getTime(),
                          )[0].createdAt
                        : undefined;

                const result = {
                    totalFiles,
                    totalSize,
                    byType,
                    averageSize,
                    lastUpload,
                };

                // Cache the result
                await this.cacheManager.set(
                    cacheKey,
                    result,
                    this.CACHE_TTL.STATS * 1000,
                );

                return result;
            } catch (error) {
                this.logger.error('Error getting media stats:', error);
                throw error;
            }
        });
    }

    // Private helper methods

    private async testGCSConnection(): Promise<void> {
        try {
            // Test connection by checking if bucket exists and is accessible
            const bucket = this.storage.bucket(this.bucketName);
            const [exists] = await bucket.exists();

            if (exists) {
                this.logger.log(`✅ GCS`);
            } else {
                this.logger.error(
                    `❌ GCS - ${this.bucketName} does not exist or is not accessible`,
                );
            }
        } catch (error) {
            this.logger.error(
                `❌ Google Cloud Storage connection failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
            );
        }
    }

    private validateFile(file: UploadedFile): void {
        const maxSize = 50 * 1024 * 1024; // 50MB

        if (!file || !file.buffer) {
            throw new BadRequestException('No file provided');
        }

        if (file.size > maxSize) {
            throw new BadRequestException('File size exceeds 50MB limit');
        }

        const isSupported = Object.values(this.supportedMimeTypes)
            .flat()
            .includes(file.mimetype);

        if (!isSupported) {
            throw new BadRequestException(
                `Unsupported file type: ${file.mimetype}`,
            );
        }
    }

    private detectMediaType(mimeType: string): MediaType {
        for (const [type, mimeTypes] of Object.entries(
            this.supportedMimeTypes,
        )) {
            if (mimeTypes.includes(mimeType)) {
                return type as MediaType;
            }
        }
        return MediaType.OTHER;
    }

    private generateFilename(
        originalName: string,
        scope: OrgBranchScope,
    ): string {
        const ext = path.extname(originalName);
        const nameWithoutExt = path.basename(originalName, ext);
        const uuid = uuidv4();
        const timestamp = new Date().toISOString().slice(0, 10);

        const orgPath = scope.orgId || 'global';
        const branchPath = scope.branchId || 'main';

        return `media/${orgPath}/${branchPath}/${timestamp}/${uuid}-${nameWithoutExt}${ext}`;
    }

    private async uploadToGCS(
        file: UploadedFile,
        filename: string,
    ): Promise<Partial<MediaFile>> {
        try {
            const bucket = this.storage.bucket(this.bucketName);
            const gcsFile = bucket.file(filename);

            // Upload file
            await gcsFile.save(file.buffer, {
                metadata: {
                    contentType: file.mimetype,
                },
                public: true,
            });

            // Make file publicly accessible
            await gcsFile.makePublic();

            const url = `${this.baseUrl}/${filename}`;

            // Get image dimensions if it's an image
            let width, height;
            if (this.detectMediaType(file.mimetype) === MediaType.IMAGE) {
                try {
                    const metadata = await sharp(file.buffer).metadata();
                    width = metadata.width;
                    height = metadata.height;
                } catch (error) {
                    this.logger.warn(
                        'Could not extract image dimensions:',
                        error,
                    );
                }
            }

            return {
                originalName: file.originalname,
                filename,
                url,
                mimeType: file.mimetype,
                size: file.size,
                width,
                height,
            };
        } catch (error) {
            this.logger.error('Error uploading to GCS:', error);
            throw new InternalServerErrorException(
                'Failed to upload file to storage',
            );
        }
    }

    private async saveToDatabase(
        data: Partial<MediaFile>,
    ): Promise<MediaFileResponseDto> {
        try {
            const mediaFile = this.mediaRepository.create(data);
            const saved = await this.mediaRepository.save(mediaFile);

            // Load the full entity with relations
            const result = await this.mediaRepository.findOne({
                where: { id: saved.id },
                relations: ['uploader', 'orgId', 'branchId'],
            });

            if (!result) {
                throw new InternalServerErrorException(
                    'Failed to retrieve saved file',
                );
            }

            return result;
        } catch (error) {
            this.logger.error('Error saving to database:', error);
            throw new InternalServerErrorException(
                'Failed to save file metadata',
            );
        }
    }

    private async generateImageVariants(
        originalFile: UploadedFile,
        savedOriginal: MediaFileResponseDto,
        variants: ImageVariant[],
        scope: OrgBranchScope,
    ): Promise<MediaFileResponseDto[]> {
        const generatedVariants: MediaFileResponseDto[] = [];

        for (const variant of variants) {
            if (variant === ImageVariant.ORIGINAL) continue;

            try {
                const config = this.imageVariants[variant];
                if (!config) continue;

                // Process image with Sharp
                const processedBuffer = await sharp(originalFile.buffer)
                    .resize(config.width, config.height, {
                        fit: 'inside',
                        withoutEnlargement: true,
                    })
                    .jpeg({ quality: 85 })
                    .toBuffer();

                // Generate variant filename
                const variantFilename = this.generateVariantFilename(
                    savedOriginal.filename,
                    variant,
                );

                // Upload variant to GCS
                const variantFile = await this.uploadToGCS(
                    {
                        buffer: processedBuffer,
                        originalname: `${variant}-${originalFile.originalname}`,
                        mimetype: 'image/jpeg',
                        size: processedBuffer.length,
                    },
                    variantFilename,
                );

                // Save variant to database
                const savedVariant = await this.saveToDatabase({
                    ...variantFile,
                    type: MediaType.IMAGE,
                    variant,
                    originalFileId: savedOriginal.id,
                    uploadedBy: scope.userId,
                    orgId: scope.orgId
                        ? ({ id: scope.orgId } as any)
                        : undefined,
                    branchId: scope.branchId
                        ? ({ id: scope.branchId } as any)
                        : undefined,
                });

                generatedVariants.push(savedVariant);
            } catch (error) {
                this.logger.error(
                    `Error generating ${variant} variant:`,
                    error,
                );
                // Continue with other variants even if one fails
            }
        }

        return generatedVariants;
    }

    private generateVariantFilename(
        originalFilename: string,
        variant: ImageVariant,
    ): string {
        const ext = path.extname(originalFilename);
        const nameWithoutExt = originalFilename.replace(ext, '');
        return `${nameWithoutExt}-${variant}${ext}`;
    }
}

/*
 * Class #122: CreateOrgDto
 * Source: org/dto/create-org.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 10
 * Decorators: 12
 * Complexity: 29
 * Size: 1523 characters (52 lines)
 */
export class CreateOrgDto {
    @ApiProperty({
        description: 'Organization name (must be unique across the system)',
        example: 'Acme Corporation',
        type: String,
        title: 'Organization Name',
        minLength: 2,
        maxLength: 255,
    })
    @IsString({ message: 'Organization name must be a string' })
    @MinLength(2, {
        message: 'Organization name must be at least 2 characters long',
    })
    name: string;

    @ApiProperty({
        description: 'Organization description or mission statement',
        example:
            'Leading technology company specializing in innovative solutions',
        required: false,
        type: String,
        title: 'Description',
        maxLength: 1000,
    })
    @IsOptional()
    @IsString({ message: 'Description must be a string' })
    description?: string;

    @ApiProperty({
        description: 'Organization logo image URL',
        example: 'https://cdn.example.com/logos/acme-corp.png',
        required: false,
        type: String,
        title: 'Logo URL',
        format: 'url',
    })
    @IsOptional()
    @IsUrl({}, { message: 'Logo URL must be a valid URL' })
    logoUrl?: string;

    @ApiProperty({
        description: 'Organization official website URL',
        example: 'https://www.acmecorp.com',
        required: false,
        type: String,
        title: 'Website URL',
        format: 'url',
    })
    @IsOptional()
    @IsUrl({}, { message: 'Website must be a valid URL' })
    website?: string;
}

/*
 * Class #123: UpdateOrgDto
 * Source: org/dto/update-org.dto.ts:5
 * Type: Exported Class
 * Methods: 1
 * Properties: 6
 * Decorators: 3
 * Complexity: 11
 * Size: 378 characters (12 lines)
 * Extends: PartialType(CreateOrgDto)
 */
export class UpdateOrgDto extends PartialType(CreateOrgDto) {
    @ApiProperty({
        description: 'Organization active status (enable/disable organization)',
        example: true,
        required: false,
        type: Boolean,
        title: 'Active Status',
    })
    @IsOptional()
    @IsBoolean({ message: 'Active status must be a boolean' })
    isActive?: boolean;
}

/*
 * Class #124: Organization
 * Source: org/entities/org.entity.ts:16
 * Type: Exported Class
 * Methods: 0
 * Properties: 17
 * Decorators: 26
 * Complexity: 62
 * Size: 2322 characters (83 lines)
 */
export class Organization {
    @PrimaryGeneratedColumn('uuid')
    @ApiProperty({
        description: 'Organization unique identifier',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    id: string;

    @Column({ unique: true })
    @ApiProperty({
        description: 'Organization name (must be unique)',
        example: 'Acme Corporation',
    })
    @IsString({ message: 'Organization name must be a string' })
    name: string;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Organization description',
        example:
            'Leading technology company specializing in innovative solutions',
        required: false,
    })
    @IsOptional()
    @IsString({ message: 'Description must be a string' })
    description?: string;

    @Column({ default: true })
    @ApiProperty({
        description: 'Organization active status',
        example: true,
        default: true,
    })
    @IsBoolean({ message: 'Active status must be a boolean' })
    isActive: boolean;

    @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
    @ApiProperty({
        description: 'Organization creation date',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Organization logo URL',
        example: 'https://cdn.example.com/logos/acme-corp.png',
        required: false,
    })
    @IsOptional()
    @IsUrl({}, { message: 'Logo URL must be a valid URL' })
    logoUrl?: string;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Organization website URL',
        example: 'https://www.acmecorp.com',
        required: false,
    })
    @IsOptional()
    @IsUrl({}, { message: 'Website must be a valid URL' })
    website?: string;

    @Column({ nullable: false, unique: true })
    @ApiProperty({
        description: 'Organization email',
        example: 'info@acmecorp.com',
        required: false,
    })
    email?: string;

    @OneToMany(() => Branch, branch => branch.organization)
    @ApiProperty({
        description: 'Organization branches',
        type: () => [Branch],
        required: false,
    })
    branches?: Branch[];

    constructor(partial: Partial<Organization>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #125: OrgController
 * Source: org/org.controller.ts:41
 * Type: Exported Class
 * Methods: 12
 * Properties: 841
 * Decorators: 97
 * Complexity: 270
 * Size: 62687 characters (1576 lines)
 */
export class OrgController {
    private readonly logger = new Logger(OrgController.name);

    constructor(private readonly orgService: OrgService) {}

    // Organization endpoints
    @Post()
    @ApiOperation({
        summary: '🏗️ Create New Organization',
        description: `
        **Create Organization - Foundation of the trainpro Ecosystem**
        
        Organizations are the cornerstone of the trainpro platform, enabling:
        
        **🎯 Why Organizations Matter:**
        - **Multi-tenant Architecture**: Isolate data and operations between different institutions
        - **Scalable Exam Management**: Support universities, corporations, training centers simultaneously  
        - **Brand Identity**: Custom logos, websites, and organizational profiles
        - **Administrative Control**: Centralized management of all institutional activities
        - **Compliance & Security**: Organization-level data governance and access controls
        
        **🏫 Real-world Use Cases:**
        - Universities managing multiple campuses and departments
        - Corporations with different divisions and subsidiaries  
        - Training institutes with franchises across regions
        - Government agencies with various departments
        - Educational networks with multiple member institutions
        
        **✨ Platform Benefits:**
        - **Exam Isolation**: Tests created by one org don't interfere with others
        - **User Segmentation**: Students/staff belong to specific organizations
        - **Custom Branding**: Each org maintains its unique identity
        - **Resource Management**: Dedicated courses, tests, and content per organization
        - **Analytics Separation**: Performance metrics isolated by organization
        
        **🔧 Technical Features:**
        - Unique name validation across the entire platform
        - Support for organizational branding (logos, websites)
        - Active/inactive status for temporary suspension
        - Automatic relationship management with branches
        `,
        operationId: 'createOrganization',
    })
    @ApiBody({
        type: CreateOrgDto,
        description: 'Organization creation data with unique name validation',
        examples: {
            university: {
                summary: '🎓 University Example',
                description:
                    'Large educational institution with multiple campuses',
                value: {
                    name: 'Stanford University',
                    description:
                        'Leading research university with world-class programs in technology, medicine, and business',
                    logoUrl: 'https://cdn.stanford.edu/logo.png',
                    website: 'https://www.stanford.edu',
                },
            },
            corporation: {
                summary: '🏢 Corporate Example',
                description: 'Technology company with training programs',
                value: {
                    name: 'TechCorp Industries',
                    description:
                        'Global technology company providing innovative solutions and employee training programs',
                    logoUrl: 'https://cdn.techcorp.com/brand/logo.png',
                    website: 'https://www.techcorp.com',
                },
            },
            training: {
                summary: '📚 Training Institute Example',
                description: 'Professional certification and training center',
                value: {
                    name: 'Professional Skills Academy',
                    description:
                        'Comprehensive professional development and certification programs for working professionals',
                    logoUrl: 'https://cdn.psa.edu/logo.png',
                    website: 'https://www.psa.edu',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description:
            '✅ Organization created successfully - Ready for branch creation and user assignment',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success status',
                },
                message: {
                    type: 'string',
                    example: 'Organization created successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'object',
                    description: 'Created organization data',
                    properties: {
                        id: {
                            type: 'string',
                            example: '1',
                            description: 'Unique organization identifier',
                        },
                        name: {
                            type: 'string',
                            example: 'Stanford University',
                            description: 'Organization name',
                        },
                        description: {
                            type: 'string',
                            example:
                                'Leading research university with world-class programs',
                            description: 'Organization description',
                        },
                        logoUrl: {
                            type: 'string',
                            example: 'https://cdn.stanford.edu/logo.png',
                            description: 'Organization logo URL',
                        },
                        website: {
                            type: 'string',
                            example: 'https://www.stanford.edu',
                            description: 'Organization website',
                        },
                        isActive: {
                            type: 'boolean',
                            example: true,
                            description: 'Organization active status',
                        },
                        createdAt: {
                            type: 'string',
                            example: '2024-01-15T10:30:45.123Z',
                            description: 'Creation timestamp',
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description:
            '❌ Invalid input data - Check name length, URL format validation',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    example: [
                        'Organization name must be at least 2 characters long',
                        'Logo URL must be a valid URL',
                        'Website must be a valid URL',
                    ],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CONFLICT,
        description:
            '⚠️ Organization name already exists - Names must be unique across the platform',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 409 },
                message: {
                    type: 'string',
                    example:
                        'Organization with name "Stanford University" already exists',
                },
                error: { type: 'string', example: 'Conflict' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description: '🔥 Internal server error during organization creation',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: { type: 'string', example: 'Internal server error' },
            },
        },
    })
    async createOrganization(@Body() createOrgDto: CreateOrgDto) {
        this.logger.log(`Creating organization: ${createOrgDto.name}`);
        return await this.orgService.createOrganization(createOrgDto);
    }

    @Get()
    @ApiOperation({
        summary: '📋 List All Organizations',
        description: `
        **Organization Directory - Complete Platform Overview**
        
        **🔍 What This Provides:**
        - Complete list of all organizations in the trainpro platform
        - Hierarchical view showing organizations with their branches
        - Administrative overview for platform management
        - Quick access to organizational statistics and health
        
        **📊 Data Included:**
        - Organization profiles and branding information
        - Associated branches with location details
        - Active/inactive status for each organization
        - Creation timestamps for audit and reporting
        
        **🎯 Use Cases:**
        - **Platform Administration**: Monitor all organizations on the platform
        - **Onboarding Support**: Help new organizations understand the ecosystem
        - **Analytics Dashboards**: Generate platform-wide usage reports
        - **Customer Success**: Track organizational growth and expansion
        - **Sales Intelligence**: Identify opportunities for service expansion
        `,
        operationId: 'getAllOrganizations',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description:
            '✅ Organizations retrieved successfully with branch relationships',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success status',
                },
                message: {
                    type: 'string',
                    example: 'Organizations retrieved successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'array',
                    description: 'List of organizations with branches',
                    items: {
                        type: 'object',
                        properties: {
                            id: {
                                type: 'string',
                                example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
                                description: 'Organization identifier',
                            },
                            name: {
                                type: 'string',
                                example: 'Stanford University',
                                description: 'Organization name',
                            },
                            description: {
                                type: 'string',
                                example: 'Leading research university',
                                description: 'Organization description',
                            },
                            isActive: {
                                type: 'boolean',
                                example: true,
                                description: 'Organization status',
                            },
                            branches: {
                                type: 'array',
                                description: 'Associated branches',
                                items: {
                                    type: 'object',
                                    properties: {
                                        id: {
                                            type: 'string',
                                            example:
                                                'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
                                        },
                                        name: {
                                            type: 'string',
                                            example: 'Medical Center Campus',
                                        },
                                        address: {
                                            type: 'string',
                                            example: '450 Medical Plaza Drive',
                                        },
                                        isActive: {
                                            type: 'boolean',
                                            example: true,
                                        },
                                    },
                                },
                            },
                            createdAt: {
                                type: 'string',
                                example: '2024-01-01T00:00:00.000Z',
                                description: 'Creation timestamp',
                            },
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description: '🔥 Internal server error during data retrieval',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: { type: 'string', example: 'Internal server error' },
            },
        },
    })
    async findAllOrganizations() {
        this.logger.log('Retrieving all organizations');
        return await this.orgService.findAllOrganizations();
    }

    @Get(':id')
    @ApiOperation({
        summary: '🔍 Get Organization Details',
        description: `
        **Organization Profile - Complete Institutional Overview**
        
        **🏛️ Detailed Organization Information:**
        - Complete organizational profile and branding
        - Full branch network with locations and contact details
        - Operational status and administrative information
        - Historical data and institutional timeline
        
        **📍 Branch Network Overview:**
        - All physical and virtual branch locations
        - Branch-specific contact information and management
        - Operating hours and availability schedules
        - Local administrative contacts and responsibilities
        
        **🎯 Critical for Operations:**
        - **Exam Scheduling**: Understanding available locations and capacity
        - **User Assignment**: Determining which branches users belong to
        - **Resource Allocation**: Planning equipment and space requirements
        - **Communication**: Directing inquiries to appropriate branch contacts
        - **Compliance**: Ensuring all locations meet regulatory requirements
        `,
        operationId: 'getOrganizationById',
    })
    @ApiParam({
        name: 'id',
        description: 'Organization unique identifier (UUID format)',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
        type: 'string',
        format: 'uuid',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description:
            '✅ Organization retrieved successfully with complete branch network',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success status',
                },
                message: {
                    type: 'string',
                    example: 'Organization retrieved successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'object',
                    description: 'Complete organization data with branches',
                    properties: {
                        id: {
                            type: 'string',
                            example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
                            description: 'Organization identifier',
                        },
                        name: {
                            type: 'string',
                            example: 'Stanford University',
                            description: 'Organization name',
                        },
                        description: {
                            type: 'string',
                            example:
                                'Leading research university with world-class programs',
                            description: 'Organization description',
                        },
                        logoUrl: {
                            type: 'string',
                            example: 'https://cdn.stanford.edu/logo.png',
                            description: 'Organization logo URL',
                        },
                        website: {
                            type: 'string',
                            example: 'https://www.stanford.edu',
                            description: 'Organization website',
                        },
                        isActive: {
                            type: 'boolean',
                            example: true,
                            description: 'Organization active status',
                        },
                        branches: {
                            type: 'array',
                            description: 'Complete branch network',
                            items: {
                                type: 'object',
                                properties: {
                                    id: {
                                        type: 'string',
                                        example:
                                            'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
                                    },
                                    name: {
                                        type: 'string',
                                        example: 'Medical Center Campus',
                                    },
                                    address: {
                                        type: 'string',
                                        example:
                                            '450 Medical Plaza Drive, CA 90095',
                                    },
                                    contactNumber: {
                                        type: 'string',
                                        example: '+1-310-825-9111',
                                    },
                                    email: {
                                        type: 'string',
                                        example: 'medcenter@stanford.edu',
                                    },
                                    managerName: {
                                        type: 'string',
                                        example: 'Dr. Sarah Johnson',
                                    },
                                    operatingHours: {
                                        type: 'object',
                                        example: {
                                            opening: '07:00',
                                            closing: '19:00',
                                            days: [
                                                'Monday',
                                                'Tuesday',
                                                'Wednesday',
                                                'Thursday',
                                                'Friday',
                                                'Saturday',
                                            ],
                                        },
                                    },
                                    isActive: {
                                        type: 'boolean',
                                        example: true,
                                    },
                                    createdAt: {
                                        type: 'string',
                                        example: '2024-01-01T00:00:00.000Z',
                                    },
                                },
                            },
                        },
                        createdAt: {
                            type: 'string',
                            example: '2024-01-01T00:00:00.000Z',
                            description: 'Creation timestamp',
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid organization ID format',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: { type: 'string', example: 'Invalid UUID format' },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description:
            '❌ Organization not found - Invalid ID or organization may have been deleted',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 404 },
                message: {
                    type: 'string',
                    example:
                        'Organization with ID a1b2c3d4-e5f6-7890-abcd-ef1234567890 not found',
                },
                error: { type: 'string', example: 'Not Found' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description: '🔥 Internal server error during data retrieval',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: { type: 'string', example: 'Internal server error' },
            },
        },
    })
    async findOrganizationById(@Param('id') id: string) {
        this.logger.log(`Retrieving organization: ${id}`);
        return await this.orgService.findOrganizationById(id);
    }

    @Get(':id/stats')
    @ApiOperation({
        summary: '📊 Organization Analytics & Statistics',
        description: `
        **Organization Metrics - Performance & Growth Insights**
        
        **📈 Key Performance Indicators:**
        - Total branch count and geographic distribution
        - Active vs inactive branch status breakdown
        - Growth trends and expansion patterns
        - Operational efficiency metrics
        
        **🎯 Business Intelligence Value:**
        - **Capacity Planning**: Understand current infrastructure
        - **Expansion Planning**: Identify growth opportunities
        - **Resource Optimization**: Balance load across branches
        - **Performance Monitoring**: Track organizational health
        - **Compliance Reporting**: Generate regulatory reports
        
        **💡 Strategic Applications:**
        - Facility management and space utilization
        - Budget allocation and resource planning
        - Risk assessment and business continuity
        - Market analysis and competitive positioning
        `,
        operationId: 'getOrganizationStats',
    })
    @ApiParam({
        name: 'id',
        description: 'Organization unique identifier for statistics',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
        type: 'string',
        format: 'uuid',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Organization statistics retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success status',
                },
                message: {
                    type: 'string',
                    example: 'Organization statistics retrieved successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'object',
                    description: 'Organization statistics and metrics',
                    properties: {
                        organization: {
                            type: 'object',
                            properties: {
                                id: {
                                    type: 'string',
                                    example:
                                        'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
                                },
                                name: {
                                    type: 'string',
                                    example: 'Stanford University',
                                },
                                isActive: { type: 'boolean', example: true },
                            },
                        },
                        stats: {
                            type: 'object',
                            properties: {
                                totalBranches: {
                                    type: 'number',
                                    example: 15,
                                    description: 'Total number of branches',
                                },
                                activeBranches: {
                                    type: 'number',
                                    example: 12,
                                    description: 'Number of active branches',
                                },
                                inactiveBranches: {
                                    type: 'number',
                                    example: 3,
                                    description: 'Number of inactive branches',
                                },
                            },
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid organization ID format',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: { type: 'string', example: 'Invalid UUID format' },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Organization not found - Cannot generate statistics',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 404 },
                message: {
                    type: 'string',
                    example:
                        'Organization with ID a1b2c3d4-e5f6-7890-abcd-ef1234567890 not found',
                },
                error: { type: 'string', example: 'Not Found' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description: '🔥 Internal server error during statistics generation',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: { type: 'string', example: 'Internal server error' },
            },
        },
    })
    async getOrganizationStats(@Param('id') id: string) {
        this.logger.log(`Retrieving statistics for organization: ${id}`);
        return await this.orgService.getOrganizationStats(id);
    }

    @Put(':id')
    @ApiOperation({
        summary: '✏️ Update Organization Profile',
        description: `
        **Organization Management - Keep Information Current**
        
        **🔄 Updatable Information:**
        - Organizational name (with uniqueness validation)
        - Mission statement and institutional description  
        - Branding elements (logo, website)
        - Operational status (active/inactive)
        
        **🎯 Why Updates Matter:**
        - **Brand Consistency**: Maintain current logos and messaging
        - **Regulatory Compliance**: Update information per legal requirements
        - **User Experience**: Ensure accurate information across platform
        - **Business Continuity**: Manage organizational status changes
        - **Marketing Alignment**: Keep branding synchronized
        
        **⚠️ Important Considerations:**
        - Name changes affect all users and data relationships
        - Status changes impact exam access and operations
        - Branding updates reflect across all user interfaces
        - Changes are logged for audit and compliance
        `,
        operationId: 'updateOrganization',
    })
    @ApiParam({
        name: 'id',
        description: 'Organization unique identifier to update',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
        type: 'string',
        format: 'uuid',
    })
    @ApiBody({
        type: UpdateOrgDto,
        description: 'Organization update data (all fields optional)',
        examples: {
            'name-update': {
                summary: '📝 Organization Name Change',
                description: 'Update organization name with uniqueness check',
                value: {
                    name: 'Stanford University Medical Center',
                },
            },
            'branding-update': {
                summary: '🎨 Branding Update',
                description: 'Update logo and website information',
                value: {
                    logoUrl: 'https://cdn.stanford.edu/new-logo-2024.png',
                    website: 'https://www.stanford.edu',
                },
            },
            'full-update': {
                summary: '🔄 Complete Profile Update',
                description: 'Update all available organization fields',
                value: {
                    name: 'Stanford University',
                    description:
                        'Premier research university with cutting-edge programs in technology, medicine, and innovation',
                    logoUrl: 'https://cdn.stanford.edu/logo-updated.png',
                    website: 'https://www.stanford.edu',
                    isActive: true,
                },
            },
            'status-change': {
                summary: '⚡ Status Change',
                description: 'Activate or deactivate organization',
                value: {
                    isActive: false,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Organization updated successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Update operation success status',
                },
                message: {
                    type: 'string',
                    example: 'Organization updated successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'object',
                    description: 'Updated organization data',
                    properties: {
                        id: {
                            type: 'string',
                            example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
                            description: 'Organization identifier',
                        },
                        name: {
                            type: 'string',
                            example: 'Stanford University Medical Center',
                            description: 'Updated organization name',
                        },
                        description: {
                            type: 'string',
                            example:
                                'Premier research university with cutting-edge programs',
                            description: 'Updated description',
                        },
                        logoUrl: {
                            type: 'string',
                            example:
                                'https://cdn.stanford.edu/new-logo-2024.png',
                            description: 'Updated logo URL',
                        },
                        website: {
                            type: 'string',
                            example: 'https://www.stanford.edu',
                            description: 'Updated website URL',
                        },
                        isActive: {
                            type: 'boolean',
                            example: true,
                            description: 'Updated active status',
                        },
                        updatedAt: {
                            type: 'string',
                            example: '2024-01-15T10:45:30.567Z',
                            description: 'Update timestamp',
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data or validation errors',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    example: [
                        'Organization name must be at least 2 characters long',
                        'Logo URL must be a valid URL',
                        'Website must be a valid URL',
                        'Invalid UUID format',
                    ],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Organization not found',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 404 },
                message: {
                    type: 'string',
                    example:
                        'Organization with ID a1b2c3d4-e5f6-7890-abcd-ef1234567890 not found',
                },
                error: { type: 'string', example: 'Not Found' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CONFLICT,
        description: '⚠️ Organization name already exists',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 409 },
                message: {
                    type: 'string',
                    example:
                        'Organization with name "Stanford University Medical Center" already exists',
                },
                error: { type: 'string', example: 'Conflict' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description: '🔥 Internal server error during organization update',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: { type: 'string', example: 'Internal server error' },
            },
        },
    })
    async updateOrganization(
        @Param('id') id: string,
        @Body() updateOrgDto: UpdateOrgDto,
    ) {
        this.logger.log(`Updating organization: ${id}`);
        return await this.orgService.updateOrganization(id, updateOrgDto);
    }

    @Delete(':id')
    @ApiOperation({
        summary: '🗑️ Delete Organization',
        description: `
        **Organization Removal - Complete Data Cleanup**
        
        ⚠️ **CRITICAL WARNING - IRREVERSIBLE ACTION**
        
        **🚨 What Gets Deleted:**
        - The organization record and all metadata
        - ALL associated branches and their data
        - User assignments and organizational relationships
        - Exams, courses, and content created under this organization
        - Historical data, reports, and analytics
        
        **💥 Cascade Effects:**
        - All users lose organizational affiliation
        - Active exams and tests become inaccessible
        - Branch-specific data and configurations removed
        - Integration connections and API access revoked
        
        **🛡️ Before Deletion Checklist:**
        - Export critical data and reports
        - Notify all users of pending closure
        - Complete any ongoing exams or assessments
        - Transfer ownership of shared content
        - Update integrations and external systems
        
        **🔄 Alternatives to Consider:**
        - Set organization as inactive instead of deletion
        - Transfer branches to another organization
        - Archive data before removal
        `,
        operationId: 'deleteOrganization',
    })
    @ApiParam({
        name: 'id',
        description: 'Organization unique identifier to delete',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
        type: 'string',
        format: 'uuid',
    })
    @ApiResponse({
        status: HttpStatus.NO_CONTENT,
        description:
            '✅ Organization deleted successfully - All data permanently removed',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Deletion operation success status',
                },
                message: {
                    type: 'string',
                    example: 'Organization deleted successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'null',
                    description: 'No data returned for deletion operations',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid organization ID format',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: { type: 'string', example: 'Invalid UUID format' },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description:
            '❌ Organization not found - May have been already deleted',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 404 },
                message: {
                    type: 'string',
                    example:
                        'Organization with ID a1b2c3d4-e5f6-7890-abcd-ef1234567890 not found',
                },
                error: { type: 'string', example: 'Not Found' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description:
            '🚫 Forbidden - Organization has dependent data that prevents deletion',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 403 },
                message: {
                    type: 'string',
                    example:
                        'Cannot delete organization with active branches or users',
                },
                error: { type: 'string', example: 'Forbidden' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description: '🔥 Internal server error during organization deletion',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: { type: 'string', example: 'Internal server error' },
            },
        },
    })
    async deleteOrganization(@Param('id') id: string) {
        this.logger.log(`Deleting organization: ${id}`);
        await this.orgService.deleteOrganization(id);
    }

    // Branch endpoints
    @Post(':organizationId/branches')
    @ApiOperation({
        summary: '🏪 Create Branch Location',
        description: `
        **Branch Creation - Expand Organizational Reach**
        
        **🌍 Why Branches Are Essential:**
        Branches represent the physical and operational divisions within organizations:
        
        **🏫 Educational Institutions:**
        - Multiple campuses (Main Campus, Medical Center, Law School)
        - Departments (Engineering, Business, Arts & Sciences)
        - Regional centers and satellite locations
        - Research facilities and specialized labs
        
        **🏢 Corporate Organizations:**
        - Regional offices (North America, Europe, Asia-Pacific)
        - Business units (Sales, Engineering, Customer Support)
        - Training centers and learning facilities
        - Remote work hubs and co-working spaces
        
        **🎯 Operational Benefits:**
        - **Localized Management**: Branch-specific administrators and policies
        - **Geographic Distribution**: Serve users across different locations
        - **Resource Allocation**: Dedicated equipment and facility management
        - **Scheduling Optimization**: Location-specific exam scheduling
        - **Compliance Alignment**: Meet local regulatory requirements
        
        **📊 Exam Management Value:**
        - Users assigned to specific branches for better organization
        - Proctored exams can be location-specific
        - Resource planning based on branch capacity
        - Local support and technical assistance
        - Branch-level reporting and analytics
        `,
        operationId: 'createBranch',
    })
    @ApiParam({
        name: 'organizationId',
        description: 'Parent organization identifier',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
        type: 'string',
        format: 'uuid',
    })
    @ApiBody({
        type: CreateBranchDto,
        description: 'Branch creation data with operational details',
        examples: {
            campus: {
                summary: '🏫 University Campus',
                description: 'Educational institution campus branch',
                value: {
                    name: 'Medical Center Campus',
                    address:
                        '450 Medical Plaza Drive, Health Sciences District, CA 90095',
                    contactNumber: '+1-310-825-9111',
                    email: 'medcenter@university.edu',
                    managerName: 'Dr. Sarah Johnson',
                    operatingHours: {
                        opening: '07:00',
                        closing: '19:00',
                        days: [
                            'Monday',
                            'Tuesday',
                            'Wednesday',
                            'Thursday',
                            'Friday',
                            'Saturday',
                        ],
                    },
                },
            },
            office: {
                summary: '🏢 Corporate Office',
                description: 'Corporate regional office branch',
                value: {
                    name: 'Pacific Northwest Regional Office',
                    address:
                        '1200 Tech Tower, Innovation District, Seattle, WA 98101',
                    contactNumber: '+1-206-555-0199',
                    email: 'pnw.office@techcorp.com',
                    managerName: 'Michael Chen',
                    operatingHours: {
                        opening: '08:00',
                        closing: '18:00',
                        days: [
                            'Monday',
                            'Tuesday',
                            'Wednesday',
                            'Thursday',
                            'Friday',
                        ],
                    },
                },
            },
            training: {
                summary: '📚 Training Center',
                description:
                    'Professional development and certification center',
                value: {
                    name: 'Downtown Training Center',
                    address: '789 Learning Avenue, Business District, NY 10001',
                    contactNumber: '+1-212-555-0167',
                    email: 'downtown@skillsacademy.edu',
                    managerName: 'Lisa Rodriguez',
                    operatingHours: {
                        opening: '09:00',
                        closing: '21:00',
                        days: [
                            'Monday',
                            'Tuesday',
                            'Wednesday',
                            'Thursday',
                            'Friday',
                            'Saturday',
                        ],
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description:
            '✅ Branch created successfully - Ready for user assignment and exam scheduling',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success status',
                },
                message: {
                    type: 'string',
                    example: 'Branch created successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'object',
                    description: 'Created branch data',
                    properties: {
                        id: {
                            type: 'string',
                            example: 'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
                            description: 'Unique branch identifier',
                        },
                        name: {
                            type: 'string',
                            example: 'Medical Center Campus',
                            description: 'Branch name',
                        },
                        address: {
                            type: 'string',
                            example:
                                '450 Medical Plaza Drive, Health Sciences District, CA 90095',
                            description: 'Branch address',
                        },
                        contactNumber: {
                            type: 'string',
                            example: '+1-310-825-9111',
                            description: 'Branch contact phone',
                        },
                        email: {
                            type: 'string',
                            example: 'medcenter@university.edu',
                            description: 'Branch email address',
                        },
                        managerName: {
                            type: 'string',
                            example: 'Dr. Sarah Johnson',
                            description: 'Branch manager name',
                        },
                        operatingHours: {
                            type: 'object',
                            example: {
                                opening: '07:00',
                                closing: '19:00',
                                days: [
                                    'Monday',
                                    'Tuesday',
                                    'Wednesday',
                                    'Thursday',
                                    'Friday',
                                    'Saturday',
                                ],
                            },
                            description: 'Branch operating schedule',
                        },
                        isActive: {
                            type: 'boolean',
                            example: true,
                            description: 'Branch active status',
                        },
                        createdAt: {
                            type: 'string',
                            example: '2024-01-15T10:30:45.123Z',
                            description: 'Creation timestamp',
                        },
                        organization: {
                            type: 'object',
                            properties: {
                                id: {
                                    type: 'string',
                                    example:
                                        'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
                                },
                                name: {
                                    type: 'string',
                                    example: 'Stanford University',
                                },
                            },
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data or organization ID format',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    example: [
                        'Branch name must be at least 2 characters long',
                        'Email must be a valid email address',
                        'Invalid UUID format for organization ID',
                    ],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description:
            '❌ Organization not found - Cannot create branch without valid parent organization',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 404 },
                message: {
                    type: 'string',
                    example:
                        'Organization with ID a1b2c3d4-e5f6-7890-abcd-ef1234567890 not found',
                },
                error: { type: 'string', example: 'Not Found' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description: '🔥 Internal server error during branch creation',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: { type: 'string', example: 'Internal server error' },
            },
        },
    })
    async createBranch(
        @Param('organizationId') organizationId: string,
        @Body() createBranchDto: CreateBranchDto,
    ) {
        this.logger.log(
            `Creating branch "${createBranchDto.name}" in organization: ${organizationId}`,
        );
        return await this.orgService.createBranch(
            organizationId,
            createBranchDto,
        );
    }

    @Get(':organizationId/branches')
    @ApiOperation({
        summary: '🏪 List Organization Branches',
        description: `
        **Branch Directory - Complete Location Network**
        
        **🗺️ Comprehensive Branch Overview:**
        - All branches within the organization
        - Geographic distribution and location details
        - Contact information and local management
        - Operational status and availability
        
        **📋 Essential for Operations:**
        - **User Assignment**: Determine where users should be allocated
        - **Exam Scheduling**: Plan test sessions across locations
        - **Resource Planning**: Allocate equipment and personnel
        - **Communication**: Route inquiries to appropriate branches
        - **Compliance**: Ensure all locations meet standards
        
        **🎯 Management Applications:**
        - Facility utilization and capacity planning
        - Regional performance analysis and comparison
        - Emergency preparedness and business continuity
        - Quality assurance and standardization efforts
        `,
        operationId: 'getOrganizationBranches',
    })
    @ApiParam({
        name: 'organizationId',
        description: 'Organization identifier to list branches',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description:
            '✅ Branches retrieved successfully with operational details',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Organization not found - Cannot list branches',
    })
    async findAllBranches(@Param('organizationId') organizationId: string) {
        this.logger.log(
            `Retrieving branches for organization: ${organizationId}`,
        );
        return await this.orgService.findAllBranches(organizationId);
    }

    @Get(':organizationId/branches/:branchId')
    @ApiOperation({
        summary: '🔍 Get Branch Details',
        description: `
        **Branch Profile - Complete Location Information**
        
        **🏢 Detailed Branch Information:**
        - Complete branch profile and contact details
        - Operating schedules and availability windows
        - Local management and administrative contacts
        - Parent organization context and relationships
        
        **🎯 Critical Operational Data:**
        - **Scheduling**: Plan exams during operating hours
        - **Support**: Direct users to appropriate contacts
        - **Logistics**: Coordinate equipment and resource delivery
        - **Emergency**: Access location and contact information
        - **Compliance**: Verify operational standards and requirements
        `,
        operationId: 'getBranchById',
    })
    @ApiParam({
        name: 'organizationId',
        description: 'Parent organization identifier',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    @ApiParam({
        name: 'branchId',
        description: 'Branch unique identifier',
        example: 'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Branch retrieved successfully with complete details',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Branch or organization not found',
    })
    async findBranchById(
        @Param('organizationId') organizationId: string,
        @Param('branchId') branchId: string,
    ) {
        this.logger.log(
            `Retrieving branch ${branchId} from organization: ${organizationId}`,
        );
        return await this.orgService.findBranchById(organizationId, branchId);
    }

    @Put(':organizationId/branches/:branchId')
    @ApiOperation({
        summary: '✏️ Update Branch Information',
        description: `
        **Branch Management - Keep Location Data Current**
        
        **🔄 Updatable Branch Information:**
        - Contact details and address changes
        - Operating hours and schedule modifications
        - Management personnel updates
        - Service availability and status changes
        
        **🎯 Why Branch Updates Matter:**
        - **User Experience**: Accurate contact and location information
        - **Operational Efficiency**: Current schedules for exam planning
        - **Emergency Preparedness**: Up-to-date contact information
        - **Regulatory Compliance**: Maintain accurate records
        - **Quality Assurance**: Reflect current management and capabilities
        
        **📋 Common Update Scenarios:**
        - Facility relocations or address changes
        - Management personnel transitions
        - Operating hour adjustments for seasonal changes
        - Contact information updates for better communication
        - Status changes for temporary closures or maintenance
        `,
        operationId: 'updateBranch',
    })
    @ApiParam({
        name: 'organizationId',
        description: 'Parent organization identifier',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    @ApiParam({
        name: 'branchId',
        description: 'Branch unique identifier to update',
        example: 'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
    })
    @ApiBody({
        type: UpdateBranchDto,
        description: 'Branch update data (all fields optional)',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Branch updated successfully',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Branch or organization not found',
    })
    async updateBranch(
        @Param('organizationId') organizationId: string,
        @Param('branchId') branchId: string,
        @Body() updateBranchDto: UpdateBranchDto,
    ) {
        this.logger.log(
            `Updating branch ${branchId} in organization: ${organizationId}`,
        );
        return await this.orgService.updateBranch(
            organizationId,
            branchId,
            updateBranchDto,
        );
    }

    @Delete(':organizationId/branches/:branchId')
    @ApiOperation({
        summary: '🗑️ Delete Branch',
        description: `
        **Branch Removal - Location Closure**
        
        ⚠️ **Important Considerations Before Deletion:**
        
        **🚨 Impact Assessment:**
        - Users currently assigned to this branch
        - Active exams scheduled at this location
        - Equipment and resources allocated to the branch
        - Historical data and performance records
        
        **📋 Pre-deletion Checklist:**
        - Transfer users to alternative branches
        - Reschedule or relocate pending examinations
        - Reassign equipment and physical resources
        - Archive important branch-specific data
        - Update organizational directory and communications
        
        **🔄 Alternative Approaches:**
        - Set branch as inactive instead of permanent deletion
        - Merge with another branch location
        - Convert to remote/virtual branch status
        
        **💡 Data Preservation:**
        - Export branch-specific reports and analytics
        - Document closure reason for compliance
        - Maintain contact information for reference
        `,
        operationId: 'deleteBranch',
    })
    @ApiParam({
        name: 'organizationId',
        description: 'Parent organization identifier',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    @ApiParam({
        name: 'branchId',
        description: 'Branch unique identifier to delete',
        example: 'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
    })
    @ApiResponse({
        status: HttpStatus.NO_CONTENT,
        description:
            '✅ Branch deleted successfully - Users and resources should be reallocated',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Branch or organization not found',
    })
    async deleteBranch(
        @Param('organizationId') organizationId: string,
        @Param('branchId') branchId: string,
    ) {
        this.logger.log(
            `Deleting branch ${branchId} from organization: ${organizationId}`,
        );
        await this.orgService.deleteBranch(organizationId, branchId);
    }
}

/*
 * Class #126: OrgModule
 * Source: org/org.module.ts:14
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 25 characters (1 lines)
 */
export class OrgModule {}

/*
 * Class #127: OrgService
 * Source: org/org.service.ts:18
 * Type: Exported Class
 * Methods: 20
 * Properties: 38
 * Decorators: 2
 * Complexity: 112
 * Size: 8619 characters (253 lines)
 */
export class OrgService {
    constructor(
        @InjectRepository(Organization)
        private readonly organizationRepository: Repository<Organization>,
        @InjectRepository(Branch)
        private readonly branchRepository: Repository<Branch>,
        private readonly eventEmitter: EventEmitter2,
    ) {}

    private async retryOperation<T>(
        operation: () => Promise<T>,
        maxRetries = 3,
        delay = 1000,
    ): Promise<T> {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                const isConnectionError =
                    error instanceof Error &&
                    (error.message.includes('ECONNRESET') ||
                        error.message.includes('Connection lost') ||
                        error.message.includes('connect ETIMEDOUT'));

                if (isConnectionError && attempt < maxRetries) {
                    console.log(
                        `Database connection error on attempt ${attempt}, retrying in ${delay}ms...`,
                    );
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                    continue;
                }
                throw error;
            }
        }
        throw new Error('Max retries exceeded');
    }

    // Organization CRUD operations
    async createOrganization(
        createOrgDto: CreateOrgDto,
    ): Promise<Organization> {
        return this.retryOperation(async () => {
            // Check if organization name already exists
            const existingOrg = await this.organizationRepository.findOne({
                where: { name: createOrgDto.name },
            });

            if (existingOrg) {
                throw new ConflictException(
                    `Organization with name "${createOrgDto.name}" already exists`,
                );
            }

            const organization =
                this.organizationRepository.create(createOrgDto);
            const savedOrganization =
                await this.organizationRepository.save(organization);

            // Emit organization created event
            this.eventEmitter.emit(
                'organization.created',
                new OrganizationCreatedEvent(
                    savedOrganization.id,
                    savedOrganization.name,
                    savedOrganization.email || '',
                    savedOrganization.logoUrl,
                    savedOrganization.website,
                ),
            );

            return savedOrganization;
        });
    }

    async findAllOrganizations(): Promise<Organization[]> {
        return this.retryOperation(async () => {
            return await this.organizationRepository.find({
                relations: ['branches'],
                order: { createdAt: 'DESC' },
            });
        });
    }

    async findOrganizationById(id: string): Promise<Organization> {
        const organization = await this.retryOperation(async () => {
            return await this.organizationRepository.findOne({
                where: { id },
                relations: ['branches'],
            });
        });

        if (!organization) {
            throw new NotFoundException(`Organization with ID ${id} not found`);
        }

        return organization;
    }

    async updateOrganization(
        id: string,
        updateOrgDto: UpdateOrgDto,
    ): Promise<Organization> {
        return this.retryOperation(async () => {
            // Check if organization exists
            const organization = await this.findOrganizationById(id);

            // Check if name is being updated and if it conflicts
            if (updateOrgDto.name && updateOrgDto.name !== organization.name) {
                const existingOrg = await this.organizationRepository.findOne({
                    where: { name: updateOrgDto.name },
                });

                if (existingOrg) {
                    throw new ConflictException(
                        `Organization with name "${updateOrgDto.name}" already exists`,
                    );
                }
            }

            await this.organizationRepository.update(id, updateOrgDto);
            return await this.findOrganizationById(id);
        });
    }

    async deleteOrganization(id: string): Promise<void> {
        return this.retryOperation(async () => {
            const organization = await this.findOrganizationById(id);
            await this.organizationRepository.remove(organization);
        });
    }

    // Branch CRUD operations
    async createBranch(
        organizationId: string,
        createBranchDto: CreateBranchDto,
    ): Promise<Branch> {
        return this.retryOperation(async () => {
            const organization =
                await this.findOrganizationById(organizationId);

            const branch = this.branchRepository.create({
                ...createBranchDto,
                organization,
            });

            const savedBranch = await this.branchRepository.save(branch);

            // Emit branch created event
            this.eventEmitter.emit(
                'branch.created',
                new BranchCreatedEvent(
                    savedBranch.id,
                    savedBranch.name,
                    savedBranch.email || '',
                    organization.id,
                    organization.name,
                    savedBranch.address,
                    savedBranch.contactNumber,
                    savedBranch.managerName,
                ),
            );

            return savedBranch;
        });
    }

    async findAllBranches(organizationId: string): Promise<Branch[]> {
        return this.retryOperation(async () => {
            // Verify organization exists
            await this.findOrganizationById(organizationId);

            return await this.branchRepository.find({
                where: { organization: { id: organizationId } },
                relations: ['organization'],
                order: { createdAt: 'DESC' },
            });
        });
    }

    async findBranchById(
        organizationId: string,
        branchId: string,
    ): Promise<Branch> {
        const branch = await this.retryOperation(async () => {
            return await this.branchRepository.findOne({
                where: { id: branchId, organization: { id: organizationId } },
                relations: ['organization'],
            });
        });

        if (!branch) {
            throw new NotFoundException(
                `Branch with ID ${branchId} not found in organization ${organizationId}`,
            );
        }

        return branch;
    }

    async updateBranch(
        organizationId: string,
        branchId: string,
        updateBranchDto: UpdateBranchDto,
    ): Promise<Branch> {
        return this.retryOperation(async () => {
            const branch = await this.findBranchById(organizationId, branchId);
            await this.branchRepository.update(branchId, updateBranchDto);
            return await this.findBranchById(organizationId, branchId);
        });
    }

    async deleteBranch(
        organizationId: string,
        branchId: string,
    ): Promise<void> {
        return this.retryOperation(async () => {
            const branch = await this.findBranchById(organizationId, branchId);
            await this.branchRepository.remove(branch);
        });
    }

    // Additional utility methods
    async findOrganizationByName(name: string): Promise<Organization | null> {
        return this.retryOperation(async () => {
            return await this.organizationRepository.findOne({
                where: { name },
                relations: ['branches'],
            });
        });
    }

    async getOrganizationStats(id: string) {
        return this.retryOperation(async () => {
            const organization = await this.findOrganizationById(id);
            const totalBranches = await this.branchRepository.count({
                where: { organization: { id } },
            });
            const activeBranches = await this.branchRepository.count({
                where: { organization: { id }, isActive: true },
            });

            return {
                organization,
                stats: {
                    totalBranches,
                    activeBranches,
                    inactiveBranches: totalBranches - activeBranches,
                },
            };
        });
    }
}

/*
 * Class #128: BulkCreateQuestionsDto
 * Source: questions/dto/bulk-create-questions.dto.ts:6
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 4
 * Complexity: 9
 * Size: 275 characters (10 lines)
 */
export class BulkCreateQuestionsDto {
    @ApiProperty({
        description: 'Array of questions to create',
        type: [CreateQuestionDto],
    })
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CreateQuestionDto)
    questions: CreateQuestionDto[];
}

/*
 * Class #129: CreateQuestionDto
 * Source: questions/dto/create-question.dto.ts:12
 * Type: Exported Class
 * Methods: 0
 * Properties: 9
 * Decorators: 17
 * Complexity: 40
 * Size: 1096 characters (48 lines)
 */
export class CreateQuestionDto {
    @ApiProperty({
        description: 'Test ID that this question belongs to',
        example: 1,
    })
    @IsNumber()
    @IsNotEmpty()
    testId: number;

    @ApiProperty({
        description: 'The question text/content',
        example: 'What is the time complexity of binary search algorithm?',
    })
    @IsString()
    @IsNotEmpty()
    questionText: string;

    @ApiProperty({
        description: 'Type of question',
        example: QuestionType.MULTIPLE_CHOICE,
        enum: QuestionType,
    })
    @IsEnum(QuestionType)
    @IsNotEmpty()
    questionType: QuestionType;

    @ApiProperty({
        description: 'Points awarded for correct answer',
        example: 5,
        minimum: 1,
    })
    @IsNumber()
    @IsNotEmpty()
    @Min(1)
    points: number;

    @ApiProperty({
        description:
            'Order index of the question in the test (will auto-increment if not provided)',
        example: 1,
        minimum: 1,
        required: false,
    })
    @IsNumber()
    @IsOptional()
    @Min(1)
    orderIndex?: number;
}

/*
 * Class #130: QuestionFilterDto
 * Source: questions/dto/question-filter.dto.ts:12
 * Type: Exported Class
 * Methods: 0
 * Properties: 28
 * Decorators: 33
 * Complexity: 76
 * Size: 1797 characters (87 lines)
 */
export class QuestionFilterDto {
    @ApiProperty({
        description: 'Filter by test ID',
        example: 1,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    @Type(() => Number)
    testId?: number;

    @ApiProperty({
        description: 'Filter by question type',
        enum: QuestionType,
        required: false,
    })
    @IsOptional()
    @IsEnum(QuestionType)
    questionType?: QuestionType;

    @ApiProperty({
        description: 'Filter by minimum points',
        example: 1,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    @Min(1)
    @Type(() => Number)
    minPoints?: number;

    @ApiProperty({
        description: 'Filter by maximum points',
        example: 10,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    @Min(1)
    @Type(() => Number)
    maxPoints?: number;

    @ApiProperty({
        description: 'Filter by creation date from',
        example: '2024-01-01',
        required: false,
    })
    @IsOptional()
    @IsDateString()
    createdFrom?: string;

    @ApiProperty({
        description: 'Filter by creation date to',
        example: '2024-12-31',
        required: false,
    })
    @IsOptional()
    @IsDateString()
    createdTo?: string;

    @ApiProperty({
        description: 'Page number for pagination',
        example: 1,
        minimum: 1,
        default: 1,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    @Min(1)
    @Type(() => Number)
    page?: number = 1;

    @ApiProperty({
        description: 'Number of items per page',
        example: 10,
        minimum: 1,
        maximum: 100,
        default: 10,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    @Min(1)
    @Type(() => Number)
    pageSize?: number = 10;
}

/*
 * Class #131: QuestionListResponseDto
 * Source: questions/dto/question-list-response.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 6
 * Decorators: 6
 * Complexity: 14
 * Size: 779 characters (37 lines)
 */
export class QuestionListResponseDto {
    @ApiProperty({
        description: 'Array of questions',
        type: [QuestionResponseDto],
    })
    questions: QuestionResponseDto[];

    @ApiProperty({
        description: 'Total number of questions',
        example: 50,
    })
    total: number;

    @ApiProperty({
        description: 'Current page number',
        example: 1,
    })
    page: number;

    @ApiProperty({
        description: 'Number of questions per page',
        example: 10,
    })
    pageSize: number;

    @ApiProperty({
        description: 'Total number of pages',
        example: 5,
    })
    totalPages: number;

    @ApiProperty({
        description: 'Total points for all questions',
        example: 125,
    })
    totalPoints: number;
}

/*
 * Class #132: QuestionResponseDto
 * Source: questions/dto/question-response.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 14
 * Decorators: 11
 * Complexity: 30
 * Size: 1715 characters (74 lines)
 */
export class QuestionResponseDto {
    @ApiProperty({
        description: 'Question unique identifier',
        example: 1,
    })
    questionId: number;

    @ApiProperty({
        description: 'Test ID that this question belongs to',
        example: 1,
    })
    testId: number;

    @ApiProperty({
        description: 'The question text/content',
        example: 'What is the time complexity of binary search algorithm?',
    })
    questionText: string;

    @ApiProperty({
        description: 'Type of question',
        example: QuestionType.MULTIPLE_CHOICE,
        enum: QuestionType,
    })
    questionType: QuestionType;

    @ApiProperty({
        description: 'Points awarded for correct answer',
        example: 5,
    })
    points: number;

    @ApiProperty({
        description: 'Order index of the question in the test',
        example: 1,
    })
    orderIndex: number;

    @ApiProperty({
        description: 'Question creation timestamp',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @ApiProperty({
        description: 'Question last update timestamp',
        example: '2024-01-15T10:30:45.123Z',
    })
    updatedAt: Date;

    @ApiProperty({
        description: 'Test information',
        required: false,
    })
    test?: {
        testId: number;
        title: string;
        testType: string;
    };

    @ApiProperty({
        description: 'Number of answer options for this question',
        example: 4,
        required: false,
    })
    optionsCount?: number;

    @ApiProperty({
        description: 'Number of answers submitted for this question',
        example: 25,
        required: false,
    })
    answersCount?: number;
}

/*
 * Class #133: StandardApiResponse
 * Source: questions/dto/question-response.dto.ts:80
 * Type: Exported Class
 * Methods: 0
 * Properties: 11
 * Decorators: 4
 * Complexity: 15
 * Size: 803 characters (34 lines)
 */
export class StandardApiResponse<T = any> {
    @ApiProperty({
        description: 'Indicates if the operation was successful',
        example: true,
    })
    success: boolean;

    @ApiProperty({
        description: 'Human-readable message about the operation result',
        example: 'Question created successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Response data payload',
        required: false,
    })
    data?: T;

    @ApiProperty({
        description: 'Additional metadata about the response',
        required: false,
    })
    meta?: {
        timestamp?: string;
        requestId?: string;
        pagination?: {
            page: number;
            limit: number;
            total: number;
            totalPages: number;
        };
    };
}

/*
 * Class #134: QuestionApiResponse
 * Source: questions/dto/question-response.dto.ts:115
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 1
 * Complexity: 4
 * Size: 238 characters (7 lines)
 * Extends: StandardApiResponse<QuestionResponseDto>
 */
export class QuestionApiResponse extends StandardApiResponse<QuestionResponseDto> {
    @ApiProperty({
        description: 'Question data retrieved successfully',
        type: QuestionResponseDto,
    })
    data: QuestionResponseDto;
}

/*
 * Class #135: QuestionListApiResponse
 * Source: questions/dto/question-response.dto.ts:123
 * Type: Exported Class
 * Methods: 0
 * Properties: 6
 * Decorators: 0
 * Complexity: 2
 * Size: 214 characters (8 lines)
 * Extends: StandardApiResponse<
 */
export class QuestionListApiResponse extends StandardApiResponse<{
    questions: QuestionResponseDto[];
    total: number;
    page: number;
    pageSize: number;
    totalPages: number;
    totalPoints: number;
}

/*
 * Class #136: QuestionCreatedResponse
 * Source: questions/dto/question-response.dto.ts:178
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 7
 * Size: 419 characters (19 lines)
 */
export class QuestionCreatedResponse {
    @ApiProperty({
        description: 'Question creation success message',
        example: 'Question created successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 201,
    })
    code: number;
}

/*
 * Class #137: QuestionUpdatedResponse
 * Source: questions/dto/question-response.dto.ts:198
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 7
 * Size: 417 characters (19 lines)
 */
export class QuestionUpdatedResponse {
    @ApiProperty({
        description: 'Question update success message',
        example: 'Question updated successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #138: QuestionDeletedResponse
 * Source: questions/dto/question-response.dto.ts:218
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 7
 * Size: 419 characters (19 lines)
 */
export class QuestionDeletedResponse {
    @ApiProperty({
        description: 'Question deletion success message',
        example: 'Question deleted successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #139: QuestionsReorderedResponse
 * Source: questions/dto/question-response.dto.ts:238
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 7
 * Size: 425 characters (19 lines)
 */
export class QuestionsReorderedResponse {
    @ApiProperty({
        description: 'Questions reorder success message',
        example: 'Questions reordered successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #140: BulkQuestionsCreatedResponse
 * Source: questions/dto/question-response.dto.ts:258
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 7
 * Size: 433 characters (19 lines)
 */
export class BulkQuestionsCreatedResponse {
    @ApiProperty({
        description: 'Bulk questions creation success message',
        example: '5 questions created successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 201,
    })
    code: number;
}

/*
 * Class #141: UpdateQuestionDto
 * Source: questions/dto/update-question.dto.ts:4
 * Type: Exported Class
 * Methods: 1
 * Properties: 0
 * Decorators: 0
 * Complexity: 4
 * Size: 110 characters (3 lines)
 * Extends: PartialType(
    OmitType(CreateQuestionDto, ['testId'] as const),
)
 */
export class UpdateQuestionDto extends PartialType(
    OmitType(CreateQuestionDto, ['testId'] as const),
) {}

/*
 * Class #142: Question
 * Source: questions/entities/question.entity.ts:30
 * Type: Exported Class
 * Methods: 1
 * Properties: 21
 * Decorators: 36
 * Complexity: 78
 * Size: 2318 characters (103 lines)
 */
export class Question {
    @PrimaryGeneratedColumn()
    @ApiProperty({
        description: 'Question unique identifier',
        example: 1,
    })
    questionId: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Test ID that this question belongs to',
        example: 1,
    })
    @IsNumber()
    @IsNotEmpty()
    testId: number;

    @Column('text')
    @ApiProperty({
        description: 'The question text/content',
        example: 'What is the time complexity of binary search algorithm?',
    })
    @IsString()
    @IsNotEmpty()
    questionText: string;

    @Column({
        type: 'enum',
        enum: QuestionType,
    })
    @ApiProperty({
        description: 'Type of question',
        example: QuestionType.MULTIPLE_CHOICE,
        enum: QuestionType,
    })
    @IsEnum(QuestionType)
    @IsNotEmpty()
    questionType: QuestionType;

    @Column()
    @ApiProperty({
        description: 'Points awarded for correct answer',
        example: 5,
        minimum: 1,
    })
    @IsNumber()
    @IsNotEmpty()
    @Min(1)
    points: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Order index of the question in the test',
        example: 1,
        minimum: 1,
    })
    @IsNumber()
    @IsNotEmpty()
    @Min(1)
    orderIndex: number;

    @CreateDateColumn()
    @ApiProperty({
        description: 'Question creation timestamp',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @UpdateDateColumn()
    @ApiProperty({
        description: 'Question last update timestamp',
        example: '2024-01-15T10:30:45.123Z',
    })
    updatedAt: Date;

    @ManyToOne(() => Organization, { nullable: false })
    @ApiProperty({
        description: 'Organization this question belongs to',
        type: () => Organization,
    })
    orgId: Organization;

    @ManyToOne(() => Branch, { nullable: true })
    @ApiProperty({
        description: 'Branch this question belongs to',
        type: () => Branch,
        required: false,
    })
    branchId?: Branch;

    // Relations
    @ManyToOne(() => Test, { onDelete: 'CASCADE' })
    test: Test;

    @OneToMany('QuestionOption', 'question')
    options: any[];

    constructor(partial: Partial<Question>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #143: QuestionsController
 * Source: questions/questions.controller.ts:59
 * Type: Exported Class
 * Methods: 17
 * Properties: 237
 * Decorators: 66
 * Complexity: 231
 * Size: 18538 characters (583 lines)
 */
export class QuestionsController {
    private readonly logger = new Logger(QuestionsController.name);

    constructor(private readonly questionsService: QuestionsService) {}

    @Post()
    @HttpCode(HttpStatus.CREATED)
    @ApiOperation({
        summary: '➕ Create New Question',
        description: `
      **Creates a new question for a test with comprehensive validation**
      
      This endpoint allows authorized users to create questions for tests within their organization scope:
      - Validates test access and permissions
      - Automatically assigns organization and branch context
      - Supports various question types (multiple choice, true/false, etc.)
      - Auto-increments order index if not provided
      - Comprehensive caching invalidation
      
      **Security Features:**
      - Requires valid JWT authentication
      - Organization/branch scope validation
      - Test ownership verification
      
      **Use Cases:**
      - Test content creation
      - Question bank building
      - Educational content management
      - Assessment development
    `,
        operationId: 'createQuestion',
    })
    @ApiBody({
        type: CreateQuestionDto,
        description: 'Question creation data',
        examples: {
            'multiple-choice': {
                summary: '🔘 Multiple Choice Question',
                description: 'Creates a multiple choice question',
                value: {
                    testId: 1,
                    questionText:
                        'What is the time complexity of binary search?',
                    questionType: 'multiple_choice',
                    points: 5,
                    orderIndex: 1,
                },
            },
            'true-false': {
                summary: '✅ True/False Question',
                description: 'Creates a true/false question',
                value: {
                    testId: 1,
                    questionText: 'Binary search works only on sorted arrays.',
                    questionType: 'true_false',
                    points: 3,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description: '✅ Question created successfully',
        type: QuestionCreatedResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data or validation errors',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    examples: [
                        'Question text is required',
                        'Points must be a positive number',
                        'Invalid question type',
                    ],
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 400 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Test not found',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'Test with ID 1 not found',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 404 },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CONFLICT,
        description: '⚠️ Order index conflict',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example:
                        'Question with order index 1 already exists in this test',
                },
                status: { type: 'string', example: 'error' },
                code: { type: 'number', example: 409 },
            },
        },
    })
    async create(
        @Body() createQuestionDto: CreateQuestionDto,
        @OrgBranchScope() scope: any,
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(
                `Creating question for test ${createQuestionDto.testId} by user: ${req.user.id}`,
            );

            return await this.questionsService.create(createQuestionDto, scope);
        } catch (error) {
            this.logger.error(
                `Error creating question for user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Post('bulk')
    @HttpCode(HttpStatus.CREATED)
    @ApiOperation({
        summary: '📦 Create Multiple Questions in Bulk',
        description: `
      **Creates multiple questions simultaneously with transaction safety**
      
      This endpoint allows batch creation of questions for efficient content management:
      - All questions created in a single transaction
      - Rollback on any failure ensures data consistency
      - Validates all questions before creation
      - Comprehensive cache invalidation for all affected tests
      
      **Use Cases:**
      - Bulk content import
      - Test template creation
      - Educational content migration
      - Batch question uploads
    `,
        operationId: 'createBulkQuestions',
    })
    @ApiBody({
        type: BulkCreateQuestionsDto,
        description: 'Bulk questions creation data',
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description: '✅ Questions created successfully in bulk',
        type: BulkQuestionsCreatedResponse,
    })
    async createBulk(
        @Body() bulkCreateDto: BulkCreateQuestionsDto,
        @OrgBranchScope() scope: any,
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(
                `Creating ${bulkCreateDto.questions.length} questions in bulk by user: ${req.user.id}`,
            );

            return await this.questionsService.createBulk(bulkCreateDto, scope);
        } catch (error) {
            this.logger.error(
                `Error creating bulk questions for user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Get('test/:testId')
    @ApiOperation({
        summary: '📋 Get Questions by Test',
        description: `
      **Retrieves all questions for a specific test with filtering and pagination**
      
      This endpoint provides comprehensive question listing with:
      - Advanced filtering by question type, points range, creation date
      - Pagination support for large question sets
      - Total points calculation for the test
      - Comprehensive caching for performance
      
      **Filtering Options:**
      - Question type (multiple_choice, true_false, etc.)
      - Points range (minimum and maximum)
      - Creation date range
      - Pagination (page, pageSize)
    `,
        operationId: 'getQuestionsByTest',
    })
    @ApiParam({
        name: 'testId',
        description: 'Test ID to retrieve questions for',
        example: 1,
    })
    @ApiQuery({
        name: 'questionType',
        required: false,
        description: 'Filter by question type',
        example: 'multiple_choice',
    })
    @ApiQuery({
        name: 'minPoints',
        required: false,
        description: 'Minimum points filter',
        example: 1,
    })
    @ApiQuery({
        name: 'maxPoints',
        required: false,
        description: 'Maximum points filter',
        example: 10,
    })
    @ApiQuery({
        name: 'page',
        required: false,
        description: 'Page number for pagination',
        example: 1,
    })
    @ApiQuery({
        name: 'pageSize',
        required: false,
        description: 'Number of questions per page',
        example: 10,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Questions retrieved successfully',
        type: QuestionListApiResponse,
    })
    async findByTest(
        @Param('testId', ParseIntPipe) testId: number,
        @Query() filters: QuestionFilterDto,
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardApiResponse> {
        try {
            this.logger.log(
                `Getting questions for test ${testId} by user: ${req.user.id}`,
            );

            const result = await this.questionsService.findByTest(
                testId,
                req.user.id,
                filters,
            );

            return {
                success: true,
                message: 'Questions retrieved successfully',
                data: result,
                meta: {
                    timestamp: new Date().toISOString(),
                    pagination: {
                        page: result.page,
                        limit: result.pageSize,
                        total: result.total,
                        totalPages: result.totalPages,
                    },
                },
            };
        } catch (error) {
            this.logger.error(
                `Error getting questions for test ${testId} by user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Get(':id')
    @ApiOperation({
        summary: '🔍 Get Question by ID',
        description: `
      **Retrieves a single question with comprehensive details**
      
      This endpoint provides detailed question information including:
      - Complete question data with test context
      - Related options count (when implemented)
      - Answer statistics (when implemented)
      - Comprehensive caching for performance
    `,
        operationId: 'getQuestionById',
    })
    @ApiParam({
        name: 'id',
        description: 'Question ID to retrieve',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Question retrieved successfully',
        type: QuestionApiResponse,
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Question not found',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: false },
                message: {
                    type: 'string',
                    example: 'Question with ID 1 not found',
                },
                data: { type: 'null' },
            },
        },
    })
    async findOne(
        @Param('id', ParseIntPipe) id: number,
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardApiResponse> {
        try {
            this.logger.log(`Getting question ${id} by user: ${req.user.id}`);

            const question = await this.questionsService.findOne(
                id,
                req.user.id,
            );

            return {
                success: true,
                message: 'Question retrieved successfully',
                data: question,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                `Error getting question ${id} by user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Patch(':id')
    @ApiOperation({
        summary: '✏️ Update Question',
        description: `
      **Updates an existing question with validation and cache management**
      
      This endpoint allows updating question properties including:
      - Question text and type modifications
      - Points value adjustments
      - Order index changes (with conflict checking)
      - Comprehensive cache invalidation
    `,
        operationId: 'updateQuestion',
    })
    @ApiParam({
        name: 'id',
        description: 'Question ID to update',
        example: 1,
    })
    @ApiBody({
        type: UpdateQuestionDto,
        description: 'Question update data',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Question updated successfully',
        type: QuestionUpdatedResponse,
    })
    async update(
        @Param('id', ParseIntPipe) id: number,
        @Body() updateQuestionDto: UpdateQuestionDto,
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(`Updating question ${id} by user: ${req.user.id}`);

            return await this.questionsService.update(
                id,
                updateQuestionDto,
                req.user.id,
            );
        } catch (error) {
            this.logger.error(
                `Error updating question ${id} by user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Patch('reorder/:testId')
    @ApiOperation({
        summary: '🔄 Reorder Questions in Test',
        description: `
      **Reorders questions within a test with transaction safety**
      
      This endpoint allows bulk reordering of questions for better test organization:
      - Transaction-based updates ensure consistency
      - Comprehensive cache invalidation
      - Batch processing for efficiency
    `,
        operationId: 'reorderQuestions',
    })
    @ApiParam({
        name: 'testId',
        description: 'Test ID to reorder questions for',
        example: 1,
    })
    @ApiBody({
        description: 'Array of question reorder data',
        schema: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    questionId: { type: 'number', example: 1 },
                    newOrderIndex: { type: 'number', example: 2 },
                },
                required: ['questionId', 'newOrderIndex'],
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Questions reordered successfully',
        type: QuestionsReorderedResponse,
    })
    async reorder(
        @Param('testId', ParseIntPipe) testId: number,
        @Body() reorderData: { questionId: number; newOrderIndex: number }[],
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(
                `Reordering questions in test ${testId} by user: ${req.user.id}`,
            );

            return await this.questionsService.reorder(
                testId,
                reorderData,
                req.user.id,
            );
        } catch (error) {
            this.logger.error(
                `Error reordering questions in test ${testId} by user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Delete(':id')
    @ApiOperation({
        summary: '🗑️ Delete Question',
        description: `
      **Deletes a question with validation and cache management**
      
      This endpoint safely removes questions with:
      - Answer dependency checking (when implemented)
      - Comprehensive cache invalidation
      - Audit trail preservation
      - Transaction safety
    `,
        operationId: 'deleteQuestion',
    })
    @ApiParam({
        name: 'id',
        description: 'Question ID to delete',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Question deleted successfully',
        type: QuestionDeletedResponse,
    })
    async remove(
        @Param('id', ParseIntPipe) id: number,
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(`Deleting question ${id} by user: ${req.user.id}`);

            return await this.questionsService.remove(id, req.user.id);
        } catch (error) {
            this.logger.error(
                `Error deleting question ${id} by user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Get('test/:testId/count')
    @ApiOperation({
        summary: '🔢 Get Question Count for Test',
        description: `
      **Retrieves the total number of questions in a test with caching**
      
      This endpoint provides efficient question counting with:
      - Comprehensive caching for performance
      - Fast count retrieval without full data loading
      - Test validation and access control
    `,
        operationId: 'getQuestionCount',
    })
    @ApiParam({
        name: 'testId',
        description: 'Test ID to count questions for',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Question count retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: {
                    type: 'string',
                    example: 'Question count retrieved successfully',
                },
                data: {
                    type: 'object',
                    properties: {
                        count: { type: 'number', example: 15 },
                        testId: { type: 'number', example: 1 },
                    },
                },
                meta: {
                    type: 'object',
                    properties: {
                        timestamp: {
                            type: 'string',
                            example: '2024-01-01T12:00:00.000Z',
                        },
                    },
                },
            },
        },
    })
    async getQuestionCount(
        @Param('testId', ParseIntPipe) testId: number,
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardApiResponse> {
        try {
            this.logger.log(
                `Getting question count for test ${testId} by user: ${req.user.id}`,
            );

            const count = await this.questionsService.getQuestionCount(testId);

            return {
                success: true,
                message: 'Question count retrieved successfully',
                data: {
                    count,
                    testId,
                },
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                `Error getting question count for test ${testId} by user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }
}

/*
 * Class #144: QuestionsModule
 * Source: questions/questions.module.ts:27
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 31 characters (1 lines)
 */
export class QuestionsModule {}

/*
 * Class #145: QuestionsService
 * Source: questions/questions.service.ts:38
 * Type: Exported Class
 * Methods: 48
 * Properties: 124
 * Decorators: 4
 * Complexity: 349
 * Size: 26475 characters (771 lines)
 */
export class QuestionsService {
    private readonly logger = new Logger(QuestionsService.name);

    // Cache keys with comprehensive coverage
    private readonly CACHE_KEYS = {
        QUESTION_BY_ID: (id: number) => `question:${id}`,
        QUESTIONS_BY_TEST: (testId: number, filters: string) =>
            `questions:test:${testId}:${filters}`,
        QUESTION_STATS: (testId: number) => `question:stats:${testId}`,
        QUESTION_LIST: (filters: string) => `questions:list:${filters}`,
        QUESTION_COUNT: (testId: number) => `question:count:${testId}`,
        TEST_QUESTIONS_CACHE: (testId: number) => `test:${testId}:questions`,
        USER_QUESTIONS: (userId: string) => `user:${userId}:questions`,
        ALL_QUESTIONS: 'questions:all',
    };

    // Cache TTL in seconds with different durations for different data types
    private readonly CACHE_TTL = {
        QUESTION: 300, // 5 minutes
        QUESTION_LIST: 180, // 3 minutes
        STATS: 600, // 10 minutes
        COUNT: 120, // 2 minutes
        USER_DATA: 240, // 4 minutes
        ALL_QUESTIONS: 900, // 15 minutes
    };

    constructor(
        @InjectRepository(Question)
        private readonly questionRepository: Repository<Question>,
        @InjectRepository(Test)
        private readonly testRepository: Repository<Test>,
        private readonly testService: TestService,
        private readonly dataSource: DataSource,
        @Inject(CACHE_MANAGER) private readonly cacheManager: Cache,
        private readonly answersService: AnswersService,
        @Inject(forwardRef(() => QuestionsOptionsService))
        private readonly questionsOptionsService: QuestionsOptionsService,
    ) {}

    /**
     * Retry database operations with exponential backoff
     */
    private async retryOperation<T>(
        operation: () => Promise<T>,
        maxRetries: number = 3,
        delay: number = 1000,
    ): Promise<T> {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                if (attempt === maxRetries) {
                    this.logger.error(
                        `Operation failed after ${maxRetries} attempts`,
                        error instanceof Error ? error.stack : String(error),
                    );
                    throw error;
                }
                this.logger.warn(
                    `Operation failed, attempt ${attempt}/${maxRetries}. Retrying in ${delay}ms...`,
                );
                await new Promise(resolve =>
                    setTimeout(resolve, delay * attempt),
                );
            }
        }
        throw new Error('Retry operation failed unexpectedly');
    }

    /**
     * Comprehensive cache invalidation methods
     */
    private async invalidateQuestionCache(
        questionId: number,
        testId?: number,
    ): Promise<void> {
        const keysToDelete = [this.CACHE_KEYS.QUESTION_BY_ID(questionId)];

        if (testId) {
            // Invalidate all test-related caches
            keysToDelete.push(
                this.CACHE_KEYS.QUESTION_STATS(testId),
                this.CACHE_KEYS.QUESTION_COUNT(testId),
                this.CACHE_KEYS.TEST_QUESTIONS_CACHE(testId),
            );

            // Invalidate pattern-based keys for test questions with different filters
            // Note: In production, you might want to use Redis SCAN or similar for pattern-based deletion
            this.logger.debug(`Invalidating cache patterns for test ${testId}`);
        }

        // Also invalidate general question lists
        keysToDelete.push(this.CACHE_KEYS.ALL_QUESTIONS);

        await Promise.all(
            keysToDelete.map(async key => {
                try {
                    await this.cacheManager.del(key);
                } catch (error) {
                    this.logger.warn(
                        `Failed to delete cache key ${key}:`,
                        error,
                    );
                }
            }),
        );
    }

    private async invalidateTestQuestionsCache(testId: number): Promise<void> {
        const keysToDelete = [
            this.CACHE_KEYS.QUESTION_STATS(testId),
            this.CACHE_KEYS.QUESTION_COUNT(testId),
            this.CACHE_KEYS.TEST_QUESTIONS_CACHE(testId),
            this.CACHE_KEYS.ALL_QUESTIONS,
        ];

        await Promise.all(
            keysToDelete.map(async key => {
                try {
                    await this.cacheManager.del(key);
                } catch (error) {
                    this.logger.warn(
                        `Failed to delete cache key ${key}:`,
                        error,
                    );
                }
            }),
        );
    }

    private async invalidateUserQuestionsCache(userId: string): Promise<void> {
        const keysToDelete = [
            this.CACHE_KEYS.USER_QUESTIONS(userId),
            this.CACHE_KEYS.ALL_QUESTIONS,
        ];

        await Promise.all(
            keysToDelete.map(async key => {
                try {
                    await this.cacheManager.del(key);
                } catch (error) {
                    this.logger.warn(
                        `Failed to delete cache key ${key}:`,
                        error,
                    );
                }
            }),
        );
    }

    private generateCacheKeyForTestQuestions(
        testId: number,
        filters?: QuestionFilterDto,
    ): string {
        const filterKey = JSON.stringify({
            questionType: filters?.questionType,
            minPoints: filters?.minPoints,
            maxPoints: filters?.maxPoints,
            createdFrom: filters?.createdFrom,
            createdTo: filters?.createdTo,
            page: filters?.page,
            pageSize: filters?.pageSize,
        });
        return this.CACHE_KEYS.QUESTIONS_BY_TEST(testId, filterKey);
    }

    /**
     * Create a new question
     */
    async create(
        createQuestionDto: CreateQuestionDto,
        scope: OrgBranchScope,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            // Validate test access
            await this.validateTestAccess(
                createQuestionDto.testId,
                scope.userId,
            );

            // Get test information to inherit org and branch
            const test = await this.testRepository.findOne({
                where: { testId: createQuestionDto.testId },
                relations: ['orgId', 'branchId'],
            });

            if (!test) {
                throw new NotFoundException(
                    `Test with ID ${createQuestionDto.testId} not found`,
                );
            }

            // Auto-increment order index if not provided
            if (!createQuestionDto.orderIndex) {
                const maxOrder = await this.questionRepository
                    .createQueryBuilder('question')
                    .select('MAX(question.orderIndex)', 'maxOrder')
                    .where('question.testId = :testId', {
                        testId: createQuestionDto.testId,
                    })
                    .getRawOne<MaxOrderResult>();

                createQuestionDto.orderIndex = (maxOrder?.maxOrder || 0) + 1;
            } else {
                // Check for duplicate order index
                const existingQuestion = await this.questionRepository.findOne({
                    where: {
                        testId: createQuestionDto.testId,
                        orderIndex: createQuestionDto.orderIndex,
                    },
                });

                if (existingQuestion) {
                    throw new ConflictException(
                        `Question with order index ${createQuestionDto.orderIndex} already exists in this test`,
                    );
                }
            }

            const question = this.questionRepository.create({
                ...createQuestionDto,
                orgId: test.orgId,
                branchId: test.branchId,
            });
            const savedQuestion = await this.questionRepository.save(question);

            // Comprehensive cache invalidation
            await Promise.all([
                this.invalidateTestQuestionsCache(createQuestionDto.testId),
                this.invalidateUserQuestionsCache(scope.userId),
            ]);

            this.logger.log(
                `Question ${savedQuestion.questionId} created successfully`,
            );

            return {
                message: 'Question created successfully',
                status: 'success',
                code: 201,
            };
        });
    }

    /**
     * Create multiple questions in bulk
     */
    async createBulk(
        bulkCreateDto: BulkCreateQuestionsDto,
        scope: OrgBranchScope,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            const queryRunner = this.dataSource.createQueryRunner();
            await queryRunner.connect();
            await queryRunner.startTransaction();

            try {
                const testIds = new Set<number>();
                const createdQuestions: Question[] = [];

                for (const questionDto of bulkCreateDto.questions) {
                    // Validate test access for each question
                    await this.validateTestAccess(
                        questionDto.testId,
                        scope.userId,
                    );

                    const question = await this.createQuestionInTransaction(
                        questionDto,
                        queryRunner,
                    );
                    createdQuestions.push(question);
                    testIds.add(questionDto.testId);
                }

                await queryRunner.commitTransaction();

                // Comprehensive cache invalidation for all affected tests
                await Promise.all([
                    ...Array.from(testIds).map(testId =>
                        this.invalidateTestQuestionsCache(testId),
                    ),
                    this.invalidateUserQuestionsCache(scope.userId),
                ]);

                this.logger.log(
                    `${createdQuestions.length} questions created successfully in bulk`,
                );

                return {
                    message: `${createdQuestions.length} questions created successfully`,
                    status: 'success',
                    code: 201,
                };
            } catch (error) {
                await queryRunner.rollbackTransaction();
                throw error;
            } finally {
                await queryRunner.release();
            }
        });
    }

    /**
     * Find questions by test with optional filters and comprehensive caching
     */
    async findByTest(
        testId: number,
        userId?: string,
        filters?: QuestionFilterDto,
    ): Promise<QuestionListResponseDto> {
        return this.retryOperation(async () => {
            // Check cache first
            const cacheKey = this.generateCacheKeyForTestQuestions(
                testId,
                filters,
            );

            try {
                const cachedResult =
                    await this.cacheManager.get<QuestionListResponseDto>(
                        cacheKey,
                    );

                if (cachedResult) {
                    this.logger.debug(
                        `Cache hit for test questions: ${cacheKey}`,
                    );
                    return cachedResult;
                }
            } catch (error) {
                this.logger.warn(
                    `Cache get failed for key ${cacheKey}:`,
                    error,
                );
            }

            // Validate test access if userId provided
            if (userId) {
                await this.validateTestAccess(testId, userId);
            }

            const query = this.questionRepository
                .createQueryBuilder('question')
                .leftJoinAndSelect('question.test', 'test')
                .where('question.testId = :testId', { testId });

            // Apply filters
            if (filters?.questionType) {
                query.andWhere('question.questionType = :questionType', {
                    questionType: filters.questionType,
                });
            }
            if (filters?.minPoints) {
                query.andWhere('question.points >= :minPoints', {
                    minPoints: filters.minPoints,
                });
            }
            if (filters?.maxPoints) {
                query.andWhere('question.points <= :maxPoints', {
                    maxPoints: filters.maxPoints,
                });
            }
            if (filters?.createdFrom) {
                query.andWhere('question.createdAt >= :createdFrom', {
                    createdFrom: filters.createdFrom,
                });
            }
            if (filters?.createdTo) {
                query.andWhere('question.createdAt <= :createdTo', {
                    createdTo: filters.createdTo,
                });
            }

            // Order by index
            query.orderBy('question.orderIndex', 'ASC');

            // Pagination
            const page = filters?.page || 1;
            const pageSize = filters?.pageSize || 10;
            const offset = (page - 1) * pageSize;

            const [questions, total] = await query
                .skip(offset)
                .take(pageSize)
                .getManyAndCount();

            const totalPointsResult = await this.questionRepository
                .createQueryBuilder('question')
                .select('SUM(question.points)', 'total')
                .where('question.testId = :testId', { testId })
                .getRawOne<TotalPointsResult>();

            const result = {
                questions: await Promise.all(
                    questions.map(q => this.mapToResponseDto(q)),
                ),
                total,
                page,
                pageSize,
                totalPages: Math.ceil(total / pageSize),
                totalPoints: parseInt(totalPointsResult?.total || '0'),
            };

            // Cache the result with error handling
            try {
                await this.cacheManager.set(
                    cacheKey,
                    result,
                    this.CACHE_TTL.QUESTION_LIST * 1000,
                );
                this.logger.debug(`Cache set for test questions: ${cacheKey}`);
            } catch (error) {
                this.logger.warn(
                    `Cache set failed for key ${cacheKey}:`,
                    error,
                );
            }

            return result;
        });
    }

    /**
     * Find a single question by ID with comprehensive caching
     */
    async findOne(id: number, userId?: string): Promise<QuestionResponseDto> {
        return this.retryOperation(async () => {
            // Check cache first
            const cacheKey = this.CACHE_KEYS.QUESTION_BY_ID(id);

            try {
                const cachedQuestion =
                    await this.cacheManager.get<QuestionResponseDto>(cacheKey);

                if (cachedQuestion) {
                    this.logger.debug(`Cache hit for question: ${cacheKey}`);
                    return cachedQuestion;
                }
            } catch (error) {
                this.logger.warn(
                    `Cache get failed for key ${cacheKey}:`,
                    error,
                );
            }

            const question = await this.questionRepository.findOne({
                where: { questionId: id },
                relations: [
                    'test',
                    'test.course',
                    'test.course.orgId',
                    'test.course.branchId',
                    'orgId',
                    'branchId',
                ],
            });

            if (!question) {
                throw new NotFoundException(`Question with ID ${id} not found`);
            }

            // Validate test access if userId provided
            if (userId) {
                await this.validateTestAccess(question.testId, userId);
            }

            const result = await this.mapToResponseDto(question);

            // Cache the result with error handling
            try {
                await this.cacheManager.set(
                    cacheKey,
                    result,
                    this.CACHE_TTL.QUESTION * 1000,
                );
                this.logger.debug(`Cache set for question: ${cacheKey}`);
            } catch (error) {
                this.logger.warn(
                    `Cache set failed for key ${cacheKey}:`,
                    error,
                );
            }

            return result;
        });
    }

    /**
     * Update a question with comprehensive cache invalidation
     */
    async update(
        id: number,
        updateQuestionDto: UpdateQuestionDto,
        userId: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            const question = await this.questionRepository.findOne({
                where: { questionId: id },
                relations: ['test'],
            });

            if (!question) {
                throw new NotFoundException(`Question with ID ${id} not found`);
            }

            // Validate test access
            await this.validateTestAccess(question.testId, userId);

            // Check for order index conflicts if updating
            if (
                updateQuestionDto.orderIndex &&
                updateQuestionDto.orderIndex !== question.orderIndex
            ) {
                const existingQuestion = await this.questionRepository.findOne({
                    where: {
                        testId: question.testId,
                        orderIndex: updateQuestionDto.orderIndex,
                    },
                });

                if (existingQuestion) {
                    throw new ConflictException(
                        `Question with order index ${updateQuestionDto.orderIndex} already exists in this test`,
                    );
                }
            }

            Object.assign(question, updateQuestionDto);
            await this.questionRepository.save(question);

            // Comprehensive cache invalidation
            await Promise.all([
                this.invalidateQuestionCache(id, question.testId),
                this.invalidateUserQuestionsCache(userId),
            ]);

            this.logger.log(`Question ${id} updated successfully`);

            return {
                message: 'Question updated successfully',
                status: 'success',
                code: 200,
            };
        });
    }

    /**
     * Reorder questions in a test with cache invalidation
     */
    async reorder(
        testId: number,
        reorderData: { questionId: number; newOrderIndex: number }[],
        userId: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            // Validate test access
            await this.validateTestAccess(testId, userId);

            const queryRunner = this.dataSource.createQueryRunner();
            await queryRunner.connect();
            await queryRunner.startTransaction();

            try {
                for (const { questionId, newOrderIndex } of reorderData) {
                    await queryRunner.manager.update(
                        Question,
                        { questionId, testId },
                        { orderIndex: newOrderIndex },
                    );
                }

                await queryRunner.commitTransaction();

                // Comprehensive cache invalidation
                await Promise.all([
                    this.invalidateTestQuestionsCache(testId),
                    this.invalidateUserQuestionsCache(userId),
                    // Invalidate individual question caches
                    ...reorderData.map(({ questionId }) =>
                        this.invalidateQuestionCache(questionId, testId),
                    ),
                ]);

                this.logger.log(
                    `Questions reordered successfully in test ${testId}`,
                );

                return {
                    message: 'Questions reordered successfully',
                    status: 'success',
                    code: 200,
                };
            } catch (error) {
                await queryRunner.rollbackTransaction();
                throw error;
            } finally {
                await queryRunner.release();
            }
        });
    }

    /**
     * Delete a question with comprehensive cache invalidation
     */
    async remove(
        id: number,
        userId: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            const question = await this.questionRepository.findOne({
                where: { questionId: id },
                relations: ['test'],
            });

            if (!question) {
                throw new NotFoundException(`Question with ID ${id} not found`);
            }

            // Validate test access
            await this.validateTestAccess(question.testId, userId);

            // Check if question has answers
            const answersCount = await this.answersService.countByQuestion(id);
            if (answersCount > 0) {
                throw new ConflictException(
                    'Cannot delete question that has answers',
                );
            }

            const testId = question.testId;
            await this.questionRepository.remove(question);

            // Comprehensive cache invalidation
            await Promise.all([
                this.invalidateQuestionCache(id, testId),
                this.invalidateUserQuestionsCache(userId),
            ]);

            this.logger.log(`Question ${id} deleted successfully`);

            return {
                message: 'Question deleted successfully',
                status: 'success',
                code: 200,
            };
        });
    }

    /**
     * Get question count for a test with caching
     */
    async getQuestionCount(testId: number): Promise<number> {
        return this.retryOperation(async () => {
            const cacheKey = this.CACHE_KEYS.QUESTION_COUNT(testId);

            try {
                const cachedCount =
                    await this.cacheManager.get<number>(cacheKey);
                if (cachedCount !== undefined && cachedCount !== null) {
                    this.logger.debug(
                        `Cache hit for question count: ${cacheKey}`,
                    );
                    return cachedCount;
                }
            } catch (error) {
                this.logger.warn(
                    `Cache get failed for key ${cacheKey}:`,
                    error,
                );
            }

            const count = await this.questionRepository.count({
                where: { testId },
            });

            try {
                await this.cacheManager.set(
                    cacheKey,
                    count,
                    this.CACHE_TTL.COUNT * 1000,
                );
                this.logger.debug(`Cache set for question count: ${cacheKey}`);
            } catch (error) {
                this.logger.warn(
                    `Cache set failed for key ${cacheKey}:`,
                    error,
                );
            }

            return count;
        });
    }

    /**
     * Validate test access and ownership
     */
    private async validateTestAccess(
        testId: number,
        userId: string,
    ): Promise<void> {
        try {
            await this.testService.validateCourseAccess(testId, userId);
        } catch (error) {
            if (error instanceof NotFoundException) {
                throw new NotFoundException(`Test with ID ${testId} not found`);
            }
            throw new ForbiddenException('You do not have access to this test');
        }
    }

    /**
     * Create question within transaction
     */
    private async createQuestionInTransaction(
        createQuestionDto: CreateQuestionDto,
        queryRunner: QueryRunner,
    ): Promise<Question> {
        // Auto-increment order index if not provided
        if (!createQuestionDto.orderIndex) {
            const maxOrder = await queryRunner.manager
                .createQueryBuilder(Question, 'question')
                .select('MAX(question.orderIndex)', 'maxOrder')
                .where('question.testId = :testId', {
                    testId: createQuestionDto.testId,
                })
                .getRawOne<MaxOrderResult>();

            createQuestionDto.orderIndex = (maxOrder?.maxOrder || 0) + 1;
        }

        const question = queryRunner.manager.create(
            Question,
            createQuestionDto,
        );
        return await queryRunner.manager.save(question);
    }

    /**
     * Map Question entity to response DTO
     */
    private async mapToResponseDto(
        question: Question,
    ): Promise<QuestionResponseDto> {
        // Get actual counts from related services
        const [optionsCount, answersCount] = await Promise.all([
            this.questionsOptionsService.getOptionCount(question.questionId),
            this.answersService.countByQuestion(question.questionId),
        ]);

        return {
            questionId: question.questionId,
            testId: question.testId,
            questionText: question.questionText,
            questionType: question.questionType,
            points: question.points,
            orderIndex: question.orderIndex,
            createdAt: question.createdAt,
            updatedAt: question.updatedAt,
            test: question.test
                ? {
                      testId: question.test.testId,
                      title: question.test.title,
                      testType: question.test.testType,
                  }
                : undefined,
            optionsCount,
            answersCount,
        };
    }
}

/*
 * Class #146: BulkOptionDto
 * Source: questions_options/dto/bulk-create-options.dto.ts:5
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 2
 * Complexity: 6
 * Size: 351 characters (14 lines)
 */
export class BulkOptionDto {
    @ApiProperty({
        description: 'The option text/content',
        example: 'O(log n) - Logarithmic time complexity',
    })
    optionText: string;

    @ApiProperty({
        description: 'Whether this option is the correct answer',
        example: true,
        default: false,
    })
    isCorrect: boolean;
}

/*
 * Class #147: BulkCreateOptionsDto
 * Source: questions_options/dto/bulk-create-options.dto.ts:20
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 6
 * Complexity: 13
 * Size: 409 characters (17 lines)
 */
export class BulkCreateOptionsDto {
    @ApiProperty({
        description: 'Question ID that these options belong to',
        example: 1,
    })
    @IsNumber()
    questionId: number;

    @ApiProperty({
        description: 'Array of options to create',
        type: [BulkOptionDto],
    })
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => BulkOptionDto)
    options: BulkOptionDto[];
}

/*
 * Class #148: CreateQuestionOptionDto
 * Source: questions_options/dto/create-questions_option.dto.ts:10
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 9
 * Complexity: 21
 * Size: 633 characters (27 lines)
 */
export class CreateQuestionOptionDto {
    @ApiProperty({
        description: 'Question ID that this option belongs to',
        example: 1,
    })
    @IsNumber()
    @IsNotEmpty()
    questionId: number;

    @ApiProperty({
        description: 'The option text/content',
        example: 'O(log n) - Logarithmic time complexity',
    })
    @IsString()
    @IsNotEmpty()
    optionText: string;

    @ApiProperty({
        description: 'Whether this option is the correct answer',
        example: true,
        default: false,
        required: false,
    })
    @IsBoolean()
    @IsOptional()
    isCorrect?: boolean = false;
}

/*
 * Class #149: QuestionOptionListResponseDto
 * Source: questions_options/dto/question-option-list-response.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 8
 * Decorators: 4
 * Complexity: 10
 * Size: 678 characters (30 lines)
 */
export class QuestionOptionListResponseDto {
    @ApiProperty({
        description: 'Array of question options',
        type: [QuestionOptionResponseDto],
    })
    options: QuestionOptionResponseDto[];

    @ApiProperty({
        description: 'Total number of options',
        example: 15,
    })
    total: number;

    @ApiProperty({
        description: 'Number of correct options',
        example: 4,
    })
    correctCount: number;

    @ApiProperty({
        description: 'Question information',
        required: false,
    })
    question?: {
        questionId: number;
        questionText: string;
        questionType: string;
        points: number;
    };
}

/*
 * Class #150: QuestionOptionResponseDto
 * Source: questions_options/dto/question-option-response.dto.ts:3
 * Type: Exported Class
 * Methods: 0
 * Properties: 15
 * Decorators: 9
 * Complexity: 23
 * Size: 1461 characters (62 lines)
 */
export class QuestionOptionResponseDto {
    @ApiProperty({
        description: 'Question option unique identifier',
        example: 1,
    })
    optionId: number;

    @ApiProperty({
        description: 'Question ID that this option belongs to',
        example: 1,
    })
    questionId: number;

    @ApiProperty({
        description: 'The option text/content',
        example: 'O(log n) - Logarithmic time complexity',
    })
    optionText: string;

    @ApiProperty({
        description: 'Whether this option is the correct answer',
        example: true,
    })
    isCorrect: boolean;

    @ApiProperty({
        description: 'Option creation timestamp',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @ApiProperty({
        description: 'Option last update timestamp',
        example: '2024-01-15T10:30:45.123Z',
    })
    updatedAt: Date;

    @ApiProperty({
        description: 'Question information',
        required: false,
    })
    question?: {
        questionId: number;
        questionText: string;
        questionType: string;
        points: number;
    };

    @ApiProperty({
        description: 'Number of times this option was selected',
        example: 25,
        required: false,
    })
    timesSelected?: number;

    @ApiProperty({
        description: 'Selection percentage among all answers',
        example: 45.5,
        required: false,
    })
    selectionPercentage?: number;
}

/*
 * Class #151: StandardApiResponse
 * Source: questions_options/dto/question-option-response.dto.ts:67
 * Type: Exported Class
 * Methods: 0
 * Properties: 11
 * Decorators: 4
 * Complexity: 15
 * Size: 806 characters (34 lines)
 */
export class StandardApiResponse<T = any> {
    @ApiProperty({
        description: 'Indicates if the operation was successful',
        example: true,
    })
    success: boolean;

    @ApiProperty({
        description: 'Human-readable message about the operation result',
        example: 'Operation completed successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Response data payload',
        required: false,
    })
    data?: T;

    @ApiProperty({
        description: 'Additional metadata about the response',
        required: false,
    })
    meta?: {
        timestamp?: string;
        requestId?: string;
        pagination?: {
            page: number;
            limit: number;
            total: number;
            totalPages: number;
        };
    };
}

/*
 * Class #152: QuestionOptionApiResponse
 * Source: questions_options/dto/question-option-response.dto.ts:102
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 1
 * Complexity: 4
 * Size: 269 characters (7 lines)
 * Extends: StandardApiResponse<QuestionOptionResponseDto>
 */
export class QuestionOptionApiResponse extends StandardApiResponse<QuestionOptionResponseDto> {
    @ApiProperty({
        description: 'Question option data retrieved successfully',
        type: QuestionOptionResponseDto,
    })
    data: QuestionOptionResponseDto;
}

/*
 * Class #153: QuestionOptionListApiResponse
 * Source: questions_options/dto/question-option-response.dto.ts:110
 * Type: Exported Class
 * Methods: 0
 * Properties: 8
 * Decorators: 0
 * Complexity: 3
 * Size: 297 characters (11 lines)
 * Extends: StandardApiResponse<
 */
export class QuestionOptionListApiResponse extends StandardApiResponse<{
    options: QuestionOptionResponseDto[];
    total: number;
    correctCount: number;
    question?: {
        questionId: number;
        questionText: string;
        questionType: string;
        points: number;
    };
}

/*
 * Class #154: QuestionOptionCreatedResponse
 * Source: questions_options/dto/question-option-response.dto.ts:180
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 7
 * Size: 439 characters (19 lines)
 */
export class QuestionOptionCreatedResponse {
    @ApiProperty({
        description: 'Question option creation success message',
        example: 'Question option created successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 201,
    })
    code: number;
}

/*
 * Class #155: QuestionOptionUpdatedResponse
 * Source: questions_options/dto/question-option-response.dto.ts:200
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 7
 * Size: 437 characters (19 lines)
 */
export class QuestionOptionUpdatedResponse {
    @ApiProperty({
        description: 'Question option update success message',
        example: 'Question option updated successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #156: QuestionOptionDeletedResponse
 * Source: questions_options/dto/question-option-response.dto.ts:220
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 7
 * Size: 439 characters (19 lines)
 */
export class QuestionOptionDeletedResponse {
    @ApiProperty({
        description: 'Question option deletion success message',
        example: 'Question option deleted successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #157: BulkQuestionOptionsCreatedResponse
 * Source: questions_options/dto/question-option-response.dto.ts:240
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 7
 * Size: 459 characters (19 lines)
 */
export class BulkQuestionOptionsCreatedResponse {
    @ApiProperty({
        description: 'Bulk question options creation success message',
        example: 'Question options created successfully in bulk',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 201,
    })
    code: number;
}

/*
 * Class #158: UpdateQuestionOptionDto
 * Source: questions_options/dto/update-questions_option.dto.ts:4
 * Type: Exported Class
 * Methods: 1
 * Properties: 0
 * Decorators: 0
 * Complexity: 4
 * Size: 126 characters (3 lines)
 * Extends: PartialType(
    OmitType(CreateQuestionOptionDto, ['questionId'] as const),
)
 */
export class UpdateQuestionOptionDto extends PartialType(
    OmitType(CreateQuestionOptionDto, ['questionId'] as const),
) {}

/*
 * Class #159: QuestionOption
 * Source: questions_options/entities/questions_option.entity.ts:20
 * Type: Exported Class
 * Methods: 0
 * Properties: 20
 * Decorators: 25
 * Complexity: 55
 * Size: 1802 characters (77 lines)
 */
export class QuestionOption {
    @PrimaryGeneratedColumn()
    @ApiProperty({
        description: 'Question option unique identifier',
        example: 1,
    })
    optionId: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Question ID that this option belongs to',
        example: 1,
    })
    @IsNumber()
    @IsNotEmpty()
    questionId: number;

    @Column('text')
    @ApiProperty({
        description: 'The option text/content',
        example: 'O(log n)',
    })
    @IsString()
    @IsNotEmpty()
    optionText: string;

    @Column({ default: false })
    @Index()
    @ApiProperty({
        description: 'Whether this option is the correct answer',
        example: true,
        default: false,
    })
    @IsBoolean()
    isCorrect: boolean;

    @CreateDateColumn()
    @ApiProperty({
        description: 'Option creation timestamp',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @UpdateDateColumn()
    @ApiProperty({
        description: 'Option last update timestamp',
        example: '2024-01-15T10:30:45.123Z',
    })
    updatedAt: Date;

    @ManyToOne(() => Organization, { nullable: false })
    @ApiProperty({
        description: 'Organization this question option belongs to',
        type: () => Organization,
    })
    orgId: Organization;

    @ManyToOne(() => Branch, { nullable: true })
    @ApiProperty({
        description: 'Branch this question option belongs to',
        type: () => Branch,
        required: false,
    })
    branchId?: Branch;

    // Relations
    @ManyToOne(() => Question, {
        onDelete: 'CASCADE',
    })
    @JoinColumn({ name: 'questionId' })
    question: Question;

    constructor(partial: Partial<QuestionOption>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #160: QuestionsOptionsController
 * Source: questions_options/questions_options.controller.ts:47
 * Type: Exported Class
 * Methods: 13
 * Properties: 214
 * Decorators: 69
 * Complexity: 240
 * Size: 21378 characters (637 lines)
 */
export class QuestionsOptionsController {
    private readonly logger = new Logger(QuestionsOptionsController.name);

    constructor(
        private readonly questionsOptionsService: QuestionsOptionsService,
    ) {}

    @Post()
    @HttpCode(HttpStatus.CREATED)
    @ApiOperation({
        summary: '🔧 Create New Question Option',
        description: `
      **Creates a new answer option for a question with comprehensive validation**
      
      This endpoint allows test creators to add answer options including:
      - Option text and content
      - Correct answer designation
      - Multiple option support per question
      - Validation for question type compatibility
      
      **Authorization Requirements:**
      - Must be the owner of the test containing the question
      - Valid JWT authentication required
      
      **Business Rules:**
      - Question must exist and be accessible to the user
      - Option text is required and cannot be empty
      - At least one correct option should exist per question
      - Multiple correct options allowed for certain question types
      - Option order is automatically managed
      
      **Use Cases:**
      - Building multiple choice answer sets
      - Creating true/false options
      - Setting up selection-based questions
      - Preparing quiz answer choices
    `,
        operationId: 'createQuestionOption',
    })
    @ApiBody({
        type: CreateQuestionOptionDto,
        description: 'Question option creation data',
        examples: {
            'correct-option': {
                summary: '✅ Correct Answer Option',
                description: 'Create a correct answer option for a question',
                value: {
                    questionId: 1,
                    optionText: 'O(log n) - Logarithmic time complexity',
                    isCorrect: true,
                },
            },
            'incorrect-option': {
                summary: '❌ Incorrect Answer Option',
                description: 'Create an incorrect answer option for a question',
                value: {
                    questionId: 1,
                    optionText: 'O(n²) - Quadratic time complexity',
                    isCorrect: false,
                },
            },
            'true-false': {
                summary: '🔘 True/False Option',
                description: 'Create an option for true/false questions',
                value: {
                    questionId: 2,
                    optionText: 'True',
                    isCorrect: true,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description: '✅ Question option created successfully',
        type: StandardOperationResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data or validation errors',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    example: [
                        'Option text cannot be empty',
                        'Question ID is required',
                    ],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '⛔ Forbidden - No access to the specified question',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Question not found',
    })
    async create(
        @Body() createQuestionOptionDto: CreateQuestionOptionDto,
        @OrgBranchScope() scope: OrgBranchScope,
        @GetUser('id') userId: string,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(
                `Creating option for question ${createQuestionOptionDto.questionId} by user: ${userId}`,
            );

            const result = await this.questionsOptionsService.create(
                createQuestionOptionDto,
                scope,
                userId,
            );

            this.logger.log(`Question option created successfully`);

            return result;
        } catch (error) {
            this.logger.error(
                `Error creating question option for user ${userId}:`,
                error instanceof Error ? error.message : String(error),
            );
            throw error;
        }
    }

    @Post('bulk')
    @HttpCode(HttpStatus.CREATED)
    @ApiOperation({
        summary: '📋 Create Multiple Question Options in Bulk',
        description: `
      **Creates multiple answer options for a question in a single operation**
      
      This endpoint enables efficient bulk creation of question options:
      - Single transaction for all options
      - Comprehensive validation for all options
      - Automatic option ordering
      - Rollback on any validation failure
      
      **Performance Features:**
      - Batch processing for improved performance
      - Transaction-based integrity
      - Bulk validation processing
      - Optimized database operations
      
      **Business Rules:**
      - All options must belong to the same question
      - Each option must have valid text content
      - At least one correct option required
      - Maximum option limit per question enforced
      
      **Authorization Requirements:**
      - Must be the owner of the test containing the question
      - Valid JWT authentication required
      
      **Use Cases:**
      - Quick setup of multiple choice questions
      - Import question options from templates
      - Batch creation for quiz preparation
      - Efficient test construction workflows
    `,
        operationId: 'createBulkQuestionOptions',
    })
    @ApiBody({
        type: BulkCreateOptionsDto,
        description: 'Bulk option creation data',
        examples: {
            'multiple-choice': {
                summary: '🎯 Multiple Choice Options Set',
                description:
                    'Create complete set of options for a multiple choice question',
                value: {
                    questionId: 1,
                    options: [
                        {
                            optionText: 'Variable declaration',
                            isCorrect: false,
                        },
                        {
                            optionText: 'Function definition',
                            isCorrect: true,
                        },
                        {
                            optionText: 'Class instantiation',
                            isCorrect: false,
                        },
                        {
                            optionText: 'Module import',
                            isCorrect: false,
                        },
                    ],
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description: '✅ Question options created successfully',
        type: StandardOperationResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid bulk creation data',
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '⛔ Forbidden - No access to the specified question',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Question not found',
    })
    async createBulk(
        @Body() bulkCreateDto: BulkCreateOptionsDto,
        @OrgBranchScope() scope: OrgBranchScope,
        @GetUser('id') userId: string,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(
                `Creating ${bulkCreateDto.options.length} options for question ${bulkCreateDto.questionId} by user: ${userId}`,
            );

            const result = await this.questionsOptionsService.createBulk(
                bulkCreateDto,
                scope,
                userId,
            );

            this.logger.log(`Question options created successfully in bulk`);

            return result;
        } catch (error) {
            this.logger.error(
                `Error creating bulk question options for user ${userId}:`,
                error instanceof Error ? error.message : String(error),
            );
            throw error;
        }
    }

    @Get('question/:questionId')
    @ApiOperation({
        summary: '📝 Get Options for Question',
        description: `
      **Retrieve all answer options for a specific question**
      
      This endpoint returns all options configured for a question including:
      - Option text and content
      - Correct answer indicators (filtered for students)
      - Option ordering and metadata
      - Complete option details for creators
      
      **Data Filtering:**
      - Correct answer status hidden from students during active tests
      - Full details available to test creators
      - Proper ordering maintained
      - Active options only returned
      
      **Authorization Requirements:**
      - Must have access to the question (student or creator)
      - Valid JWT authentication required
      
      **Use Cases:**
      - Displaying question options to test takers
      - Reviewing question setup for creators
      - Option management interfaces
      - Test preview functionality
    `,
        operationId: 'getQuestionOptions',
    })
    @ApiParam({
        name: 'questionId',
        description: 'ID of the question to get options for',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Question options retrieved successfully',
        type: QuestionOptionListResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '⛔ Forbidden - No access to the specified question',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Question not found',
    })
    async findByQuestion(
        @Param('questionId', ParseIntPipe) questionId: number,
        @OrgBranchScope() scope: OrgBranchScope,
        @GetUser('id') userId: string,
    ): Promise<QuestionOptionListResponseDto> {
        try {
            this.logger.log(
                `Fetching options for question ${questionId} by user: ${userId}`,
            );

            const result = await this.questionsOptionsService.findByQuestion(
                questionId,
                scope,
                userId,
            );

            this.logger.log(
                `Retrieved ${result.options.length} options for question ${questionId}`,
            );

            return result;
        } catch (error) {
            this.logger.error(
                `Error fetching options for question ${questionId} by user ${userId}:`,
                error instanceof Error ? error.message : String(error),
            );
            throw error;
        }
    }

    @Get(':id')
    @ApiOperation({
        summary: '🔍 Get Question Option Details',
        description: `
      **Retrieve detailed information about a specific question option**
      
      This endpoint returns comprehensive details for a single option including:
      - Option text and content
      - Correct answer status (filtered appropriately)
      - Creation and modification metadata
      - Related question information
      
      **Data Access Rules:**
      - Test creators see all option details
      - Students see filtered information based on test status
      - Correct answer status controlled by context
      - Metadata available for authorized users
      
      **Authorization Requirements:**
      - Must have access to the question containing the option
      - Valid JWT authentication required
      
      **Use Cases:**
      - Option editing interfaces for creators
      - Detailed option review and validation
      - Option-specific metadata access
      - Debugging and administration
    `,
        operationId: 'getQuestionOption',
    })
    @ApiParam({
        name: 'id',
        description: 'ID of the question option to retrieve',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Question option retrieved successfully',
        type: QuestionOptionResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '⛔ Forbidden - No access to this option',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Question option not found',
    })
    async findOne(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
        @GetUser('id') userId: string,
    ): Promise<QuestionOptionResponseDto> {
        try {
            this.logger.log(
                `Fetching question option ${id} by user: ${userId}`,
            );

            const option = await this.questionsOptionsService.findOne(
                id,
                scope,
                userId,
            );

            this.logger.log(`Question option ${id} retrieved successfully`);

            return option;
        } catch (error) {
            this.logger.error(
                `Error fetching question option ${id} by user ${userId}:`,
                error instanceof Error ? error.message : String(error),
            );
            throw error;
        }
    }

    @Put(':id')
    @ApiOperation({
        summary: '✏️ Update Question Option',
        description: `
      **Update an existing question option with new information**
      
      This endpoint allows test creators to modify question options including:
      - Option text and content updates
      - Correct answer status changes
      - Option metadata modifications
      - Validation and consistency checks
      
      **Update Capabilities:**
      - Modify option text content
      - Change correct answer designation
      - Update option ordering
      - Preserve option relationships
      
      **Business Rules:**
      - Only test creators can update options
      - At least one correct option must remain per question
      - Option text cannot be empty
      - Changes validated for consistency
      
      **Authorization Requirements:**
      - Must be the owner of the test containing the question
      - Valid JWT authentication required
      
      **Use Cases:**
      - Correcting option text errors
      - Adjusting correct answer designations
      - Improving option clarity and accuracy
      - Maintaining question quality
    `,
        operationId: 'updateQuestionOption',
    })
    @ApiParam({
        name: 'id',
        description: 'ID of the question option to update',
        example: 1,
    })
    @ApiBody({
        type: UpdateQuestionOptionDto,
        description: 'Question option update data',
        examples: {
            'text-update': {
                summary: '📝 Update Option Text',
                description: 'Modify the text content of an option',
                value: {
                    optionText: 'Updated option text with better clarity',
                },
            },
            'correctness-change': {
                summary: '✅ Change Correct Answer',
                description: 'Update the correct answer designation',
                value: {
                    isCorrect: true,
                },
            },
            'complete-update': {
                summary: '🔄 Complete Option Update',
                description: 'Update both text and correctness',
                value: {
                    optionText: 'Completely revised option text',
                    isCorrect: false,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Question option updated successfully',
        type: StandardOperationResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid update data or validation errors',
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '⛔ Forbidden - No access to update this option',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Question option not found',
    })
    async update(
        @Param('id', ParseIntPipe) id: number,
        @Body() updateQuestionOptionDto: UpdateQuestionOptionDto,
        @OrgBranchScope() scope: OrgBranchScope,
        @GetUser('id') userId: string,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(
                `Updating question option ${id} by user: ${userId}`,
            );

            const result = await this.questionsOptionsService.update(
                id,
                updateQuestionOptionDto,
                scope,
                userId,
            );

            this.logger.log(`Question option ${id} updated successfully`);

            return result;
        } catch (error) {
            this.logger.error(
                `Error updating question option ${id} by user ${userId}:`,
                error instanceof Error ? error.message : String(error),
            );
            throw error;
        }
    }

    @Delete(':id')
    @HttpCode(HttpStatus.NO_CONTENT)
    @ApiOperation({
        summary: '🗑️ Delete Question Option',
        description: `
      **Permanently delete a question option**
      
      This endpoint allows test creators to remove question options including:
      - Complete option removal from the question
      - Validation for minimum option requirements
      - Cascade handling for related data
      - Immediate effect on question structure
      
      **Deletion Rules:**
      - Only test creators can delete options
      - Must maintain minimum number of options per question
      - At least one correct option must remain
      - Cannot delete if option is referenced in active attempts
      
      **Safety Measures:**
      - Validation before deletion
      - Transaction-based removal
      - Related data cleanup
      - Audit trail maintenance
      
      **Authorization Requirements:**
      - Must be the owner of the test containing the question
      - Valid JWT authentication required
      
      **Use Cases:**
      - Removing incorrect or redundant options
      - Simplifying question structure
      - Quality improvement of questions
      - Test maintenance and cleanup
    `,
        operationId: 'deleteQuestionOption',
    })
    @ApiParam({
        name: 'id',
        description: 'ID of the question option to delete',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.NO_CONTENT,
        description: '✅ Question option deleted successfully',
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Cannot delete option - validation failed',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'string',
                    example: 'Cannot delete last correct option for question',
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '⛔ Forbidden - No access to delete this option',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Question option not found',
    })
    async remove(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
        @GetUser('id') userId: string,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(
                `Deleting question option ${id} by user: ${userId}`,
            );

            const result = await this.questionsOptionsService.remove(
                id,
                scope,
                userId,
            );

            this.logger.log(`Question option ${id} deleted successfully`);

            return result;
        } catch (error) {
            this.logger.error(
                `Error deleting question option ${id} by user ${userId}:`,
                error instanceof Error ? error.message : String(error),
            );
            throw error;
        }
    }
}

/*
 * Class #161: QuestionsOptionsModule
 * Source: questions_options/questions_options.module.ts:23
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 38 characters (1 lines)
 */
export class QuestionsOptionsModule {}

/*
 * Class #162: QuestionsOptionsService
 * Source: questions_options/questions_options.service.ts:25
 * Type: Exported Class
 * Methods: 41
 * Properties: 113
 * Decorators: 4
 * Complexity: 266
 * Size: 22575 characters (676 lines)
 */
export class QuestionsOptionsService {
    private readonly logger = new Logger(QuestionsOptionsService.name);

    // Cache keys with comprehensive coverage
    private readonly CACHE_KEYS = {
        OPTION_BY_ID: (id: number) => `question-option:${id}`,
        OPTIONS_BY_QUESTION: (questionId: number) =>
            `question-options:question:${questionId}`,
        OPTION_STATS: (questionId: number) =>
            `question-option:stats:${questionId}`,
        OPTION_LIST: (filters: string) => `question-options:list:${filters}`,
        QUESTION_OPTIONS_COUNT: (questionId: number) =>
            `question:${questionId}:options:count`,
        USER_OPTIONS: (userId: string) => `user:${userId}:options`,
        ALL_OPTIONS: 'question-options:all',
        CORRECT_OPTIONS: (questionId: number) =>
            `question:${questionId}:correct-options`,
    };

    // Cache TTL in seconds with different durations for different data types
    private readonly CACHE_TTL = {
        OPTION: 300, // 5 minutes
        OPTION_LIST: 180, // 3 minutes
        STATS: 600, // 10 minutes
        COUNT: 120, // 2 minutes
        USER_DATA: 240, // 4 minutes
        ALL_OPTIONS: 900, // 15 minutes
        CORRECT_OPTIONS: 300, // 5 minutes
    };

    constructor(
        @InjectRepository(QuestionOption)
        private readonly questionOptionRepository: Repository<QuestionOption>,
        @InjectRepository(Question)
        private readonly questionRepository: Repository<Question>,
        @Inject(forwardRef(() => QuestionsService))
        private readonly questionsService: QuestionsService,
        private readonly dataSource: DataSource,
        @Inject(CACHE_MANAGER) private readonly cacheManager: Cache,
    ) {}

    /**
     * Retry database operations with exponential backoff
     */
    private async retryOperation<T>(
        operation: () => Promise<T>,
        maxRetries: number = 3,
        delay: number = 1000,
    ): Promise<T> {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                if (attempt === maxRetries) {
                    this.logger.error(
                        `Operation failed after ${maxRetries} attempts`,
                        error instanceof Error ? error.stack : String(error),
                    );
                    throw error;
                }
                this.logger.warn(
                    `Operation failed, attempt ${attempt}/${maxRetries}. Retrying in ${delay}ms...`,
                );
                await new Promise(resolve =>
                    setTimeout(resolve, delay * attempt),
                );
            }
        }
        throw new Error('Retry operation failed unexpectedly');
    }

    /**
     * Comprehensive cache invalidation methods
     */
    private async invalidateOptionCache(
        optionId: number,
        questionId?: number,
    ): Promise<void> {
        const keysToDelete = [this.CACHE_KEYS.OPTION_BY_ID(optionId)];

        if (questionId) {
            keysToDelete.push(
                this.CACHE_KEYS.OPTIONS_BY_QUESTION(questionId),
                this.CACHE_KEYS.OPTION_STATS(questionId),
                this.CACHE_KEYS.QUESTION_OPTIONS_COUNT(questionId),
                this.CACHE_KEYS.CORRECT_OPTIONS(questionId),
            );
        }

        // Also invalidate general option lists
        keysToDelete.push(this.CACHE_KEYS.ALL_OPTIONS);

        await Promise.all(
            keysToDelete.map(async key => {
                try {
                    await this.cacheManager.del(key);
                } catch (error) {
                    this.logger.warn(
                        `Failed to delete cache key ${key}:`,
                        error,
                    );
                }
            }),
        );
    }

    private async invalidateQuestionOptionsCache(
        questionId: number,
    ): Promise<void> {
        const keysToDelete = [
            this.CACHE_KEYS.OPTIONS_BY_QUESTION(questionId),
            this.CACHE_KEYS.OPTION_STATS(questionId),
            this.CACHE_KEYS.QUESTION_OPTIONS_COUNT(questionId),
            this.CACHE_KEYS.CORRECT_OPTIONS(questionId),
            this.CACHE_KEYS.ALL_OPTIONS,
        ];

        await Promise.all(
            keysToDelete.map(async key => {
                try {
                    await this.cacheManager.del(key);
                } catch (error) {
                    this.logger.warn(
                        `Failed to delete cache key ${key}:`,
                        error,
                    );
                }
            }),
        );
    }

    private async invalidateUserOptionsCache(userId: string): Promise<void> {
        const keysToDelete = [
            this.CACHE_KEYS.USER_OPTIONS(userId),
            this.CACHE_KEYS.ALL_OPTIONS,
        ];

        await Promise.all(
            keysToDelete.map(async key => {
                try {
                    await this.cacheManager.del(key);
                } catch (error) {
                    this.logger.warn(
                        `Failed to delete cache key ${key}:`,
                        error,
                    );
                }
            }),
        );
    }

    /**
     * Create a new question option with comprehensive caching
     */
    async create(
        createQuestionOptionDto: CreateQuestionOptionDto,
        scope: OrgBranchScope,
        userId: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            // Validate question access with scope
            await this.validateQuestionAccessWithScope(
                createQuestionOptionDto.questionId,
                scope,
                userId,
            );

            const option = this.questionOptionRepository.create(
                createQuestionOptionDto,
            );
            const savedOption =
                await this.questionOptionRepository.save(option);

            // Comprehensive cache invalidation
            await Promise.all([
                this.invalidateQuestionOptionsCache(
                    createQuestionOptionDto.questionId,
                ),
                this.invalidateUserOptionsCache(userId),
            ]);

            this.logger.log(
                `Question option ${savedOption.optionId} created successfully`,
            );

            return {
                message: 'Question option created successfully',
                status: 'success',
                code: 201,
            };
        });
    }

    /**
     * Create multiple options in bulk with comprehensive caching
     */
    async createBulk(
        bulkCreateDto: BulkCreateOptionsDto,
        scope: OrgBranchScope,
        userId: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            // Validate question access with scope
            await this.validateQuestionAccessWithScope(
                bulkCreateDto.questionId,
                scope,
                userId,
            );

            const queryRunner = this.dataSource.createQueryRunner();
            await queryRunner.connect();
            await queryRunner.startTransaction();

            try {
                const createdOptions: QuestionOption[] = [];

                for (const optionData of bulkCreateDto.options) {
                    const optionDto: CreateQuestionOptionDto = {
                        questionId: bulkCreateDto.questionId,
                        optionText: optionData.optionText,
                        isCorrect: optionData.isCorrect,
                    };

                    const option = queryRunner.manager.create(
                        QuestionOption,
                        optionDto,
                    );
                    const savedOption = await queryRunner.manager.save(option);
                    createdOptions.push(savedOption);
                }

                await queryRunner.commitTransaction();

                // Comprehensive cache invalidation
                await Promise.all([
                    this.invalidateQuestionOptionsCache(
                        bulkCreateDto.questionId,
                    ),
                    this.invalidateUserOptionsCache(userId),
                ]);

                this.logger.log(
                    `${createdOptions.length} question options created successfully in bulk`,
                );

                return {
                    message: 'Question options created successfully in bulk',
                    status: 'success',
                    code: 201,
                };
            } catch (error) {
                await queryRunner.rollbackTransaction();
                throw error;
            } finally {
                await queryRunner.release();
            }
        });
    }

    /**
     * Find options by question with comprehensive caching
     */
    async findByQuestion(
        questionId: number,
        scope: OrgBranchScope,
        userId?: string,
    ): Promise<QuestionOptionListResponseDto> {
        return this.retryOperation(async () => {
            // Check cache first
            const cacheKey = this.CACHE_KEYS.OPTIONS_BY_QUESTION(questionId);

            try {
                const cachedResult =
                    await this.cacheManager.get<QuestionOptionListResponseDto>(
                        cacheKey,
                    );

                if (cachedResult) {
                    this.logger.debug(
                        `Cache hit for question options: ${cacheKey}`,
                    );
                    return cachedResult;
                }
            } catch (error) {
                this.logger.warn(
                    `Cache get failed for key ${cacheKey}:`,
                    error,
                );
            }

            // Validate question access with scope
            await this.validateQuestionAccessWithScope(
                questionId,
                scope,
                userId,
            );

            const [options, total] = await this.questionOptionRepository
                .createQueryBuilder('option')
                .leftJoinAndSelect('option.question', 'question')
                .where('option.questionId = :questionId', { questionId })
                .orderBy('option.optionId', 'ASC')
                .getManyAndCount();

            const correctCount = options.filter(
                option => option.isCorrect,
            ).length;

            const question = options.length > 0 ? options[0].question : null;

            const result = {
                options: options.map(option => this.mapToResponseDto(option)),
                total,
                correctCount,
                question: question
                    ? {
                          questionId: question.questionId,
                          questionText: question.questionText,
                          questionType: question.questionType,
                          points: question.points,
                      }
                    : undefined,
            };

            // Cache the result with error handling
            try {
                await this.cacheManager.set(
                    cacheKey,
                    result,
                    this.CACHE_TTL.OPTION_LIST * 1000,
                );
                this.logger.debug(
                    `Cache set for question options: ${cacheKey}`,
                );
            } catch (error) {
                this.logger.warn(
                    `Cache set failed for key ${cacheKey}:`,
                    error,
                );
            }

            return result;
        });
    }

    /**
     * Find a single option by ID with comprehensive caching
     */
    async findOne(
        id: number,
        scope: OrgBranchScope,
        userId?: string,
    ): Promise<QuestionOptionResponseDto> {
        return this.retryOperation(async () => {
            // Check cache first
            const cacheKey = this.CACHE_KEYS.OPTION_BY_ID(id);

            try {
                const cachedOption =
                    await this.cacheManager.get<QuestionOptionResponseDto>(
                        cacheKey,
                    );

                if (cachedOption) {
                    this.logger.debug(`Cache hit for option: ${cacheKey}`);
                    return cachedOption;
                }
            } catch (error) {
                this.logger.warn(
                    `Cache get failed for key ${cacheKey}:`,
                    error,
                );
            }

            const option = await this.questionOptionRepository.findOne({
                where: { optionId: id },
                relations: ['question'],
            });

            if (!option) {
                throw new NotFoundException(
                    `Question option with ID ${id} not found`,
                );
            }

            // Validate question access with scope
            await this.validateQuestionAccessWithScope(
                option.questionId,
                scope,
                userId,
            );

            const result = this.mapToResponseDto(option);

            // Cache the result with error handling
            try {
                await this.cacheManager.set(
                    cacheKey,
                    result,
                    this.CACHE_TTL.OPTION * 1000,
                );
                this.logger.debug(`Cache set for option: ${cacheKey}`);
            } catch (error) {
                this.logger.warn(
                    `Cache set failed for key ${cacheKey}:`,
                    error,
                );
            }

            return result;
        });
    }

    /**
     * Update a question option with comprehensive cache invalidation
     */
    async update(
        id: number,
        updateQuestionOptionDto: UpdateQuestionOptionDto,
        scope: OrgBranchScope,
        userId: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            const option = await this.questionOptionRepository.findOne({
                where: { optionId: id },
                relations: ['question'],
            });

            if (!option) {
                throw new NotFoundException(
                    `Question option with ID ${id} not found`,
                );
            }

            // Validate question access with scope
            await this.validateQuestionAccessWithScope(
                option.questionId,
                scope,
                userId,
            );

            Object.assign(option, updateQuestionOptionDto);
            await this.questionOptionRepository.save(option);

            // Comprehensive cache invalidation
            await Promise.all([
                this.invalidateOptionCache(id, option.questionId),
                this.invalidateUserOptionsCache(userId),
            ]);

            this.logger.log(`Question option ${id} updated successfully`);

            return {
                message: 'Question option updated successfully',
                status: 'success',
                code: 200,
            };
        });
    }

    /**
     * Delete a question option with comprehensive cache invalidation
     */
    async remove(
        id: number,
        scope: OrgBranchScope,
        userId: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            const option = await this.questionOptionRepository.findOne({
                where: { optionId: id },
                relations: ['question'],
            });

            if (!option) {
                throw new NotFoundException(
                    `Question option with ID ${id} not found`,
                );
            }

            // Validate question access with scope
            await this.validateQuestionAccessWithScope(
                option.questionId,
                scope,
                userId,
            );

            // TODO: Check if option has answers (will be implemented in Answers module)
            // const answersCount = await this.answersService.countByOption(id);
            // if (answersCount > 0) {
            //     throw new BadRequestException('Cannot delete option that has answers');
            // }

            const questionId = option.questionId;
            await this.questionOptionRepository.remove(option);

            // Comprehensive cache invalidation
            await Promise.all([
                this.invalidateOptionCache(id, questionId),
                this.invalidateUserOptionsCache(userId),
            ]);

            this.logger.log(`Question option ${id} deleted successfully`);

            return {
                message: 'Question option deleted successfully',
                status: 'success',
                code: 200,
            };
        });
    }

    /**
     * Get option count for a question with caching
     */
    async getOptionCount(questionId: number): Promise<number> {
        return this.retryOperation(async () => {
            const cacheKey = this.CACHE_KEYS.QUESTION_OPTIONS_COUNT(questionId);

            try {
                const cachedCount =
                    await this.cacheManager.get<number>(cacheKey);
                if (cachedCount !== undefined && cachedCount !== null) {
                    this.logger.debug(
                        `Cache hit for option count: ${cacheKey}`,
                    );
                    return cachedCount;
                }
            } catch (error) {
                this.logger.warn(
                    `Cache get failed for key ${cacheKey}:`,
                    error,
                );
            }

            const count = await this.questionOptionRepository.count({
                where: { questionId },
            });

            try {
                await this.cacheManager.set(
                    cacheKey,
                    count,
                    this.CACHE_TTL.COUNT * 1000,
                );
                this.logger.debug(`Cache set for option count: ${cacheKey}`);
            } catch (error) {
                this.logger.warn(
                    `Cache set failed for key ${cacheKey}:`,
                    error,
                );
            }

            return count;
        });
    }

    /**
     * Get correct options for a question with caching
     */
    async getCorrectOptions(questionId: number): Promise<QuestionOption[]> {
        return this.retryOperation(async () => {
            const cacheKey = this.CACHE_KEYS.CORRECT_OPTIONS(questionId);

            try {
                const cachedOptions =
                    await this.cacheManager.get<QuestionOption[]>(cacheKey);
                if (cachedOptions) {
                    this.logger.debug(
                        `Cache hit for correct options: ${cacheKey}`,
                    );
                    return cachedOptions;
                }
            } catch (error) {
                this.logger.warn(
                    `Cache get failed for key ${cacheKey}:`,
                    error,
                );
            }

            const correctOptions = await this.questionOptionRepository.find({
                where: { questionId, isCorrect: true },
                order: { optionId: 'ASC' },
            });

            try {
                await this.cacheManager.set(
                    cacheKey,
                    correctOptions,
                    this.CACHE_TTL.CORRECT_OPTIONS * 1000,
                );
                this.logger.debug(`Cache set for correct options: ${cacheKey}`);
            } catch (error) {
                this.logger.warn(
                    `Cache set failed for key ${cacheKey}:`,
                    error,
                );
            }

            return correctOptions;
        });
    }

    /**
     * Validate question access and ownership
     */
    private async validateQuestionAccess(
        questionId: number,
        userId: string,
    ): Promise<void> {
        try {
            await this.questionsService.findOne(questionId, userId);
        } catch (error) {
            if (error instanceof NotFoundException) {
                throw new NotFoundException(
                    `Question with ID ${questionId} not found`,
                );
            }
            throw new ForbiddenException(
                'You do not have access to this question',
            );
        }
    }

    /**
     * Validate question access with org/branch scope
     */
    private async validateQuestionAccessWithScope(
        questionId: number,
        scope: OrgBranchScope,
        userId?: string,
    ): Promise<void> {
        try {
            // Use questions service to validate access (it only accepts 2 params)
            await this.questionsService.findOne(questionId, userId);
        } catch (error) {
            if (error instanceof NotFoundException) {
                throw new NotFoundException(
                    `Question with ID ${questionId} not found`,
                );
            } else if (error instanceof ForbiddenException) {
                throw new ForbiddenException(
                    'Access denied to the specified question',
                );
            }
            throw error;
        }
    }

    /**
     * Map QuestionOption entity to response DTO
     */
    private mapToResponseDto(
        option: QuestionOption,
    ): QuestionOptionResponseDto {
        return {
            optionId: option.optionId,
            questionId: option.questionId,
            optionText: option.optionText,
            isCorrect: option.isCorrect,
            createdAt: option.createdAt,
            updatedAt: option.updatedAt,
            question: option.question
                ? {
                      questionId: option.question.questionId,
                      questionText: option.question.questionText,
                      questionType: option.question.questionType,
                      points: option.question.points,
                  }
                : undefined,
            // TODO: Add statistics when implementing Answers module
            timesSelected: 0, // Will be calculated when Answers module is implemented
            selectionPercentage: 0, // Will be calculated when Answers module is implemented
        };
    }
}

/*
 * Class #163: CourseStatsDto
 * Source: reports/dto/course-analytics.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 6
 * Decorators: 12
 * Complexity: 25
 * Size: 1100 characters (48 lines)
 */
export class CourseStatsDto {
    @ApiProperty({
        description: 'Total number of students enrolled in the course',
        example: 125,
    })
    @IsNumber()
    totalStudentsEnrolled: number;

    @ApiProperty({
        description: 'Course completion rate as percentage',
        example: 78.5,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    completionRate: number;

    @ApiProperty({
        description: 'Average study duration in hours',
        example: 45.2,
    })
    @IsNumber()
    averageStudyDurationHours: number;

    @ApiProperty({
        description:
            'Course popularity score based on enrollments and completions',
        example: 85.7,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    popularityScore: number;

    @ApiProperty({
        description: 'Total number of tests in the course',
        example: 8,
    })
    @IsNumber()
    totalTests: number;

    @ApiProperty({
        description: 'Average test score across all students',
        example: 82.3,
    })
    @IsNumber()
    averageTestScore: number;
}

/*
 * Class #164: CoursePerformanceDto
 * Source: reports/dto/course-analytics.dto.ts:53
 * Type: Exported Class
 * Methods: 0
 * Properties: 6
 * Decorators: 13
 * Complexity: 29
 * Size: 1021 characters (45 lines)
 */
export class CoursePerformanceDto {
    @ApiProperty({
        description: 'Course ID',
        example: 1,
    })
    @IsNumber()
    courseId: number;

    @ApiProperty({
        description: 'Course title',
        example: 'Introduction to Computer Science',
    })
    @IsString()
    courseTitle: string;

    @ApiProperty({
        description: 'Total number of test attempts in the course',
        example: 450,
    })
    @IsNumber()
    totalAttempts: number;

    @ApiProperty({
        description: 'Success rate percentage for first attempts',
        example: 65.5,
    })
    @IsNumber()
    firstAttemptSuccessRate: number;

    @ApiProperty({
        description: 'Average number of attempts per student',
        example: 2.3,
    })
    @IsNumber()
    averageAttemptsPerStudent: number;

    @ApiProperty({
        description: 'Most challenging test in the course',
        example: 'Final Exam',
        required: false,
    })
    @IsString()
    @IsOptional()
    mostChallengingTest?: string;
}

/*
 * Class #165: CourseAnalyticsResponseDto
 * Source: reports/dto/course-analytics.dto.ts:99
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 4
 * Complexity: 9
 * Size: 613 characters (25 lines)
 */
export class CourseAnalyticsResponseDto {
    @ApiProperty({
        description: 'Course basic statistics',
        type: CourseStatsDto,
    })
    stats: CourseStatsDto;

    @ApiProperty({
        description: 'Course performance metrics',
        type: CoursePerformanceDto,
    })
    performance: CoursePerformanceDto;

    @ApiProperty({
        description: 'Timestamp when the report was generated',
        example: '2024-01-15T10:30:45.123Z',
    })
    generatedAt: Date;

    @ApiProperty({
        description: 'Whether this data is from cache',
        example: true,
    })
    cached: boolean;
}

/*
 * Class #166: LeaderboardStatsReportDto
 * Source: reports/dto/leaderboard-analytics.dto.ts:3
 * Type: Exported Class
 * Methods: 0
 * Properties: 7
 * Decorators: 5
 * Complexity: 12
 * Size: 680 characters (31 lines)
 */
export class LeaderboardStatsReportDto {
    @ApiProperty({
        description: 'Total number of leaderboard rankings',
        example: 15,
    })
    totalRankings: number;

    @ApiProperty({
        description: 'Average rank across all courses',
        example: 12.5,
    })
    averageRank: number;

    @ApiProperty({
        description: 'Best rank achieved',
        example: 3,
    })
    bestRank: number;

    @ApiProperty({
        description: 'Total points accumulated',
        example: 2850,
    })
    totalPoints: number;

    @ApiProperty({
        description: 'Recent activity count (last 30 days)',
        example: 8,
    })
    recentActivity: number;
}

/*
 * Class #167: PerformanceTrendLeaderboardDto
 * Source: reports/dto/leaderboard-analytics.dto.ts:35
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 9
 * Size: 479 characters (21 lines)
 */
export class PerformanceTrendLeaderboardDto {
    @ApiProperty({
        description: 'Date of the performance data',
        type: 'string',
        format: 'date',
        example: '2024-01-15',
    })
    date: string;

    @ApiProperty({
        description: 'Average points for that date',
        example: 185.5,
    })
    averagePoints: number;

    @ApiProperty({
        description: 'Average rank for that date',
        example: 8.3,
    })
    averageRank: number;
}

/*
 * Class #168: CoursePerformanceLeaderboardDto
 * Source: reports/dto/leaderboard-analytics.dto.ts:57
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 4
 * Complexity: 9
 * Size: 510 characters (25 lines)
 */
export class CoursePerformanceLeaderboardDto {
    @ApiProperty({
        description: 'Course ID',
        example: 1,
    })
    courseId: number;

    @ApiProperty({
        description: 'Course name',
        example: 'Advanced Mathematics',
    })
    courseName: string;

    @ApiProperty({
        description: 'Current rank in this course',
        example: 5,
    })
    rank: number;

    @ApiProperty({
        description: 'Points in this course',
        example: 425,
    })
    points: number;
}

/*
 * Class #169: LeaderboardPerformanceReportDto
 * Source: reports/dto/leaderboard-analytics.dto.ts:83
 * Type: Exported Class
 * Methods: 0
 * Properties: 2
 * Decorators: 2
 * Complexity: 5
 * Size: 412 characters (13 lines)
 */
export class LeaderboardPerformanceReportDto {
    @ApiProperty({
        description: 'Performance trends over time',
        type: [PerformanceTrendLeaderboardDto],
    })
    performanceTrends: PerformanceTrendLeaderboardDto[];

    @ApiProperty({
        description: 'Performance by course',
        type: [CoursePerformanceLeaderboardDto],
    })
    coursePerformance: CoursePerformanceLeaderboardDto[];
}

/*
 * Class #170: LeaderboardAnalyticsReportDto
 * Source: reports/dto/leaderboard-analytics.dto.ts:97
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 4
 * Complexity: 9
 * Size: 728 characters (27 lines)
 */
export class LeaderboardAnalyticsReportDto {
    @ApiProperty({
        description: 'Leaderboard statistics',
        type: LeaderboardStatsReportDto,
    })
    stats: LeaderboardStatsReportDto;

    @ApiProperty({
        description: 'Performance insights and trends',
        type: LeaderboardPerformanceReportDto,
    })
    performance: LeaderboardPerformanceReportDto;

    @ApiProperty({
        description: 'Timestamp when the analytics were generated',
        type: 'string',
        format: 'date-time',
        example: '2024-01-15T10:30:00Z',
    })
    generatedAt: Date;

    @ApiProperty({
        description: 'Whether the data was retrieved from cache',
        example: false,
    })
    cached: boolean;
}

/*
 * Class #171: TopPerformerReportDto
 * Source: reports/dto/leaderboard-analytics.dto.ts:125
 * Type: Exported Class
 * Methods: 0
 * Properties: 8
 * Decorators: 5
 * Complexity: 14
 * Size: 611 characters (32 lines)
 */
export class TopPerformerReportDto {
    @ApiProperty({
        description: 'User ID',
        example: 'user123',
    })
    userId: string;

    @ApiProperty({
        description: 'User name',
        example: 'John Doe',
    })
    name: string;

    @ApiProperty({
        description: 'Total points',
        example: 1850,
    })
    points: number;

    @ApiProperty({
        description: 'Current rank',
        example: 1,
    })
    rank: number;

    @ApiProperty({
        description: 'Course ID (if course-specific)',
        example: 1,
        required: false,
    })
    courseId?: number;
}

/*
 * Class #172: GlobalPerformerReportDto
 * Source: reports/dto/leaderboard-analytics.dto.ts:158
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 4
 * Complexity: 9
 * Size: 524 characters (25 lines)
 */
export class GlobalPerformerReportDto {
    @ApiProperty({
        description: 'User ID',
        example: 'user123',
    })
    userId: string;

    @ApiProperty({
        description: 'User name',
        example: 'John Doe',
    })
    name: string;

    @ApiProperty({
        description: 'Total points across all courses',
        example: 5240,
    })
    totalPoints: number;

    @ApiProperty({
        description: 'Number of courses participated in',
        example: 8,
    })
    coursesParticipated: number;
}

/*
 * Class #173: ActiveCourseLeaderboardDto
 * Source: reports/dto/leaderboard-analytics.dto.ts:184
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 5
 * Complexity: 11
 * Size: 643 characters (31 lines)
 */
export class ActiveCourseLeaderboardDto {
    @ApiProperty({
        description: 'Course ID',
        example: 1,
    })
    courseId: number;

    @ApiProperty({
        description: 'Course title',
        example: 'Advanced Mathematics',
    })
    title: string;

    @ApiProperty({
        description: 'Number of participants',
        example: 156,
    })
    participants: number;

    @ApiProperty({
        description: 'Average points in this course',
        example: 285.5,
    })
    averagePoints: number;

    @ApiProperty({
        description: 'Top score in this course',
        example: 950,
    })
    topScore: number;
}

/*
 * Class #174: GlobalLeaderboardStatsReportDto
 * Source: reports/dto/leaderboard-analytics.dto.ts:216
 * Type: Exported Class
 * Methods: 0
 * Properties: 9
 * Decorators: 7
 * Complexity: 16
 * Size: 1184 characters (45 lines)
 */
export class GlobalLeaderboardStatsReportDto {
    @ApiProperty({
        description: 'Total participants across all leaderboards',
        example: 2847,
    })
    totalParticipants: number;

    @ApiProperty({
        description: 'Average points across all participants',
        example: 312.8,
    })
    averagePoints: number;

    @ApiProperty({
        description: 'Top 10 global performers',
        type: [GlobalPerformerReportDto],
    })
    topGlobalPerformers: GlobalPerformerReportDto[];

    @ApiProperty({
        description: 'Most active courses by participant count',
        type: [ActiveCourseLeaderboardDto],
    })
    mostActiveCourses: ActiveCourseLeaderboardDto[];

    @ApiProperty({
        description: 'Recent activity count (last 7 days)',
        example: 485,
    })
    recentActivity: number;

    @ApiProperty({
        description: 'Timestamp when the statistics were generated',
        type: 'string',
        format: 'date-time',
        example: '2024-01-15T10:30:00Z',
    })
    generatedAt: Date;

    @ApiProperty({
        description: 'Whether the data was retrieved from cache',
        example: false,
    })
    cached: boolean;
}

/*
 * Class #175: RankMovementReportDto
 * Source: reports/dto/leaderboard-analytics.dto.ts:262
 * Type: Exported Class
 * Methods: 0
 * Properties: 9
 * Decorators: 7
 * Complexity: 16
 * Size: 833 characters (43 lines)
 */
export class RankMovementReportDto {
    @ApiProperty({
        description: 'User ID',
        example: 'user123',
    })
    userId: string;

    @ApiProperty({
        description: 'User name',
        example: 'John Doe',
    })
    name: string;

    @ApiProperty({
        description: 'Current rank',
        example: 8,
    })
    currentRank: number;

    @ApiProperty({
        description: 'Previous rank',
        example: 12,
    })
    previousRank: number;

    @ApiProperty({
        description: 'Rank change (positive = improvement)',
        example: 4,
    })
    rankChange: number;

    @ApiProperty({
        description: 'Current points',
        example: 1250,
    })
    currentPoints: number;

    @ApiProperty({
        description: 'Points change',
        example: 75,
    })
    pointsChange: number;
}

/*
 * Class #176: CompetitiveMetricsReportDto
 * Source: reports/dto/leaderboard-analytics.dto.ts:306
 * Type: Exported Class
 * Methods: 0
 * Properties: 8
 * Decorators: 6
 * Complexity: 15
 * Size: 885 characters (37 lines)
 */
export class CompetitiveMetricsReportDto {
    @ApiProperty({
        description: 'Total number of participants',
        example: 156,
    })
    totalParticipants: number;

    @ApiProperty({
        description: 'Competition intensity score (0-100)',
        example: 78.5,
    })
    competitionIntensity: number;

    @ApiProperty({
        description: 'Average points among all participants',
        example: 425.8,
    })
    averagePoints: number;

    @ApiProperty({
        description: 'Points threshold for top 10% performers',
        example: 850.0,
    })
    topPerformerThreshold: number;

    @ApiProperty({
        description: 'Gap between top 10% and bottom 10%',
        example: 650.5,
    })
    participationGap: number;

    @ApiProperty({
        description: 'Standard deviation of points',
        example: 125.3,
    })
    standardDeviation: number;
}

/*
 * Class #177: ResultsStatsReportDto
 * Source: reports/dto/results-analytics.dto.ts:3
 * Type: Exported Class
 * Methods: 0
 * Properties: 9
 * Decorators: 7
 * Complexity: 16
 * Size: 914 characters (43 lines)
 */
export class ResultsStatsReportDto {
    @ApiProperty({
        description: 'Total number of results',
        example: 156,
    })
    totalResults: number;

    @ApiProperty({
        description: 'Number of passed results',
        example: 98,
    })
    passedResults: number;

    @ApiProperty({
        description: 'Number of failed results',
        example: 58,
    })
    failedResults: number;

    @ApiProperty({
        description: 'Pass rate percentage',
        example: 62.82,
    })
    passRate: number;

    @ApiProperty({
        description: 'Average score across all results',
        example: 74.5,
    })
    averageScore: number;

    @ApiProperty({
        description: 'Best score achieved',
        example: 95.0,
    })
    bestScore: number;

    @ApiProperty({
        description: 'Number of recent results (last 7 days)',
        example: 12,
    })
    recentResults: number;
}

/*
 * Class #178: ScoreHistoryReportDto
 * Source: reports/dto/results-analytics.dto.ts:47
 * Type: Exported Class
 * Methods: 0
 * Properties: 2
 * Decorators: 2
 * Complexity: 6
 * Size: 331 characters (15 lines)
 */
export class ScoreHistoryReportDto {
    @ApiProperty({
        description: 'Date of the score',
        type: 'string',
        format: 'date',
        example: '2024-01-15',
    })
    date: string;

    @ApiProperty({
        description: 'Average score for that date',
        example: 78.5,
    })
    averageScore: number;
}

/*
 * Class #179: SubjectPerformanceReportDto
 * Source: reports/dto/results-analytics.dto.ts:63
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 4
 * Complexity: 10
 * Size: 553 characters (25 lines)
 */
export class SubjectPerformanceReportDto {
    @ApiProperty({
        description: 'Subject or course name',
        example: 'Mathematics',
    })
    subject: string;

    @ApiProperty({
        description: 'Average score in this subject',
        example: 82.3,
    })
    averageScore: number;

    @ApiProperty({
        description: 'Total attempts in this subject',
        example: 25,
    })
    totalAttempts: number;

    @ApiProperty({
        description: 'Pass rate for this subject',
        example: 76.0,
    })
    passRate: number;
}

/*
 * Class #180: ResultsPerformanceReportDto
 * Source: reports/dto/results-analytics.dto.ts:89
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 4
 * Complexity: 9
 * Size: 663 characters (25 lines)
 */
export class ResultsPerformanceReportDto {
    @ApiProperty({
        description: 'Score history over time',
        type: [ScoreHistoryReportDto],
    })
    scoreHistory: ScoreHistoryReportDto[];

    @ApiProperty({
        description: 'Performance by subject/course',
        type: [SubjectPerformanceReportDto],
    })
    subjectPerformance: SubjectPerformanceReportDto[];

    @ApiProperty({
        description: 'Overall improvement from first to last result',
        example: 15.5,
    })
    improvement: number;

    @ApiProperty({
        description: 'Improvement as a percentage',
        example: 23.8,
    })
    improvementPercentage: number;
}

/*
 * Class #181: ResultsQualityReportDto
 * Source: reports/dto/results-analytics.dto.ts:115
 * Type: Exported Class
 * Methods: 0
 * Properties: 9
 * Decorators: 5
 * Complexity: 13
 * Size: 728 characters (31 lines)
 */
export class ResultsQualityReportDto {
    @ApiProperty({
        description: 'Score consistency measure (0-100)',
        example: 85.2,
    })
    scoreConsistency: number;

    @ApiProperty({
        description: 'Results reliability score (0-100)',
        example: 78.9,
    })
    reliability: number;

    @ApiProperty({
        description: 'Number of outlier scores detected',
        example: 3,
    })
    outlierCount: number;

    @ApiProperty({
        description: 'Performance variance from expected difficulty',
        example: 12.5,
    })
    performanceVariance: number;

    @ApiProperty({
        description: 'Standard deviation of scores',
        example: 14.2,
    })
    standardDeviation: number;
}

/*
 * Class #182: ResultsAnalyticsReportDto
 * Source: reports/dto/results-analytics.dto.ts:147
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 5
 * Complexity: 11
 * Size: 864 characters (33 lines)
 */
export class ResultsAnalyticsReportDto {
    @ApiProperty({
        description: 'Results statistics',
        type: ResultsStatsReportDto,
    })
    stats: ResultsStatsReportDto;

    @ApiProperty({
        description: 'Performance insights and trends',
        type: ResultsPerformanceReportDto,
    })
    performance: ResultsPerformanceReportDto;

    @ApiProperty({
        description: 'Quality and reliability metrics',
        type: ResultsQualityReportDto,
    })
    quality: ResultsQualityReportDto;

    @ApiProperty({
        description: 'Timestamp when the analytics were generated',
        type: 'string',
        format: 'date-time',
        example: '2024-01-15T10:30:00Z',
    })
    generatedAt: Date;

    @ApiProperty({
        description: 'Whether the data was retrieved from cache',
        example: false,
    })
    cached: boolean;
}

/*
 * Class #183: ScoreDistributionReportDto
 * Source: reports/dto/results-analytics.dto.ts:181
 * Type: Exported Class
 * Methods: 0
 * Properties: 15
 * Decorators: 5
 * Complexity: 16
 * Size: 642 characters (31 lines)
 */
export class ScoreDistributionReportDto {
    @ApiProperty({
        description: 'Number of A grades (90-100%)',
        example: 25,
    })
    aGrade: number;

    @ApiProperty({
        description: 'Number of B grades (80-89%)',
        example: 42,
    })
    bGrade: number;

    @ApiProperty({
        description: 'Number of C grades (70-79%)',
        example: 38,
    })
    cGrade: number;

    @ApiProperty({
        description: 'Number of D grades (60-69%)',
        example: 28,
    })
    dGrade: number;

    @ApiProperty({
        description: 'Number of F grades (0-59%)',
        example: 23,
    })
    fGrade: number;
}

/*
 * Class #184: TopPerformingCourseReportDto
 * Source: reports/dto/results-analytics.dto.ts:213
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 4
 * Complexity: 11
 * Size: 540 characters (25 lines)
 */
export class TopPerformingCourseReportDto {
    @ApiProperty({
        description: 'Course ID',
        example: 1,
    })
    courseId: number;

    @ApiProperty({
        description: 'Course title',
        example: 'Advanced Mathematics',
    })
    title: string;

    @ApiProperty({
        description: 'Average score for this course',
        example: 87.5,
    })
    averageScore: number;

    @ApiProperty({
        description: 'Total number of results for this course',
        example: 156,
    })
    totalResults: number;
}

/*
 * Class #185: GlobalResultsStatsReportDto
 * Source: reports/dto/results-analytics.dto.ts:239
 * Type: Exported Class
 * Methods: 0
 * Properties: 10
 * Decorators: 10
 * Complexity: 21
 * Size: 1561 characters (63 lines)
 */
export class GlobalResultsStatsReportDto {
    @ApiProperty({
        description: 'Total results across all courses',
        example: 2847,
    })
    totalResults: number;

    @ApiProperty({
        description: 'Total passed results',
        example: 1823,
    })
    passedResults: number;

    @ApiProperty({
        description: 'Total failed results',
        example: 1024,
    })
    failedResults: number;

    @ApiProperty({
        description: 'Global pass rate percentage',
        example: 64.0,
    })
    passRate: number;

    @ApiProperty({
        description: 'Overall average score across all results',
        example: 72.8,
    })
    overallAverageScore: number;

    @ApiProperty({
        description: 'Score distribution across grade levels',
        type: ScoreDistributionReportDto,
    })
    scoreDistribution: ScoreDistributionReportDto;

    @ApiProperty({
        description: 'Number of results in the last 30 days',
        example: 485,
    })
    recentResults: number;

    @ApiProperty({
        description: 'Top 5 performing courses by average score',
        type: [TopPerformingCourseReportDto],
    })
    topPerformingCourses: TopPerformingCourseReportDto[];

    @ApiProperty({
        description: 'Timestamp when the statistics were generated',
        type: 'string',
        format: 'date-time',
        example: '2024-01-15T10:30:00Z',
    })
    generatedAt: Date;

    @ApiProperty({
        description: 'Whether the data was retrieved from cache',
        example: false,
    })
    cached: boolean;
}

/*
 * Class #186: PerformanceTrendReportDto
 * Source: reports/dto/results-analytics.dto.ts:303
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 5
 * Complexity: 15
 * Size: 740 characters (33 lines)
 */
export class PerformanceTrendReportDto {
    @ApiProperty({
        description: 'Date of the performance data',
        type: 'string',
        format: 'date',
        example: '2024-01-15',
    })
    date: string;

    @ApiProperty({
        description: 'Average score for that date',
        example: 75.4,
    })
    averageScore: number;

    @ApiProperty({
        description: 'Total number of results for that date',
        example: 23,
    })
    totalResults: number;

    @ApiProperty({
        description: 'Number of passed results for that date',
        example: 15,
    })
    passedResults: number;

    @ApiProperty({
        description: 'Pass rate for that date',
        example: 65.2,
    })
    passRate: number;
}

/*
 * Class #187: TestStatsDto
 * Source: reports/dto/test-analytics.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 8
 * Decorators: 16
 * Complexity: 34
 * Size: 1326 characters (61 lines)
 */
export class TestStatsDto {
    @ApiProperty({
        description: 'Total number of attempts for this test',
        example: 150,
    })
    @IsNumber()
    totalAttempts: number;

    @ApiProperty({
        description: 'Number of completed attempts',
        example: 125,
    })
    @IsNumber()
    completedAttempts: number;

    @ApiProperty({
        description: 'Test completion rate as percentage',
        example: 83.3,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    completionRate: number;

    @ApiProperty({
        description: 'Average test duration in minutes',
        example: 45.5,
    })
    @IsNumber()
    averageDurationMinutes: number;

    @ApiProperty({
        description: 'Average score across all attempts',
        example: 78.2,
    })
    @IsNumber()
    averageScore: number;

    @ApiProperty({
        description: 'Pass rate percentage',
        example: 72.0,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    passRate: number;

    @ApiProperty({
        description: 'Average number of attempts per user',
        example: 2.3,
    })
    @IsNumber()
    averageAttemptsPerUser: number;

    @ApiProperty({
        description: 'First attempt success rate',
        example: 58.5,
    })
    @IsNumber()
    firstAttemptSuccessRate: number;
}

/*
 * Class #188: TestPerformanceDto
 * Source: reports/dto/test-analytics.dto.ts:66
 * Type: Exported Class
 * Methods: 0
 * Properties: 15
 * Decorators: 20
 * Complexity: 46
 * Size: 1457 characters (66 lines)
 */
export class TestPerformanceDto {
    @ApiProperty({
        description: 'Test ID',
        example: 1,
    })
    @IsNumber()
    testId: number;

    @ApiProperty({
        description: 'Test title',
        example: 'Mathematics Final Exam',
    })
    @IsString()
    testTitle: string;

    @ApiProperty({
        description: 'Test type (EXAM, QUIZ, TRAINING)',
        example: 'EXAM',
    })
    @IsString()
    testType: string;

    @ApiProperty({
        description: 'Highest score achieved',
        example: 98.5,
    })
    @IsNumber()
    highestScore: number;

    @ApiProperty({
        description: 'Lowest score achieved',
        example: 32.0,
    })
    @IsNumber()
    lowestScore: number;

    @ApiProperty({
        description: 'Score standard deviation',
        example: 18.3,
    })
    @IsNumber()
    scoreStandardDeviation: number;

    @ApiProperty({
        description: 'Most challenging question (lowest success rate)',
        example: 'Question 15: Complex Integration',
    })
    @IsString()
    @IsOptional()
    mostChallengingQuestion?: string;

    @ApiProperty({
        description: 'Easiest question (highest success rate)',
        example: 'Question 1: Basic Addition',
    })
    @IsString()
    @IsOptional()
    easiestQuestion?: string;

    @ApiProperty({
        description: 'Average time per question in seconds',
        example: 120.5,
    })
    @IsNumber()
    averageTimePerQuestion: number;
}

/*
 * Class #189: TestQualityDto
 * Source: reports/dto/test-analytics.dto.ts:133
 * Type: Exported Class
 * Methods: 0
 * Properties: 17
 * Decorators: 12
 * Complexity: 28
 * Size: 1225 characters (51 lines)
 */
export class TestQualityDto {
    @ApiProperty({
        description: 'Test difficulty score (0-100)',
        example: 65.5,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    difficultyScore: number;

    @ApiProperty({
        description: 'Test reliability coefficient',
        example: 0.85,
        minimum: 0,
        maximum: 1,
    })
    @IsNumber()
    reliabilityCoefficient: number;

    @ApiProperty({
        description:
            'Discrimination index (how well test distinguishes performance)',
        example: 0.72,
        minimum: 0,
        maximum: 1,
    })
    @IsNumber()
    discriminationIndex: number;

    @ApiProperty({
        description: 'Percentage of questions with good discrimination',
        example: 78.5,
    })
    @IsNumber()
    effectiveQuestionsPercentage: number;

    @ApiProperty({
        description: 'Optimal duration recommendation in minutes',
        example: 50,
    })
    @IsNumber()
    optimalDurationMinutes: number;

    @ApiProperty({
        description: 'Time pressure factor (based on completion patterns)',
        example: 'moderate',
        enum: ['low', 'moderate', 'high'],
    })
    @IsString()
    timePressureFactor: string;
}

/*
 * Class #190: TestAnalyticsResponseDto
 * Source: reports/dto/test-analytics.dto.ts:185
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 5
 * Complexity: 11
 * Size: 730 characters (31 lines)
 */
export class TestAnalyticsResponseDto {
    @ApiProperty({
        description: 'Test basic statistics',
        type: TestStatsDto,
    })
    stats: TestStatsDto;

    @ApiProperty({
        description: 'Test performance metrics',
        type: TestPerformanceDto,
    })
    performance: TestPerformanceDto;

    @ApiProperty({
        description: 'Test quality metrics',
        type: TestQualityDto,
    })
    quality: TestQualityDto;

    @ApiProperty({
        description: 'Timestamp when the report was generated',
        example: '2024-01-15T10:30:45.123Z',
    })
    generatedAt: Date;

    @ApiProperty({
        description: 'Whether this data is from cache',
        example: true,
    })
    cached: boolean;
}

/*
 * Class #191: GlobalTestStatsDto
 * Source: reports/dto/test-analytics.dto.ts:217
 * Type: Exported Class
 * Methods: 0
 * Properties: 11
 * Decorators: 15
 * Complexity: 32
 * Size: 1241 characters (57 lines)
 */
export class GlobalTestStatsDto {
    @ApiProperty({
        description: 'Total number of tests in the system',
        example: 45,
    })
    @IsNumber()
    totalTests: number;

    @ApiProperty({
        description: 'Total test attempts across all tests',
        example: 1250,
    })
    @IsNumber()
    totalAttempts: number;

    @ApiProperty({
        description: 'Tests taken today',
        example: 85,
    })
    @IsNumber()
    testsToday: number;

    @ApiProperty({
        description: 'Tests taken this week',
        example: 420,
    })
    @IsNumber()
    testsThisWeek: number;

    @ApiProperty({
        description: 'Average test completion rate across all tests',
        example: 78.5,
    })
    @IsNumber()
    averageCompletionRate: number;

    @ApiProperty({
        description: 'Average score across all tests',
        example: 75.2,
    })
    @IsNumber()
    averageScore: number;

    @ApiProperty({
        description: 'Most popular test type',
        example: 'QUIZ',
    })
    @IsString()
    mostPopularTestType: string;

    @ApiProperty({
        description: 'Peak testing hours (hour of day)',
        example: [14, 15, 16],
        type: [Number],
    })
    peakTestingHours: number[];
}

/*
 * Class #192: TrainingProgressStatsReportDto
 * Source: reports/dto/training-progress-analytics.dto.ts:3
 * Type: Exported Class
 * Methods: 0
 * Properties: 9
 * Decorators: 5
 * Complexity: 13
 * Size: 735 characters (31 lines)
 */
export class TrainingProgressStatsReportDto {
    @ApiProperty({
        description: 'Total number of courses enrolled',
        example: 8,
    })
    totalCourses: number;

    @ApiProperty({
        description: 'Number of completed courses',
        example: 3,
    })
    completedCourses: number;

    @ApiProperty({
        description: 'Average completion percentage across all courses',
        example: 72.5,
    })
    averageCompletion: number;

    @ApiProperty({
        description: 'Total time spent learning (in minutes)',
        example: 1250,
    })
    totalTimeSpent: number;

    @ApiProperty({
        description: 'Recent activity count (last 7 days)',
        example: 5,
    })
    recentActivity: number;
}

/*
 * Class #193: LearningVelocityTrendDto
 * Source: reports/dto/training-progress-analytics.dto.ts:35
 * Type: Exported Class
 * Methods: 0
 * Properties: 2
 * Decorators: 2
 * Complexity: 6
 * Size: 363 characters (15 lines)
 */
export class LearningVelocityTrendDto {
    @ApiProperty({
        description: 'Date of the learning data',
        type: 'string',
        format: 'date',
        example: '2024-01-15',
    })
    date: string;

    @ApiProperty({
        description: 'Average completion percentage for that date',
        example: 78.5,
    })
    averageCompletion: number;
}

/*
 * Class #194: CourseProgressReportDto
 * Source: reports/dto/training-progress-analytics.dto.ts:51
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 3
 * Complexity: 8
 * Size: 432 characters (19 lines)
 */
export class CourseProgressReportDto {
    @ApiProperty({
        description: 'Course name',
        example: 'Advanced Mathematics',
    })
    courseName: string;

    @ApiProperty({
        description: 'Completion percentage',
        example: 85.5,
    })
    completionPercentage: number;

    @ApiProperty({
        description: 'Time spent on this course (in minutes)',
        example: 420,
    })
    timeSpent: number;
}

/*
 * Class #195: TrainingProgressPerformanceReportDto
 * Source: reports/dto/training-progress-analytics.dto.ts:71
 * Type: Exported Class
 * Methods: 0
 * Properties: 2
 * Decorators: 2
 * Complexity: 5
 * Size: 388 characters (13 lines)
 */
export class TrainingProgressPerformanceReportDto {
    @ApiProperty({
        description: 'Learning velocity trends over time',
        type: [LearningVelocityTrendDto],
    })
    learningVelocity: LearningVelocityTrendDto[];

    @ApiProperty({
        description: 'Progress by course',
        type: [CourseProgressReportDto],
    })
    courseProgress: CourseProgressReportDto[];
}

/*
 * Class #196: TrainingProgressAnalyticsReportDto
 * Source: reports/dto/training-progress-analytics.dto.ts:85
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 4
 * Complexity: 9
 * Size: 759 characters (27 lines)
 */
export class TrainingProgressAnalyticsReportDto {
    @ApiProperty({
        description: 'Training progress statistics',
        type: TrainingProgressStatsReportDto,
    })
    stats: TrainingProgressStatsReportDto;

    @ApiProperty({
        description: 'Performance insights and trends',
        type: TrainingProgressPerformanceReportDto,
    })
    performance: TrainingProgressPerformanceReportDto;

    @ApiProperty({
        description: 'Timestamp when the analytics were generated',
        type: 'string',
        format: 'date-time',
        example: '2024-01-15T10:30:00Z',
    })
    generatedAt: Date;

    @ApiProperty({
        description: 'Whether the data was retrieved from cache',
        example: false,
    })
    cached: boolean;
}

/*
 * Class #197: CompletionDistributionDto
 * Source: reports/dto/training-progress-analytics.dto.ts:113
 * Type: Exported Class
 * Methods: 0
 * Properties: 15
 * Decorators: 5
 * Complexity: 16
 * Size: 718 characters (31 lines)
 */
export class CompletionDistributionDto {
    @ApiProperty({
        description: 'Number of completed courses (100%)',
        example: 25,
    })
    completed: number;

    @ApiProperty({
        description: 'Number of nearly completed courses (75-99%)',
        example: 18,
    })
    nearlyCompleted: number;

    @ApiProperty({
        description: 'Number of halfway completed courses (50-74%)',
        example: 22,
    })
    halfway: number;

    @ApiProperty({
        description: 'Number of started courses (25-49%)',
        example: 35,
    })
    started: number;

    @ApiProperty({
        description: 'Number of just started courses (0-24%)',
        example: 45,
    })
    justStarted: number;
}

/*
 * Class #198: PopularLearningPathDto
 * Source: reports/dto/training-progress-analytics.dto.ts:145
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 4
 * Complexity: 9
 * Size: 528 characters (25 lines)
 */
export class PopularLearningPathDto {
    @ApiProperty({
        description: 'Course ID',
        example: 1,
    })
    courseId: number;

    @ApiProperty({
        description: 'Course title',
        example: 'Introduction to Data Science',
    })
    title: string;

    @ApiProperty({
        description: 'Number of enrollments',
        example: 156,
    })
    enrollments: number;

    @ApiProperty({
        description: 'Average completion percentage',
        example: 68.5,
    })
    averageCompletion: number;
}

/*
 * Class #199: LearningVelocityGlobalTrendDto
 * Source: reports/dto/training-progress-analytics.dto.ts:171
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 7
 * Size: 505 characters (21 lines)
 */
export class LearningVelocityGlobalTrendDto {
    @ApiProperty({
        description: 'Date of the velocity data',
        type: 'string',
        format: 'date',
        example: '2024-01-15',
    })
    date: string;

    @ApiProperty({
        description: 'Average completion percentage across all users',
        example: 72.3,
    })
    averageCompletion: number;

    @ApiProperty({
        description: 'Number of active users on that date',
        example: 45,
    })
    activeUsers: number;
}

/*
 * Class #200: GlobalTrainingProgressStatsReportDto
 * Source: reports/dto/training-progress-analytics.dto.ts:193
 * Type: Exported Class
 * Methods: 0
 * Properties: 10
 * Decorators: 8
 * Complexity: 18
 * Size: 1409 characters (51 lines)
 */
export class GlobalTrainingProgressStatsReportDto {
    @ApiProperty({
        description: 'Total number of learning paths',
        example: 1847,
    })
    totalLearningPaths: number;

    @ApiProperty({
        description: 'Average completion percentage across all paths',
        example: 58.7,
    })
    averageCompletion: number;

    @ApiProperty({
        description: 'Number of active learners (last 7 days)',
        example: 285,
    })
    activeLearners: number;

    @ApiProperty({
        description: 'Completion distribution across different stages',
        type: CompletionDistributionDto,
    })
    completionDistribution: CompletionDistributionDto;

    @ApiProperty({
        description: 'Most popular learning paths by enrollment',
        type: [PopularLearningPathDto],
    })
    popularLearningPaths: PopularLearningPathDto[];

    @ApiProperty({
        description: 'Learning velocity trends over time',
        type: [LearningVelocityGlobalTrendDto],
    })
    learningVelocityTrends: LearningVelocityGlobalTrendDto[];

    @ApiProperty({
        description: 'Timestamp when the statistics were generated',
        type: 'string',
        format: 'date-time',
        example: '2024-01-15T10:30:00Z',
    })
    generatedAt: Date;

    @ApiProperty({
        description: 'Whether the data was retrieved from cache',
        example: false,
    })
    cached: boolean;
}

/*
 * Class #201: LearningPathCompletionReportDto
 * Source: reports/dto/training-progress-analytics.dto.ts:245
 * Type: Exported Class
 * Methods: 0
 * Properties: 11
 * Decorators: 7
 * Complexity: 17
 * Size: 1033 characters (45 lines)
 */
export class LearningPathCompletionReportDto {
    @ApiProperty({
        description: 'Course ID',
        example: 1,
    })
    courseId: number;

    @ApiProperty({
        description: 'Course title',
        example: 'Advanced JavaScript',
    })
    title: string;

    @ApiProperty({
        description: 'Completion percentage',
        example: 75.5,
    })
    completionPercentage: number;

    @ApiProperty({
        description: 'Current module or chapter',
        example: 'Module 8: Async Programming',
    })
    currentModule: string;

    @ApiProperty({
        description: 'Time spent on this course (in minutes)',
        example: 420,
    })
    timeSpent: number;

    @ApiProperty({
        description: 'Last activity timestamp',
        type: 'string',
        format: 'date-time',
        example: '2024-01-15T14:30:00Z',
    })
    lastActivity: Date;

    @ApiProperty({
        description: 'Estimated time to complete (in minutes)',
        example: 140,
    })
    estimatedTimeToComplete: number;
}

/*
 * Class #202: SkillDevelopmentReportDto
 * Source: reports/dto/training-progress-analytics.dto.ts:291
 * Type: Exported Class
 * Methods: 0
 * Properties: 11
 * Decorators: 7
 * Complexity: 17
 * Size: 1109 characters (44 lines)
 */
export class SkillDevelopmentReportDto {
    @ApiProperty({
        description: 'Skill area or subject',
        example: 'JavaScript Programming',
    })
    skillArea: string;

    @ApiProperty({
        description: 'Current skill level',
        enum: ['Beginner', 'Intermediate', 'Advanced', 'Expert'],
        example: 'Intermediate',
    })
    skillLevel: 'Beginner' | 'Intermediate' | 'Advanced' | 'Expert';

    @ApiProperty({
        description: 'Progress percentage in this skill area',
        example: 68.5,
    })
    progressPercentage: number;

    @ApiProperty({
        description: 'Average test score in this skill area',
        example: 78.3,
    })
    averageTestScore: number;

    @ApiProperty({
        description: 'Total number of test attempts',
        example: 12,
    })
    totalAttempts: number;

    @ApiProperty({
        description: 'Time spent learning this skill (in minutes)',
        example: 680,
    })
    timeSpent: number;

    @ApiProperty({
        description: 'Improvement rate score (0-100)',
        example: 85.2,
    })
    improvementRate: number;
}

/*
 * Class #203: ProgressMilestoneReportDto
 * Source: reports/dto/training-progress-analytics.dto.ts:336
 * Type: Exported Class
 * Methods: 0
 * Properties: 6
 * Decorators: 6
 * Complexity: 13
 * Size: 980 characters (40 lines)
 */
export class ProgressMilestoneReportDto {
    @ApiProperty({
        description: 'Course name',
        example: 'React Development Fundamentals',
    })
    courseName: string;

    @ApiProperty({
        description: 'Current progress percentage',
        example: 65.0,
    })
    currentProgress: number;

    @ApiProperty({
        description: 'Current module or chapter',
        example: 'Module 5: State Management',
    })
    currentModule: string;

    @ApiProperty({
        description: 'List of achieved milestones',
        type: [String],
        example: ['Getting Started', 'Halfway Point'],
    })
    milestonesAchieved: string[];

    @ApiProperty({
        description: 'Next milestone to achieve',
        example: 'Almost There',
    })
    nextMilestone: string;

    @ApiProperty({
        description: 'Last update timestamp',
        type: 'string',
        format: 'date-time',
        example: '2024-01-15T16:45:00Z',
    })
    lastUpdate: Date;
}

/*
 * Class #204: UserStatsDto
 * Source: reports/dto/user-analytics.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 8
 * Decorators: 16
 * Complexity: 33
 * Size: 1317 characters (59 lines)
 */
export class UserStatsDto {
    @ApiProperty({
        description: 'Total number of tests attempted by the user',
        example: 25,
    })
    @IsNumber()
    totalTestsAttempted: number;

    @ApiProperty({
        description: 'Number of tests completed successfully',
        example: 18,
    })
    @IsNumber()
    testsCompleted: number;

    @ApiProperty({
        description: 'Average score across all completed tests',
        example: 82.5,
    })
    @IsNumber()
    averageScore: number;

    @ApiProperty({
        description: 'User success rate as percentage',
        example: 72.0,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    successRate: number;

    @ApiProperty({
        description: 'Total study time in hours',
        example: 45.5,
    })
    @IsNumber()
    totalStudyTimeHours: number;

    @ApiProperty({
        description: 'Average session duration in minutes',
        example: 35.2,
    })
    @IsNumber()
    averageSessionDurationMinutes: number;

    @ApiProperty({
        description: 'Number of different courses engaged with',
        example: 5,
    })
    @IsNumber()
    coursesEngaged: number;

    @ApiProperty({
        description: 'Current streak of successful tests',
        example: 3,
    })
    @IsNumber()
    currentStreak: number;
}

/*
 * Class #205: UserEngagementDto
 * Source: reports/dto/user-analytics.dto.ts:64
 * Type: Exported Class
 * Methods: 0
 * Properties: 20
 * Decorators: 18
 * Complexity: 42
 * Size: 1408 characters (65 lines)
 */
export class UserEngagementDto {
    @ApiProperty({
        description: 'User ID',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @IsString()
    userId: string;

    @ApiProperty({
        description: 'User full name',
        example: 'John Doe',
    })
    @IsString()
    userName: string;

    @ApiProperty({
        description: 'Total login sessions in the last 30 days',
        example: 18,
    })
    @IsNumber()
    loginSessions: number;

    @ApiProperty({
        description: 'Days active in the last 30 days',
        example: 12,
    })
    @IsNumber()
    activeDays: number;

    @ApiProperty({
        description: 'User engagement score (0-100)',
        example: 78.5,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    engagementScore: number;

    @ApiProperty({
        description: 'Last activity timestamp',
        example: '2024-01-15T14:30:00.000Z',
    })
    @IsDate()
    lastActivity: Date;

    @ApiProperty({
        description: 'Preferred study time (hour of day)',
        example: 14,
        minimum: 0,
        maximum: 23,
    })
    @IsNumber()
    @IsOptional()
    preferredStudyHour?: number;

    @ApiProperty({
        description: 'Most active day of week (0=Sunday, 6=Saturday)',
        example: 2,
        minimum: 0,
        maximum: 6,
    })
    @IsNumber()
    @IsOptional()
    mostActiveDayOfWeek?: number;
}

/*
 * Class #206: UserPerformanceDto
 * Source: reports/dto/user-analytics.dto.ts:130
 * Type: Exported Class
 * Methods: 0
 * Properties: 14
 * Decorators: 16
 * Complexity: 37
 * Size: 1297 characters (55 lines)
 */
export class UserPerformanceDto {
    @ApiProperty({
        description: 'User performance trend (improving/declining/stable)',
        example: 'improving',
        enum: ['improving', 'declining', 'stable'],
    })
    @IsString()
    performanceTrend: string;

    @ApiProperty({
        description: 'Improvement rate percentage over time',
        example: 15.5,
    })
    @IsNumber()
    improvementRate: number;

    @ApiProperty({
        description: 'Strongest subject area',
        example: 'Mathematics',
    })
    @IsString()
    @IsOptional()
    strongestSubject?: string;

    @ApiProperty({
        description: 'Subject area that needs improvement',
        example: 'Physics',
    })
    @IsString()
    @IsOptional()
    weakestSubject?: string;

    @ApiProperty({
        description: 'Average attempts needed before success',
        example: 1.8,
    })
    @IsNumber()
    averageAttemptsToSuccess: number;

    @ApiProperty({
        description: 'First attempt success rate percentage',
        example: 65.5,
    })
    @IsNumber()
    firstAttemptSuccessRate: number;

    @ApiProperty({
        description: 'Time efficiency score (0-100)',
        example: 82.0,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    timeEfficiencyScore: number;
}

/*
 * Class #207: UserAnalyticsResponseDto
 * Source: reports/dto/user-analytics.dto.ts:186
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 5
 * Complexity: 11
 * Size: 743 characters (31 lines)
 */
export class UserAnalyticsResponseDto {
    @ApiProperty({
        description: 'User basic statistics',
        type: UserStatsDto,
    })
    stats: UserStatsDto;

    @ApiProperty({
        description: 'User engagement metrics',
        type: UserEngagementDto,
    })
    engagement: UserEngagementDto;

    @ApiProperty({
        description: 'User performance insights',
        type: UserPerformanceDto,
    })
    performance: UserPerformanceDto;

    @ApiProperty({
        description: 'Timestamp when the report was generated',
        example: '2024-01-15T10:30:45.123Z',
    })
    generatedAt: Date;

    @ApiProperty({
        description: 'Whether this data is from cache',
        example: true,
    })
    cached: boolean;
}

/*
 * Class #208: GlobalUserStatsDto
 * Source: reports/dto/user-analytics.dto.ts:218
 * Type: Exported Class
 * Methods: 0
 * Properties: 9
 * Decorators: 14
 * Complexity: 30
 * Size: 1125 characters (50 lines)
 */
export class GlobalUserStatsDto {
    @ApiProperty({
        description: 'Total number of registered users',
        example: 1250,
    })
    @IsNumber()
    totalUsers: number;

    @ApiProperty({
        description: 'Active users in the last 24 hours',
        example: 85,
    })
    @IsNumber()
    dailyActiveUsers: number;

    @ApiProperty({
        description: 'Active users in the last 7 days',
        example: 320,
    })
    @IsNumber()
    weeklyActiveUsers: number;

    @ApiProperty({
        description: 'Active users in the last 30 days',
        example: 750,
    })
    @IsNumber()
    monthlyActiveUsers: number;

    @ApiProperty({
        description: 'New user registrations in the last 7 days',
        example: 45,
    })
    @IsNumber()
    newUsersThisWeek: number;

    @ApiProperty({
        description: 'Average session duration across all users (minutes)',
        example: 42.3,
    })
    @IsNumber()
    averageSessionDuration: number;

    @ApiProperty({
        description: 'User retention rate percentage',
        example: 68.5,
    })
    @IsNumber()
    retentionRate: number;
}

/*
 * Class #209: CourseEnrollmentTrendDto
 * Source: reports/reports.controller.ts:60
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 0
 * Complexity: 1
 * Size: 146 characters (6 lines)
 */
export class CourseEnrollmentTrendDto {
    date: string;
    newEnrollments: number;
    cumulativeEnrollments: number;
    growthRate: number;
}

/*
 * Class #210: CoursePopularityRankingDto
 * Source: reports/reports.controller.ts:67
 * Type: Exported Class
 * Methods: 0
 * Properties: 7
 * Decorators: 0
 * Complexity: 1
 * Size: 211 characters (9 lines)
 */
export class CoursePopularityRankingDto {
    rank: number;
    courseId: number;
    title: string;
    enrollments: number;
    totalAttempts: number;
    popularityScore: number;
    trendDirection: string;
}

/*
 * Class #211: UserRegistrationTrendDto
 * Source: reports/reports.controller.ts:77
 * Type: Exported Class
 * Methods: 0
 * Properties: 2
 * Decorators: 0
 * Complexity: 1
 * Size: 89 characters (4 lines)
 */
export class UserRegistrationTrendDto {
    date: string;
    newRegistrations: number;
}

/*
 * Class #212: TestAttemptTrendDto
 * Source: reports/reports.controller.ts:82
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 0
 * Complexity: 1
 * Size: 99 characters (5 lines)
 */
export class TestAttemptTrendDto {
    date: string;
    attempts: number;
    completed: number;
}

/*
 * Class #213: ReportsController
 * Source: reports/reports.controller.ts:99
 * Type: Exported Class
 * Methods: 37
 * Properties: 1134
 * Decorators: 128
 * Complexity: 520
 * Size: 89897 characters (2380 lines)
 */
export class ReportsController {
    private readonly logger = new Logger(ReportsController.name);

    constructor(
        private readonly courseReportsService: CourseReportsService,
        private readonly userReportsService: UserReportsService,
        private readonly testReportsService: TestReportsService,
        private readonly resultsReportsService: ResultsReportsService,
        private readonly leaderboardReportsService: LeaderboardReportsService,
        private readonly trainingProgressReportsService: TrainingProgressReportsService,
    ) {}

    @Get('courses/:courseId/analytics')
    @ApiOperation({
        summary: '📈 Comprehensive Course Analytics',
        description: `
      **Retrieves detailed analytics for a specific course with caching optimization**
      
      This endpoint provides comprehensive course analytics including:
      - Student enrollment statistics and trends
      - Course completion rates and performance metrics
      - Time-based analytics and engagement patterns
      - Quality insights and improvement recommendations
      
      **Analytics Features:**
      - Real-time data aggregation from multiple sources
      - Intelligent caching for performance optimization
      - Historical trend analysis and projections
      - Cross-course comparison metrics
      
      **Data Sources:**
      - Course enrollment records
      - Test attempt statistics
      - Student progress tracking
      - Performance evaluation results
      
      **Use Cases:**
      - Course performance monitoring
      - Educational content optimization
      - Student engagement analysis
      - Instructor dashboard displays
    `,
        operationId: 'getCourseAnalytics',
    })
    @ApiParam({
        name: 'courseId',
        description: 'Unique identifier of the target course for analytics',
        type: 'integer',
        example: 1,
        required: true,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course analytics retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success indicator',
                },
                message: {
                    type: 'string',
                    example: 'Course analytics retrieved successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    $ref: '#/components/schemas/CourseAnalyticsResponseDto',
                    description: 'Comprehensive course analytics data',
                },
                meta: {
                    type: 'object',
                    properties: {
                        timestamp: {
                            type: 'string',
                            example: '2024-01-15T10:30:00Z',
                            description: 'Response generation timestamp',
                        },
                        cached: {
                            type: 'boolean',
                            example: false,
                            description:
                                'Indicates if data was served from cache',
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course not found or inaccessible',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: false },
                message: { type: 'string', example: 'Course not found' },
                data: { type: 'null' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid course ID format or analytics parameters',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    example: [
                        'Course ID must be a positive integer',
                        'Invalid date range parameters',
                    ],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description:
            '🔒 Forbidden - Insufficient permissions for course analytics',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 403 },
                message: {
                    type: 'string',
                    example: 'Insufficient permissions',
                },
                error: { type: 'string', example: 'Forbidden' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description: '🔥 Internal server error during analytics computation',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: { type: 'string', example: 'Internal server error' },
                error: { type: 'string', example: 'Internal Server Error' },
            },
        },
    })
    async getCourseAnalytics(
        @Param('courseId', ParseIntPipe) courseId: number,
        @OrgBranchScope() scope: OrgBranchScope,
        @Req() req: AuthenticatedRequest,
    ): Promise<StandardApiResponse<CourseAnalyticsResponseDto>> {
        try {
            this.logger.log(
                `Retrieving course analytics for course: ${courseId}`,
            );

            const analytics =
                await this.courseReportsService.getCourseAnalytics(
                    courseId,
                    scope,
                    req.user.id,
                );

            this.logger.log(
                `Course analytics retrieved successfully for course: ${courseId}`,
            );

            return {
                success: true,
                message: 'Course analytics retrieved successfully',
                data: analytics,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                `Error retrieving course analytics for course ${courseId}:`,
                error,
            );
            throw error;
        }
    }

    // Course enrollment trends endpoint
    @Get('courses/:courseId/enrollment')
    @ApiOperation({
        summary: '📊 Course Enrollment Trends Analysis',
        description: `
      **Analyzes enrollment trends and patterns for a specific course**
      
      This endpoint provides detailed enrollment analytics including:
      - Time-series enrollment data with trend analysis
      - Peak enrollment periods and seasonal patterns
      - Student acquisition metrics and conversion rates
      - Comparative enrollment performance
      
      **Trend Analysis Features:**
      - Daily, weekly, and monthly enrollment breakdowns
      - Growth rate calculations and projections
      - Enrollment source tracking and attribution
      - Demographic enrollment patterns
      
      **Business Intelligence:**
      - Marketing campaign effectiveness measurement
      - Optimal course launch timing recommendations
      - Capacity planning and resource allocation
      - Competitive analysis against similar courses
      
      **Use Cases:**
      - Marketing performance evaluation
      - Course scheduling optimization
      - Resource planning and allocation
      - Student acquisition strategy development
    `,
        operationId: 'getCourseEnrollmentTrends',
    })
    @ApiParam({
        name: 'courseId',
        description: 'Unique identifier of the course for enrollment analysis',
        type: 'integer',
        example: 1,
        required: true,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course enrollment trends retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success status',
                },
                message: {
                    type: 'string',
                    example: 'Course enrollment trends retrieved successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'array',
                    description: 'Time-series enrollment data',
                    items: {
                        type: 'object',
                        properties: {
                            date: {
                                type: 'string',
                                format: 'date',
                                example: '2024-01-15',
                                description: 'Date of enrollment record',
                            },
                            newEnrollments: {
                                type: 'number',
                                example: 12,
                                description:
                                    'Number of new enrollments on this date',
                            },
                            cumulativeEnrollments: {
                                type: 'number',
                                example: 150,
                                description:
                                    'Total enrollments up to this date',
                            },
                            growthRate: {
                                type: 'number',
                                example: 8.7,
                                description:
                                    'Percentage growth rate from previous period',
                            },
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course not found or no enrollment data available',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: false },
                message: { type: 'string', example: 'Course not found' },
                data: { type: 'null' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid course ID or enrollment query parameters',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    example: [
                        'Course ID must be a positive integer',
                        'Invalid date range for enrollment analysis',
                    ],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
                error: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description:
            '🔥 Internal server error during enrollment data retrieval',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: { type: 'string', example: 'Internal server error' },
                error: { type: 'string', example: 'Internal Server Error' },
            },
        },
    })
    async getCourseEnrollment(
        @Param('courseId', ParseIntPipe) courseId: number,
    ): Promise<StandardApiResponse<CourseEnrollmentTrendDto[]>> {
        try {
            this.logger.log(
                `Retrieving enrollment trends for course: ${courseId}`,
            );

            const enrollmentData =
                await this.courseReportsService.getCourseEnrollmentStats(
                    courseId,
                );

            this.logger.log(
                `Enrollment trends retrieved successfully for course: ${courseId}`,
            );

            return {
                success: true,
                message: 'Course enrollment trends retrieved successfully',
                data: enrollmentData,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                `Error retrieving enrollment trends for course ${courseId}:`,
                error,
            );
            throw error;
        }
    }

    // Global course popularity rankings
    @Get('courses/popularity-ranking')
    @ApiOperation({
        summary: '🏆 Global Course Popularity Rankings',
        description: `
      **Generates comprehensive global course popularity rankings**
      
      This endpoint provides system-wide course popularity analysis including:
      - Top-performing courses ranked by multiple metrics
      - Engagement and enrollment-based scoring
      - Cross-category popularity comparisons
      - Trending courses and emerging favorites
      
      **Ranking Methodology:**
      - Multi-factor scoring algorithm combining enrollment, engagement, and completion
      - Time-weighted analysis favoring recent activity
      - Quality metrics including student satisfaction and outcomes
      - Category normalization for fair cross-domain comparison
      
      **Metrics Included:**
      - Total enrollments and active students
      - Course completion rates and time investment
      - Student feedback scores and recommendations
      - Test performance and learning outcomes
      
      **Use Cases:**
      - Homepage featured course selection
      - Marketing priority determination
      - Curriculum development insights
      - Competitive analysis and benchmarking
    `,
        operationId: 'getGlobalCoursePopularityRanking',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description:
            '✅ Global course popularity rankings retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success status',
                },
                message: {
                    type: 'string',
                    example:
                        'Course popularity rankings retrieved successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'array',
                    description: 'Ranked list of popular courses',
                    items: {
                        type: 'object',
                        properties: {
                            rank: {
                                type: 'number',
                                example: 1,
                                description: 'Current popularity rank',
                            },
                            courseId: {
                                type: 'number',
                                example: 1,
                                description: 'Unique course identifier',
                            },
                            title: {
                                type: 'string',
                                example: 'Introduction to Computer Science',
                                description: 'Course title',
                            },
                            enrollments: {
                                type: 'number',
                                example: 150,
                                description: 'Total enrollments count',
                            },
                            totalAttempts: {
                                type: 'number',
                                example: 450,
                                description:
                                    'Total test attempts across course',
                            },
                            popularityScore: {
                                type: 'number',
                                example: 92.5,
                                description:
                                    'Calculated popularity score (0-100)',
                            },
                            trendDirection: {
                                type: 'string',
                                example: 'up',
                                description:
                                    'Trend direction: up, down, stable',
                            },
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async getCoursesPopularityRanking(): Promise<
        StandardApiResponse<CoursePopularityRankingDto[]>
    > {
        try {
            this.logger.log('Retrieving global course popularity rankings');

            const rankings =
                await this.courseReportsService.getAllCoursesPopularityRanking();

            this.logger.log(
                'Course popularity rankings retrieved successfully',
            );

            return {
                success: true,
                message: 'Course popularity rankings retrieved successfully',
                data: rankings,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                'Error retrieving course popularity rankings:',
                error,
            );
            throw error;
        }
    }

    // User analytics endpoints
    @Get('users/:userId/analytics')
    @ApiOperation({
        summary: '👤 Comprehensive User Analytics Dashboard',
        description: `
      **Provides detailed analytics for individual user performance and engagement**
      
      This endpoint delivers comprehensive user analytics including:
      - Learning progress tracking and milestone achievements
      - Test performance analysis and improvement trends
      - Engagement patterns and learning behavior insights
      - Personalized recommendations and learning paths
      
      **Analytics Dimensions:**
      - Academic performance metrics and scoring trends
      - Time investment patterns and learning efficiency
      - Course enrollment history and completion tracking
      - Social learning indicators and collaboration metrics
      
      **Intelligence Features:**
      - Predictive learning outcome modeling
      - Personalized difficulty adjustment recommendations
      - Learning style identification and adaptation
      - Achievement recognition and motivation tracking
      
      **Use Cases:**
      - Student performance monitoring and support
      - Personalized learning experience optimization
      - Academic intervention and success planning
      - Progress reporting to instructors and administrators
    `,
        operationId: 'getUserAnalytics',
    })
    @ApiParam({
        name: 'userId',
        description: 'Unique identifier of the user for analytics generation',
        type: 'string',
        example: '123e4567-e89b-12d3-a456-426614174000',
        required: true,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ User analytics retrieved successfully',
        type: UserAnalyticsResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ User not found or analytics unavailable',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: false },
                message: { type: 'string', example: 'User not found' },
                data: { type: 'null' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid user ID format',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    example: ['User ID must be a valid UUID format'],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
                error: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description:
            '🔥 Internal server error during user analytics computation',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: { type: 'string', example: 'Internal server error' },
                error: { type: 'string', example: 'Internal Server Error' },
            },
        },
    })
    async getUserAnalytics(
        @Param('userId', ParseUUIDPipe) userId: string,
        @OrgBranchScope() scope: OrgBranchScope,
        @Req() req: AuthenticatedRequest,
    ): Promise<StandardApiResponse<UserAnalyticsResponseDto>> {
        try {
            this.logger.log(`Retrieving user analytics for user: ${userId}`);

            const analytics =
                await this.userReportsService.getUserAnalytics(userId);

            this.logger.log(
                `User analytics retrieved successfully for user: ${userId}`,
            );

            return {
                success: true,
                message: 'User analytics retrieved successfully',
                data: analytics,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                `Error retrieving user analytics for user ${userId}:`,
                error,
            );
            throw error;
        }
    }

    @Get('users/global-stats')
    @ApiOperation({
        summary: '🌐 Global User Statistics Overview',
        description: `
      **Provides system-wide user engagement and activity statistics**
      
      This endpoint delivers comprehensive global user analytics including:
      - Platform-wide user activity metrics and trends
      - Registration and retention analysis
      - Engagement pattern identification across user segments
      - Performance benchmarks and comparative analytics
      
      **Global Metrics:**
      - Total active users and registration trends
      - User engagement distribution and activity patterns
      - Learning outcome statistics and success rates
      - Platform utilization metrics and peak usage analysis
      
      **Segmentation Analysis:**
      - User cohort performance comparisons
      - Geographic and demographic trend analysis
      - Course preference patterns and learning pathways
      - Retention and churn analysis with predictive insights
      
      **Use Cases:**
      - Executive dashboard reporting
      - Platform performance monitoring
      - User experience optimization
      - Strategic planning and growth analysis
    `,
        operationId: 'getGlobalUserStatistics',
    })
    @ApiOkResponse({
        description: '✅ Global user statistics retrieved successfully',
        type: GlobalUserStatsDto,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async getGlobalUserStats(): Promise<
        StandardApiResponse<GlobalUserStatsDto>
    > {
        try {
            this.logger.log('Retrieving global user statistics');

            const stats = await this.userReportsService.getGlobalUserStats();

            this.logger.log('Global user statistics retrieved successfully');

            return {
                success: true,
                message: 'Global user statistics retrieved successfully',
                data: stats,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                'Error retrieving global user statistics:',
                error,
            );
            throw error;
        }
    }

    @Get('users/registration-trends')
    @ApiOperation({
        summary: '📈 User Registration Trends Analysis',
        description: `
      **Analyzes user registration patterns and growth trends over time**
      
      This endpoint provides detailed registration analytics including:
      - Time-series registration data with growth analysis
      - Seasonal patterns and peak registration periods
      - User acquisition source tracking and attribution
      - Conversion funnel analysis and optimization insights
      
      **Trend Analysis Features:**
      - Daily, weekly, and monthly registration breakdowns
      - Growth rate calculations and future projections
      - Cohort analysis and user lifecycle tracking
      - Marketing campaign effectiveness measurement
      
      **Business Intelligence:**
      - User acquisition cost analysis and optimization
      - Retention correlation with registration timing
      - Platform growth trajectory modeling
      - Competitive benchmarking and market analysis
      
      **Use Cases:**
      - Marketing strategy optimization
      - Growth planning and resource allocation
      - User acquisition funnel improvement
      - Platform scalability planning
    `,
        operationId: 'getUserRegistrationTrends',
    })
    @ApiOkResponse({
        description: '✅ User registration trends retrieved successfully',
        schema: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    date: {
                        type: 'string',
                        format: 'date',
                        example: '2024-01-15',
                    },
                    newRegistrations: {
                        type: 'number',
                        example: 5,
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async getUserRegistrationTrends(): Promise<
        StandardApiResponse<UserRegistrationTrendDto[]>
    > {
        try {
            this.logger.log('Retrieving user registration trends');

            const trends =
                await this.userReportsService.getUserRegistrationTrends();

            this.logger.log('User registration trends retrieved successfully');

            return {
                success: true,
                message: 'User registration trends retrieved successfully',
                data: trends,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                'Error retrieving user registration trends:',
                error,
            );
            throw error;
        }
    }

    // Test analytics endpoints
    @Get('tests/:testId/analytics')
    @ApiOperation({
        summary: '🎯 Comprehensive Test Analytics Dashboard',
        description: `
      **Provides detailed analytics for individual test performance and quality metrics**
      
      This endpoint delivers comprehensive test analytics including:
      - Test performance statistics and scoring distributions
      - Question-level analysis and difficulty assessment
      - Completion patterns and timing analytics
      - Quality metrics and improvement recommendations
      
      **Analytics Dimensions:**
      - Student performance metrics and pass/fail rates
      - Question effectiveness and discrimination analysis
      - Time allocation patterns and efficiency metrics
      - Comparative performance across user segments
      
      **Quality Assessment:**
      - Statistical reliability and validity measures
      - Item difficulty and discrimination indices
      - Test fairness and bias detection
      - Content effectiveness recommendations
      
      **Use Cases:**
      - Test quality assurance and improvement
      - Educational content optimization
      - Student performance evaluation
      - Instructor feedback and course enhancement
    `,
        operationId: 'getTestAnalytics',
    })
    @ApiParam({
        name: 'testId',
        description: 'Unique identifier of the test for analytics generation',
        type: 'integer',
        example: 1,
        required: true,
    })
    @ApiOkResponse({
        description: '✅ Test analytics retrieved successfully',
        type: TestAnalyticsResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Test not found or analytics unavailable',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: false },
                message: { type: 'string', example: 'Test not found' },
                data: { type: 'null' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async getTestAnalytics(
        @Param('testId', ParseIntPipe) testId: number,
        @OrgBranchScope() scope: OrgBranchScope,
        @Req() req: AuthenticatedRequest,
    ): Promise<StandardApiResponse<TestAnalyticsResponseDto>> {
        try {
            this.logger.log(`Retrieving test analytics for test: ${testId}`);

            const analytics =
                await this.testReportsService.getTestAnalytics(testId);

            this.logger.log(
                `Test analytics retrieved successfully for test: ${testId}`,
            );

            return {
                success: true,
                message: 'Test analytics retrieved successfully',
                data: analytics,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                `Error retrieving test analytics for test ${testId}:`,
                error,
            );
            throw error;
        }
    }

    @Get('tests/global-stats')
    @ApiOperation({
        summary: '🌍 Global Test Statistics Overview',
        description:
            'Retrieve system-wide test statistics including completion rates, popular test types, and peak testing hours.',
        operationId: 'getGlobalTestStatistics',
    })
    @ApiOkResponse({
        description: '✅ Global test statistics retrieved successfully',
        type: GlobalTestStatsDto,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async getGlobalTestStats(): Promise<
        StandardApiResponse<GlobalTestStatsDto>
    > {
        try {
            this.logger.log('Retrieving global test statistics');

            const stats = await this.testReportsService.getGlobalTestStats();

            this.logger.log('Global test statistics retrieved successfully');

            return {
                success: true,
                message: 'Global test statistics retrieved successfully',
                data: stats,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                'Error retrieving global test statistics:',
                error,
            );
            throw error;
        }
    }

    @Get('tests/:testId/attempt-trends')
    @ApiOperation({
        summary: '📊 Test Attempt Trends Analysis',
        description:
            'Retrieve test attempt trends over the last 30 days for a specific test.',
        operationId: 'getTestAttemptTrends',
    })
    @ApiParam({
        name: 'testId',
        description: 'Unique identifier of the test',
        type: 'integer',
        example: 1,
    })
    @ApiOkResponse({
        description: '✅ Test attempt trends retrieved successfully',
        schema: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    date: {
                        type: 'string',
                        format: 'date',
                        example: '2024-01-15',
                    },
                    attempts: {
                        type: 'number',
                        example: 25,
                    },
                    completed: {
                        type: 'number',
                        example: 18,
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async getTestAttemptTrends(
        @Param('testId', ParseIntPipe) testId: number,
    ): Promise<StandardApiResponse<TestAttemptTrendDto[]>> {
        try {
            this.logger.log(`Retrieving attempt trends for test: ${testId}`);

            const trends =
                await this.testReportsService.getTestAttemptTrends(testId);

            this.logger.log(
                `Test attempt trends retrieved successfully for test: ${testId}`,
            );

            return {
                success: true,
                message: 'Test attempt trends retrieved successfully',
                data: trends,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                `Error retrieving test attempt trends for test ${testId}:`,
                error,
            );
            throw error;
        }
    }

    // Results Reports Endpoints
    @Get('results/:userId/analytics')
    @ApiOperation({
        summary: '📊 Comprehensive Results Analytics for User',
        description: `
      **Provides detailed results analytics for a specific user with comprehensive insights**
      
      This endpoint delivers in-depth user performance analytics including:
      - Individual test results analysis and performance trends
      - Score distribution patterns and percentile rankings
      - Learning progress tracking and achievement milestones
      - Comparative performance analysis across courses and timeframes
      
      **Analytics Dimensions:**
      - Academic performance metrics and scoring patterns
      - Test completion statistics and timing analysis
      - Subject-wise performance breakdown and skill assessment
      - Historical performance trends and improvement tracking
      
      **Quality Assessment Features:**
      - Performance consistency analysis and variance metrics
      - Learning velocity calculations and progress predictions
      - Strengths and weaknesses identification
      - Personalized improvement recommendations
      
      **Business Intelligence:**
      - Student engagement measurement and activity patterns
      - Risk assessment for academic intervention needs
      - Achievement recognition and milestone tracking
      - Comparative benchmarking against peer groups
      
      **Use Cases:**
      - Student performance dashboard and progress tracking
      - Academic counseling and intervention planning
      - Personalized learning path optimization
      - Parent/guardian progress reporting
      - Instructor student assessment and support
    `,
        operationId: 'getUserResultsAnalytics',
    })
    @ApiParam({
        name: 'userId',
        description:
            'Unique UUID identifier of the user for comprehensive results analysis',
        type: 'string',
        example: '123e4567-e89b-12d3-a456-426614174000',
        required: true,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ User results analytics retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success indicator',
                },
                message: {
                    type: 'string',
                    example: 'User results analytics retrieved successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'object',
                    description: 'Comprehensive user results analytics',
                    properties: {
                        userId: {
                            type: 'string',
                            example: '123e4567-e89b-12d3-a456-426614174000',
                            description: 'User unique identifier',
                        },
                        totalAttempts: {
                            type: 'number',
                            example: 45,
                            description:
                                'Total number of test attempts by user',
                        },
                        averageScore: {
                            type: 'number',
                            example: 87.5,
                            description:
                                'Overall average score across all attempts',
                        },
                        bestScore: {
                            type: 'number',
                            example: 98.5,
                            description: 'Highest score achieved by user',
                        },
                        recentPerformance: {
                            type: 'object',
                            properties: {
                                last30Days: {
                                    type: 'number',
                                    example: 89.2,
                                    description:
                                        'Average score in last 30 days',
                                },
                                improvementTrend: {
                                    type: 'string',
                                    example: 'improving',
                                    description:
                                        'Performance trend: improving, declining, stable',
                                },
                            },
                        },
                        subjectBreakdown: {
                            type: 'array',
                            items: {
                                type: 'object',
                                properties: {
                                    subject: {
                                        type: 'string',
                                        example: 'Mathematics',
                                    },
                                    averageScore: {
                                        type: 'number',
                                        example: 92.3,
                                    },
                                    attempts: {
                                        type: 'number',
                                        example: 12,
                                    },
                                },
                            },
                        },
                    },
                },
                meta: {
                    type: 'object',
                    properties: {
                        timestamp: {
                            type: 'string',
                            example: '2024-01-15T10:30:00Z',
                            description: 'Analytics generation timestamp',
                        },
                        dataFreshness: {
                            type: 'string',
                            example: 'real-time',
                            description: 'Data freshness indicator',
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ User not found or no results data available',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: false },
                message: {
                    type: 'string',
                    example: 'User not found or no test results available',
                },
                data: { type: 'null' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description:
            '🔒 Forbidden - Insufficient permissions to access user results',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 403 },
                message: {
                    type: 'string',
                    example: 'Insufficient permissions to access user results',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async getUserResultsAnalytics(
        @Param('userId', ParseUUIDPipe) userId: string,
    ): Promise<StandardApiResponse<ResultsAnalyticsReportDto>> {
        try {
            this.logger.log(`Retrieving results analytics for user: ${userId}`);

            const analytics =
                await this.resultsReportsService.getResultsAnalytics(userId);

            this.logger.log(
                `Results analytics retrieved successfully for user: ${userId}`,
            );

            return {
                success: true,
                message: 'User results analytics retrieved successfully',
                data: analytics,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                `Error retrieving results analytics for user ${userId}:`,
                error,
            );
            throw error;
        }
    }

    @Get('results/global-stats')
    @ApiOperation({
        summary: '🌍 Global Results Statistics Overview',
        description: `
      **Provides comprehensive system-wide results statistics and analytics**
      
      This endpoint delivers platform-wide performance analytics including:
      - Global test performance metrics and distribution analysis
      - System-wide pass rates and achievement statistics
      - Cross-course performance comparisons and benchmarks
      - Platform usage patterns and engagement insights
      
      **Global Performance Metrics:**
      - Total test attempts across all courses and users
      - Average scores and performance distribution curves
      - Pass/fail rates with statistical significance analysis
      - Top performing courses and difficulty assessments
      
      **Comparative Analytics:**
      - Course performance rankings and popularity metrics
      - Subject-wise performance analysis and trends
      - User engagement patterns and activity heatmaps
      - Geographic and demographic performance insights
      
      **Quality Intelligence:**
      - Test difficulty calibration and fairness analysis
      - Question effectiveness and discrimination metrics
      - Platform reliability and user satisfaction indicators
      - Content optimization recommendations
      
      **Business Intelligence Applications:**
      - Executive dashboard reporting and KPI tracking
      - Educational content effectiveness measurement
      - Platform scaling and capacity planning insights
      - Marketing and user acquisition strategy support
      
      **Use Cases:**
      - Administrative oversight and performance monitoring
      - Educational research and effectiveness studies
      - Platform optimization and improvement planning
      - Stakeholder reporting and transparency initiatives
      - Competitive analysis and market positioning
    `,
        operationId: 'getGlobalResultsStatistics',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Global results statistics retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success indicator',
                },
                message: {
                    type: 'string',
                    example: 'Global results statistics retrieved successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'object',
                    description: 'Comprehensive global results statistics',
                    properties: {
                        totalAttempts: {
                            type: 'number',
                            example: 15420,
                            description: 'Total test attempts across platform',
                        },
                        averageScore: {
                            type: 'number',
                            example: 78.4,
                            description: 'Platform-wide average score',
                        },
                        passRate: {
                            type: 'number',
                            example: 72.8,
                            description: 'Global pass rate percentage',
                        },
                        topPerformingCourses: {
                            type: 'array',
                            description: 'Highest performing courses',
                            items: {
                                type: 'object',
                                properties: {
                                    courseId: { type: 'number', example: 1 },
                                    title: {
                                        type: 'string',
                                        example: 'Advanced Mathematics',
                                    },
                                    averageScore: {
                                        type: 'number',
                                        example: 89.2,
                                    },
                                    totalAttempts: {
                                        type: 'number',
                                        example: 234,
                                    },
                                },
                            },
                        },
                        performanceDistribution: {
                            type: 'object',
                            properties: {
                                excellent: {
                                    type: 'number',
                                    example: 25.3,
                                    description: 'Percentage scoring 90+',
                                },
                                good: {
                                    type: 'number',
                                    example: 31.7,
                                    description: 'Percentage scoring 80-89',
                                },
                                average: {
                                    type: 'number',
                                    example: 28.2,
                                    description: 'Percentage scoring 70-79',
                                },
                                needsImprovement: {
                                    type: 'number',
                                    example: 14.8,
                                    description: 'Percentage scoring below 70',
                                },
                            },
                        },
                        trendsAnalysis: {
                            type: 'object',
                            properties: {
                                monthlyGrowth: {
                                    type: 'number',
                                    example: 12.5,
                                    description:
                                        'Monthly growth in test attempts (%)',
                                },
                                performanceImprovement: {
                                    type: 'number',
                                    example: 3.2,
                                    description:
                                        'Average score improvement over last quarter',
                                },
                            },
                        },
                    },
                },
                meta: {
                    type: 'object',
                    properties: {
                        timestamp: {
                            type: 'string',
                            example: '2024-01-15T10:30:00Z',
                            description: 'Statistics generation timestamp',
                        },
                        dataRange: {
                            type: 'string',
                            example: 'all-time',
                            description: 'Data range for statistics',
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.INTERNAL_SERVER_ERROR,
        description: '🔥 Internal Server Error - System data processing failed',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 500 },
                message: {
                    type: 'string',
                    example:
                        'Unable to process global statistics due to system error',
                },
                error: { type: 'string', example: 'Internal Server Error' },
                timestamp: { type: 'string', example: '2024-01-15T10:30:00Z' },
                path: {
                    type: 'string',
                    example: '/api/reports/results/global-stats',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: {
                    type: 'string',
                    example:
                        'Unauthorized access. Please provide a valid JWT token.',
                },
                error: { type: 'string', example: 'Unauthorized' },
                timestamp: { type: 'string', example: '2024-01-15T10:30:00Z' },
                path: {
                    type: 'string',
                    example: '/api/reports/results/global-stats',
                },
            },
        },
    })
    async getGlobalResultsStats(): Promise<
        StandardApiResponse<GlobalResultsStatsReportDto>
    > {
        try {
            this.logger.log('Retrieving global results statistics');

            const stats =
                await this.resultsReportsService.getGlobalResultsStats();

            this.logger.log('Global results statistics retrieved successfully');

            return {
                success: true,
                message: 'Global results statistics retrieved successfully',
                data: stats,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                'Error retrieving global results statistics:',
                error,
            );
            throw error;
        }
    }

    @Get('results/performance-trends')
    @ApiOperation({
        summary: '📈 Performance Trends Analysis Dashboard',
        description: `
      **Analyzes performance trends over time with advanced filtering capabilities**
      
      This endpoint provides comprehensive performance trend analysis including:
      - Time-series performance data with trend identification
      - User and course-specific performance tracking
      - Comparative analysis across different time periods
      - Predictive performance modeling and forecasting
      
      **Trend Analysis Features:**
      - Daily, weekly, and monthly performance aggregations
      - Moving averages and trend line calculations
      - Seasonal pattern identification and analysis
      - Performance variance and consistency metrics
      
      **Filtering Capabilities:**
      - **User-specific**: Individual user performance tracking
      - **Course-specific**: Course performance evolution
      - **Date ranges**: Custom time period analysis
      - **Performance segments**: High/medium/low performer trends
      
      **Advanced Analytics:**
      - Statistical significance testing for trend changes
      - Correlation analysis between different performance metrics
      - Outlier detection and anomaly identification
      - Performance prediction and forecasting models
      
      **Business Applications:**
      - Learning effectiveness measurement over time
      - Course content optimization based on performance trends
      - Student intervention timing and strategy development
      - Platform improvement impact assessment
      
      **Use Cases:**
      - Educational research and trend analysis
      - Student progress monitoring and early warning systems
      - Course effectiveness evaluation and improvement
      - Platform performance optimization
      - Academic intervention planning and timing
    `,
        operationId: 'getPerformanceTrends',
    })
    @ApiQuery({
        name: 'userId',
        required: false,
        description:
            'Filter trends by specific user UUID for personalized analysis',
        example: '123e4567-e89b-12d3-a456-426614174000',
        type: 'string',
    })
    @ApiQuery({
        name: 'courseId',
        required: false,
        description:
            'Filter trends by specific course ID for course-level analysis',
        example: 1,
        type: 'number',
    })
    @ApiQuery({
        name: 'startDate',
        required: false,
        description: 'Start date for trend analysis (ISO 8601 format)',
        example: '2024-01-01',
        type: 'string',
    })
    @ApiQuery({
        name: 'endDate',
        required: false,
        description: 'End date for trend analysis (ISO 8601 format)',
        example: '2024-12-31',
        type: 'string',
    })
    @ApiQuery({
        name: 'granularity',
        required: false,
        description: 'Data aggregation granularity',
        enum: ['daily', 'weekly', 'monthly'],
        example: 'weekly',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Performance trends retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success indicator',
                },
                message: {
                    type: 'string',
                    example: 'Performance trends retrieved successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'object',
                    description: 'Performance trends analysis data',
                    properties: {
                        trends: {
                            type: 'array',
                            description: 'Time-series performance data points',
                            items: {
                                type: 'object',
                                properties: {
                                    date: {
                                        type: 'string',
                                        format: 'date',
                                        example: '2024-01-15',
                                        description: 'Data point date',
                                    },
                                    averageScore: {
                                        type: 'number',
                                        example: 84.7,
                                        description:
                                            'Average score for this period',
                                    },
                                    attempts: {
                                        type: 'number',
                                        example: 23,
                                        description:
                                            'Number of attempts in period',
                                    },
                                    passRate: {
                                        type: 'number',
                                        example: 78.3,
                                        description:
                                            'Pass rate percentage for period',
                                    },
                                    trendDirection: {
                                        type: 'string',
                                        example: 'improving',
                                        description:
                                            'Trend direction: improving, declining, stable',
                                    },
                                },
                            },
                        },
                        summary: {
                            type: 'object',
                            properties: {
                                overallTrend: {
                                    type: 'string',
                                    example: 'improving',
                                    description:
                                        'Overall trend across entire period',
                                },
                                averageImprovement: {
                                    type: 'number',
                                    example: 5.2,
                                    description:
                                        'Average improvement percentage',
                                },
                                bestPeriod: {
                                    type: 'string',
                                    example: '2024-01-22',
                                    description: 'Date of best performance',
                                },
                                consistency: {
                                    type: 'number',
                                    example: 0.85,
                                    description:
                                        'Performance consistency score (0-1)',
                                },
                            },
                        },
                    },
                },
                meta: {
                    type: 'object',
                    properties: {
                        timestamp: {
                            type: 'string',
                            example: '2024-01-15T10:30:00Z',
                            description: 'Analysis generation timestamp',
                        },
                        dataPoints: {
                            type: 'number',
                            example: 52,
                            description: 'Number of data points in analysis',
                        },
                        filters: {
                            type: 'object',
                            description: 'Applied filters for this analysis',
                        },
                    },
                },
            },
        },
    })
    async getPerformanceTrends(
        @Query('userId') userId?: string,
        @Query('courseId') courseId?: number,
    ): Promise<StandardApiResponse<PerformanceTrendReportDto[]>> {
        try {
            this.logger.log(
                `Retrieving performance trends for userId: ${userId}, courseId: ${courseId}`,
            );

            const trends =
                await this.resultsReportsService.getPerformanceTrends(
                    userId,
                    courseId,
                );

            this.logger.log('Performance trends retrieved successfully');

            return {
                success: true,
                message: 'Performance trends retrieved successfully',
                data: trends,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error('Error retrieving performance trends:', error);
            throw error;
        }
    }

    // Leaderboard Reports Endpoints
    @Get('leaderboard/analytics')
    @ApiOperation({
        summary: '🏆 Comprehensive Leaderboard Analytics Dashboard',
        description: `
      **Provides advanced leaderboard analytics with competitive intelligence features**
      
      This endpoint delivers sophisticated competitive analysis including:
      - Multi-dimensional ranking systems and scoring algorithms
      - Competitive performance tracking and achievement recognition
      - Social learning indicators and peer comparison metrics
      - Gamification effectiveness measurement and engagement insights
      
      **Competitive Analytics Features:**
      - Real-time ranking calculations with multiple scoring criteria
      - Historical position tracking and movement analysis
      - Achievement milestone recognition and reward systems
      - Peer group analysis and competitive benchmarking
      
      **Ranking Methodologies:**
      - Score-based rankings with weighted performance metrics
      - Time-based achievements and streak tracking
      - Participation-based scoring and engagement rewards
      - Skill-based competency rankings and proficiency levels
      
      **Social Learning Intelligence:**
      - Collaborative learning pattern identification
      - Peer influence analysis and knowledge sharing metrics
      - Group performance dynamics and team effectiveness
      - Mentorship opportunity identification and matching
      
      **Gamification Insights:**
      - Achievement system effectiveness and engagement correlation
      - Reward mechanism optimization and motivation analysis
      - Competition-driven learning outcome improvements
      - User retention and engagement through competitive elements
      
      **Business Applications:**
      - Student motivation and engagement enhancement
      - Course completion rate improvement through competition
      - Community building and social learning facilitation
      - Platform stickiness and user retention optimization
      
      **Use Cases:**
      - Competitive learning environment creation
      - Student motivation and engagement programs
      - Course completion incentivization strategies
      - Social learning community development
      - Achievement recognition and reward systems
    `,
        operationId: 'getLeaderboardAnalytics',
    })
    @ApiQuery({
        name: 'userId',
        required: false,
        description:
            'Filter analytics by specific user UUID for personalized leaderboard insights',
        example: '123e4567-e89b-12d3-a456-426614174000',
        type: 'string',
    })
    @ApiQuery({
        name: 'courseId',
        required: false,
        description:
            'Filter analytics by specific course ID for course-level competitive analysis',
        example: 1,
        type: 'number',
    })
    @ApiQuery({
        name: 'timeframe',
        required: false,
        description: 'Time period for leaderboard analysis',
        enum: ['daily', 'weekly', 'monthly', 'quarterly', 'all-time'],
        example: 'monthly',
    })
    @ApiQuery({
        name: 'category',
        required: false,
        description: 'Leaderboard category for specialized rankings',
        enum: ['overall', 'recent-performance', 'improvement', 'consistency'],
        example: 'overall',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Leaderboard analytics retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success indicator',
                },
                message: {
                    type: 'string',
                    example: 'Leaderboard analytics retrieved successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'object',
                    description: 'Comprehensive leaderboard analytics',
                    properties: {
                        leaderboard: {
                            type: 'array',
                            description: 'Ranked list of leaderboard entries',
                            items: {
                                type: 'object',
                                properties: {
                                    userId: {
                                        type: 'string',
                                        example:
                                            '123e4567-e89b-12d3-a456-426614174000',
                                        description: 'User unique identifier',
                                    },
                                    rank: {
                                        type: 'number',
                                        example: 1,
                                        description: 'Current leaderboard rank',
                                    },
                                    score: {
                                        type: 'number',
                                        example: 95.2,
                                        description:
                                            'User score on the leaderboard',
                                    },
                                    progress: {
                                        type: 'number',
                                        example: 85.3,
                                        description: 'User progress percentage',
                                    },
                                    streak: {
                                        type: 'number',
                                        example: 12,
                                        description:
                                            'Current streak of consecutive days',
                                    },
                                },
                            },
                        },
                        summary: {
                            type: 'object',
                            properties: {
                                topPerformer: {
                                    type: 'object',
                                    properties: {
                                        userId: {
                                            type: 'string',
                                            example:
                                                '123e4567-e89b-12d3-a456-426614174000',
                                            description:
                                                'User unique identifier',
                                        },
                                        rank: {
                                            type: 'number',
                                            example: 1,
                                            description:
                                                'Current leaderboard rank',
                                        },
                                        score: {
                                            type: 'number',
                                            example: 98.5,
                                            description: 'Top performer score',
                                        },
                                    },
                                },
                                averageScore: {
                                    type: 'number',
                                    example: 87.5,
                                    description:
                                        'Average score across all leaderboard entries',
                                },
                                passRate: {
                                    type: 'number',
                                    example: 75.3,
                                    description:
                                        'Average pass rate across leaderboard entries',
                                },
                            },
                        },
                    },
                },
                meta: {
                    type: 'object',
                    properties: {
                        timestamp: {
                            type: 'string',
                            example: '2024-01-15T10:30:00Z',
                            description: 'Analytics generation timestamp',
                        },
                        dataRange: {
                            type: 'string',
                            example: 'all-time',
                            description: 'Data range for leaderboard analytics',
                        },
                    },
                },
            },
        },
    })
    async getLeaderboardAnalytics(
        @Query('userId') userId?: string,
        @Query('courseId') courseId?: number,
    ): Promise<StandardApiResponse<LeaderboardAnalyticsReportDto>> {
        try {
            this.logger.log(
                `Retrieving leaderboard analytics for userId: ${userId}, courseId: ${courseId}`,
            );

            const analytics =
                await this.leaderboardReportsService.getLeaderboardAnalytics(
                    userId,
                    courseId,
                );

            this.logger.log('Leaderboard analytics retrieved successfully');

            return {
                success: true,
                message: 'Leaderboard analytics retrieved successfully',
                data: analytics,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error('Error retrieving leaderboard analytics:', error);
            throw error;
        }
    }

    @Get('leaderboard/global-stats')
    @ApiOperation({
        summary: '🌍 Global Leaderboard Statistics',
        description:
            'Retrieve system-wide leaderboard statistics including top performers and course activity.',
        operationId: 'getGlobalLeaderboardStatistics',
    })
    @ApiOkResponse({
        description: '✅ Global leaderboard statistics retrieved successfully',
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async getGlobalLeaderboardStats(): Promise<
        StandardApiResponse<GlobalLeaderboardStatsReportDto>
    > {
        try {
            this.logger.log('Retrieving global leaderboard statistics');

            const stats =
                await this.leaderboardReportsService.getGlobalLeaderboardStats();

            this.logger.log(
                'Global leaderboard statistics retrieved successfully',
            );

            return {
                success: true,
                message: 'Global leaderboard statistics retrieved successfully',
                data: stats,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                'Error retrieving global leaderboard statistics:',
                error,
            );
            throw error;
        }
    }

    @Get('leaderboard/top-performers')
    @ApiOperation({
        summary: '🥇 Top Performers Rankings',
        description:
            'Retrieve top performers globally or for a specific course.',
        operationId: 'getTopPerformers',
    })
    @ApiQuery({
        name: 'courseId',
        required: false,
        description: 'Filter by specific course',
    })
    @ApiQuery({
        name: 'limit',
        required: false,
        description: 'Number of top performers to return (default: 10)',
    })
    @ApiOkResponse({
        description: '✅ Top performers retrieved successfully',
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async getTopPerformers(
        @Query('courseId') courseId?: number,
        @Query('limit') limit?: number,
    ): Promise<StandardApiResponse<TopPerformerReportDto[]>> {
        try {
            this.logger.log(
                `Retrieving top performers for courseId: ${courseId}, limit: ${limit}`,
            );

            const performers =
                await this.leaderboardReportsService.getTopPerformers(
                    courseId,
                    limit,
                );

            this.logger.log('Top performers retrieved successfully');

            return {
                success: true,
                message: 'Top performers retrieved successfully',
                data: performers,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error('Error retrieving top performers:', error);
            throw error;
        }
    }

    // Training Progress Reports Endpoints
    @Get('training-progress/:userId/analytics')
    @ApiOperation({
        summary: '📚 Comprehensive Training Progress Analytics Dashboard',
        description: `
      **Provides detailed training progress analytics with personalized learning insights**
      
      This endpoint delivers comprehensive learning journey analytics including:
      - Personalized learning path tracking and milestone recognition
      - Skill development progression with competency mapping
      - Learning velocity analysis and time investment optimization
      - Knowledge retention assessment and spaced repetition recommendations
      
      **Learning Journey Analytics:**
      - Course progression tracking with completion percentage
      - Learning milestone identification and achievement recognition
      - Skill acquisition timeline and proficiency development
      - Knowledge gap analysis and targeted improvement recommendations
      
      **Performance Intelligence:**
      - Learning velocity calculations and efficiency metrics
      - Retention rate analysis and forgetting curve modeling
      - Difficulty progression tracking and adaptive learning suggestions
      - Personalized study schedule optimization
      
      **Competency Mapping:**
      - Skill-based progress tracking with proficiency levels
      - Learning objective completion and mastery assessment
      - Cross-course skill correlation and knowledge transfer
      - Career pathway alignment and professional development tracking
      
      **Adaptive Learning Features:**
      - Personalized difficulty adjustment recommendations
      - Optimal learning session timing and duration suggestions
      - Content recommendation based on learning patterns
      - Intervention timing for maximum learning effectiveness
      
      **Predictive Analytics:**
      - Learning outcome prediction and success probability
      - Time-to-completion estimation with accuracy modeling
      - Risk assessment for learning abandonment
      - Optimal learning path recommendation algorithm
      
      **Use Cases:**
      - Personalized learning dashboard and progress tracking
      - Academic counseling and learning strategy optimization
      - Corporate training effectiveness measurement
      - Professional development planning and career guidance
      - Educational intervention timing and strategy development
    `,
        operationId: 'getTrainingProgressAnalytics',
    })
    @ApiParam({
        name: 'userId',
        description:
            'Unique UUID identifier of the user for comprehensive training progress analysis',
        type: 'string',
        example: '123e4567-e89b-12d3-a456-426614174000',
        required: true,
    })
    @ApiQuery({
        name: 'courseId',
        required: false,
        description:
            'Filter progress analytics by specific course ID for focused course analysis',
        example: 1,
        type: 'number',
    })
    @ApiQuery({
        name: 'includeDetails',
        required: false,
        description:
            'Include detailed breakdown of each learning module and skill area',
        example: true,
        type: 'boolean',
    })
    @ApiQuery({
        name: 'timeframe',
        required: false,
        description: 'Time period for progress analysis',
        enum: ['last-week', 'last-month', 'last-quarter', 'all-time'],
        example: 'last-month',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Training progress analytics retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success indicator',
                },
                message: {
                    type: 'string',
                    example:
                        'Training progress analytics retrieved successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'object',
                    description: 'Comprehensive training progress analytics',
                    properties: {
                        userId: {
                            type: 'string',
                            example: '123e4567-e89b-12d3-a456-426614174000',
                            description: 'User unique identifier',
                        },
                        courseId: {
                            type: 'number',
                            example: 1,
                            description: 'Course unique identifier',
                        },
                        progress: {
                            type: 'number',
                            example: 85.3,
                            description: 'Current progress percentage',
                        },
                        milestones: {
                            type: 'array',
                            description: 'List of completed milestones',
                            items: {
                                type: 'string',
                                example: 'Introduction to Computer Science',
                                description: 'Milestone title',
                            },
                        },
                        skillAreas: {
                            type: 'array',
                            description: 'List of mastered skill areas',
                            items: {
                                type: 'string',
                                example: 'Mathematics',
                                description: 'Skill area title',
                            },
                        },
                    },
                },
                meta: {
                    type: 'object',
                    properties: {
                        timestamp: {
                            type: 'string',
                            example: '2024-01-15T10:30:00Z',
                            description: 'Analytics generation timestamp',
                        },
                        dataPoints: {
                            type: 'number',
                            example: 52,
                            description: 'Number of data points in analysis',
                        },
                        filters: {
                            type: 'object',
                            description: 'Applied filters for this analysis',
                        },
                    },
                },
            },
        },
    })
    async getTrainingProgressAnalytics(
        @Param('userId', ParseUUIDPipe) userId: string,
        @Query('courseId') courseId?: number,
    ): Promise<StandardApiResponse<TrainingProgressAnalyticsReportDto>> {
        try {
            this.logger.log(
                `Retrieving training progress analytics for user: ${userId}, courseId: ${courseId}`,
            );

            const analytics =
                await this.trainingProgressReportsService.getTrainingProgressAnalytics(
                    userId,
                    courseId,
                );

            this.logger.log(
                `Training progress analytics retrieved successfully for user: ${userId}`,
            );

            return {
                success: true,
                message: 'Training progress analytics retrieved successfully',
                data: analytics,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                `Error retrieving training progress analytics for user ${userId}:`,
                error,
            );
            throw error;
        }
    }

    @Get('training-progress/global-stats')
    @ApiOperation({
        summary: '🌍 Global Training Progress Statistics',
        description:
            'Retrieve system-wide training progress statistics including completion rates and popular learning paths.',
        operationId: 'getGlobalTrainingProgressStatistics',
    })
    @ApiOkResponse({
        description:
            '✅ Global training progress statistics retrieved successfully',
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async getGlobalTrainingProgressStats(): Promise<
        StandardApiResponse<GlobalTrainingProgressStatsReportDto>
    > {
        try {
            this.logger.log('Retrieving global training progress statistics');

            const stats =
                await this.trainingProgressReportsService.getGlobalTrainingProgressStats();

            this.logger.log(
                'Global training progress statistics retrieved successfully',
            );

            return {
                success: true,
                message:
                    'Global training progress statistics retrieved successfully',
                data: stats,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                'Error retrieving global training progress statistics:',
                error,
            );
            throw error;
        }
    }

    @Get('training-progress/:userId/skill-development')
    @ApiOperation({
        summary: '🎯 Skill Development Report',
        description:
            'Retrieve skill development analytics for a specific user.',
        operationId: 'getSkillDevelopmentReport',
    })
    @ApiParam({
        name: 'userId',
        description: 'Unique identifier of the user',
        type: 'string',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @ApiQuery({
        name: 'courseId',
        required: false,
        description: 'Filter by specific course',
    })
    @ApiOkResponse({
        description: '✅ Skill development report retrieved successfully',
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async getSkillDevelopment(
        @Param('userId', ParseUUIDPipe) userId: string,
        @Query('courseId') courseId?: number,
    ): Promise<StandardApiResponse<SkillDevelopmentReportDto[]>> {
        try {
            this.logger.log(
                `Retrieving skill development for user: ${userId}, courseId: ${courseId}`,
            );

            const skillDevelopment =
                await this.trainingProgressReportsService.getSkillDevelopment(
                    userId,
                    courseId,
                );

            this.logger.log(
                `Skill development retrieved successfully for user: ${userId}`,
            );

            return {
                success: true,
                message: 'Skill development report retrieved successfully',
                data: skillDevelopment,
                meta: {
                    timestamp: new Date().toISOString(),
                },
            };
        } catch (error) {
            this.logger.error(
                `Error retrieving skill development for user ${userId}:`,
                error,
            );
            throw error;
        }
    }
}

/*
 * Class #214: ReportsModule
 * Source: reports/reports.module.ts:57
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 29 characters (1 lines)
 */
export class ReportsModule {}

/*
 * Class #215: CourseReportsService
 * Source: reports/services/course-reports.service.ts:18
 * Type: Exported Class
 * Methods: 14
 * Properties: 33
 * Decorators: 6
 * Complexity: 188
 * Size: 11290 characters (306 lines)
 */
export class CourseReportsService {
    constructor(
        @InjectRepository(Course)
        private courseRepository: Repository<Course>,
        @InjectRepository(Test)
        private testRepository: Repository<Test>,
        @InjectRepository(TestAttempt)
        private testAttemptRepository: Repository<TestAttempt>,
        @InjectRepository(User)
        private userRepository: Repository<User>,
        @Inject(CACHE_MANAGER)
        private cacheManager: Cache,
    ) {}

    async getCourseAnalytics(
        courseId: number,
        scope?: OrgBranchScope,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        userId?: string,
    ): Promise<CourseAnalyticsResponseDto> {
        // TODO: Implement org/branch scoping validation here in the future
        // For now, we'll use the courseId as provided
        const cacheKey = `course_analytics_${courseId}_${scope?.orgId || 'global'}_${scope?.branchId || 'global'}`;

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<CourseAnalyticsResponseDto>(cacheKey);

        if (cachedData) {
            return {
                ...cachedData,
                cached: true,
            };
        }

        // Generate fresh analytics data
        const [stats, performance] = await Promise.all([
            this.getCourseStats(courseId),
            this.getCoursePerformance(courseId),
        ]);

        const analyticsData: CourseAnalyticsResponseDto = {
            stats,
            performance,
            generatedAt: new Date(),
            cached: false,
        };

        // Cache the result for 1 hour (3600 seconds)
        await this.cacheManager.set(cacheKey, analyticsData, 3600);

        return analyticsData;
    }

    private async getCourseStats(courseId: number): Promise<CourseStatsDto> {
        // Get basic course info
        const course = await this.courseRepository.findOne({
            where: { courseId },
            relations: ['tests'],
        });

        if (!course) {
            throw new Error(`Course with ID ${courseId} not found`);
        }

        // Get total students enrolled (count unique users who attempted tests in this course)
        const totalStudentsEnrolled = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .select('COUNT(DISTINCT ta.userId)', 'count')
            .getRawOne()
            .then(
                (result: { count: string } | undefined) =>
                    parseInt(result?.count || '0') || 0,
            );

        // Get completion rate (students who completed all tests vs total enrolled)
        const totalTests = course.tests?.length || 0;
        let completionRate = 0;

        if (totalTests > 0 && totalStudentsEnrolled > 0) {
            const completedStudents = await this.testAttemptRepository
                .createQueryBuilder('ta')
                .innerJoin('ta.test', 't')
                .where('t.courseId = :courseId', { courseId })
                .andWhere('ta.status = :status', { status: 'submitted' })
                .groupBy('ta.userId')
                .having('COUNT(DISTINCT t.testId) = :totalTests', {
                    totalTests,
                })
                .select('ta.userId')
                .getCount();

            completionRate = (completedStudents / totalStudentsEnrolled) * 100;
        }

        // Calculate average study duration (time between first and last attempt per user)
        const avgStudyDuration = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .select('ta.userId')
            .addSelect('MIN(ta.startTime)', 'firstAttempt')
            .addSelect('MAX(ta.submitTime)', 'lastAttempt')
            .groupBy('ta.userId')
            .having('MAX(ta.submitTime) IS NOT NULL')
            .getRawMany();

        let averageStudyDurationHours = 0;
        if (avgStudyDuration.length > 0) {
            const totalHours = avgStudyDuration.reduce(
                (
                    sum: number,
                    student: { lastAttempt: string; firstAttempt: string },
                ) => {
                    const duration =
                        (new Date(student.lastAttempt).getTime() -
                            new Date(student.firstAttempt).getTime()) /
                        (1000 * 60 * 60);
                    return sum + duration;
                },
                0,
            );
            averageStudyDurationHours = totalHours / avgStudyDuration.length;
        }

        // Calculate popularity score (weighted by enrollments and completion rate)
        const popularityScore = Math.min(
            100,
            totalStudentsEnrolled * 0.7 + completionRate * 0.3,
        );

        // Get average test score
        const avgScore = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .innerJoin('ta.test', 't')
            .innerJoin('ta.results', 'r')
            .where('t.courseId = :courseId', { courseId })
            .andWhere('ta.status = :status', { status: 'submitted' })
            .select('AVG(r.score)', 'avgScore')
            .getRawOne();

        return {
            totalStudentsEnrolled,
            completionRate: Math.round(completionRate * 100) / 100,
            averageStudyDurationHours:
                Math.round(averageStudyDurationHours * 100) / 100,
            popularityScore: Math.round(popularityScore * 100) / 100,
            totalTests,
            averageTestScore: Math.round((avgScore?.avgScore || 0) * 100) / 100,
        };
    }

    private async getCoursePerformance(
        courseId: number,
    ): Promise<CoursePerformanceDto> {
        const course = await this.courseRepository.findOne({
            where: { courseId },
        });

        if (!course) {
            throw new Error(`Course with ID ${courseId} not found`);
        }

        // Get total attempts
        const totalAttempts = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .getCount();

        // Get first attempt success rate
        const firstAttemptSuccess = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .innerJoin('ta.test', 't')
            .innerJoin('ta.results', 'r')
            .where('t.courseId = :courseId', { courseId })
            .andWhere('ta.attemptNumber = 1')
            .andWhere('ta.status = :status', { status: 'submitted' })
            .andWhere('r.score >= 70') // Assuming 70% is passing
            .getCount();

        const totalFirstAttempts = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .andWhere('ta.attemptNumber = 1')
            .getCount();

        const firstAttemptSuccessRate =
            totalFirstAttempts > 0
                ? (firstAttemptSuccess / totalFirstAttempts) * 100
                : 0;

        // Get average attempts per student
        const attemptsPerStudent = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .select('ta.userId')
            .addSelect('COUNT(*)', 'attemptCount')
            .groupBy('ta.userId')
            .getRawMany();

        const averageAttemptsPerStudent =
            attemptsPerStudent.length > 0
                ? attemptsPerStudent.reduce(
                      (sum, student) => sum + parseInt(student.attemptCount),
                      0,
                  ) / attemptsPerStudent.length
                : 0;

        // Find most challenging test (lowest success rate)
        const testSuccessRates = await this.testRepository
            .createQueryBuilder('t')
            .leftJoin('t.testAttempts', 'ta')
            .leftJoin('ta.results', 'r')
            .where('t.courseId = :courseId', { courseId })
            .select('t.title')
            .addSelect('COUNT(ta.attemptId)', 'totalAttempts')
            .addSelect(
                'COUNT(CASE WHEN r.score >= 70 THEN 1 END)',
                'successfulAttempts',
            )
            .groupBy('t.testId, t.title')
            .having('COUNT(ta.attemptId) > 0')
            .getRawMany();

        let mostChallengingTest = undefined;
        let lowestSuccessRate = 100;

        for (const test of testSuccessRates) {
            const successRate =
                (test.successfulAttempts / test.totalAttempts) * 100;
            if (successRate < lowestSuccessRate) {
                lowestSuccessRate = successRate;
                mostChallengingTest = test.title;
            }
        }

        return {
            courseId,
            courseTitle: course.title,
            totalAttempts,
            firstAttemptSuccessRate:
                Math.round(firstAttemptSuccessRate * 100) / 100,
            averageAttemptsPerStudent:
                Math.round(averageAttemptsPerStudent * 100) / 100,
            mostChallengingTest,
        };
    }

    async getCourseEnrollmentStats(courseId: number): Promise<any> {
        const cacheKey = `course_enrollment_${courseId}`;

        const cachedData = await this.cacheManager.get(cacheKey);
        if (cachedData) {
            return cachedData;
        }

        // Get enrollment trends over time
        const enrollmentData = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .select('DATE(ta.createdAt)', 'date')
            .addSelect('COUNT(DISTINCT ta.userId)', 'newEnrollments')
            .groupBy('DATE(ta.createdAt)')
            .orderBy('date', 'ASC')
            .getRawMany();

        // Cache for 30 minutes
        await this.cacheManager.set(cacheKey, enrollmentData, 1800);

        return enrollmentData;
    }

    async getAllCoursesPopularityRanking(): Promise<any> {
        const cacheKey = 'courses_popularity_global';

        const cachedData = await this.cacheManager.get(cacheKey);
        if (cachedData) {
            return cachedData;
        }

        const popularityCourses = await this.courseRepository
            .createQueryBuilder('c')
            .leftJoin('c.tests', 't')
            .leftJoin('t.testAttempts', 'ta')
            .select('c.courseId')
            .addSelect('c.title')
            .addSelect('COUNT(DISTINCT ta.userId)', 'enrollments')
            .addSelect('COUNT(DISTINCT ta.attemptId)', 'totalAttempts')
            .groupBy('c.courseId, c.title')
            .orderBy('enrollments', 'DESC')
            .addOrderBy('totalAttempts', 'DESC')
            .limit(10)
            .getRawMany();

        // Cache for 6 hours
        await this.cacheManager.set(cacheKey, popularityCourses, 21600);

        return popularityCourses;
    }
}

/*
 * Class #216: LeaderboardReportsService
 * Source: reports/services/leaderboard-reports.service.ts:22
 * Type: Exported Class
 * Methods: 25
 * Properties: 68
 * Decorators: 6
 * Complexity: 274
 * Size: 16485 characters (470 lines)
 */
export class LeaderboardReportsService {
    constructor(
        @InjectRepository(Leaderboard)
        private leaderboardRepository: Repository<Leaderboard>,
        @InjectRepository(Result)
        private resultRepository: Repository<Result>,
        @InjectRepository(TestAttempt)
        private testAttemptRepository: Repository<TestAttempt>,
        @InjectRepository(User)
        private userRepository: Repository<User>,
        @InjectRepository(Course)
        private courseRepository: Repository<Course>,
        @Inject(CACHE_MANAGER)
        private cacheManager: Cache,
    ) {}

    async getLeaderboardAnalytics(
        userId?: string,
        courseId?: number,
    ): Promise<LeaderboardAnalyticsReportDto> {
        const cacheKey = `leaderboard_analytics_${userId || 'global'}_${courseId || 'all'}`;

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<LeaderboardAnalyticsReportDto>(
                cacheKey,
            );

        if (cachedData) {
            return {
                ...cachedData,
                cached: true,
            };
        }

        // Generate fresh analytics data
        const [stats, performance] = await Promise.all([
            this.getLeaderboardStats(userId, courseId),
            this.getLeaderboardPerformance(userId, courseId),
        ]);

        const analyticsData: LeaderboardAnalyticsReportDto = {
            stats,
            performance,
            generatedAt: new Date(),
            cached: false,
        };

        // Cache the result for 15 minutes (900 seconds) - leaderboards are dynamic
        await this.cacheManager.set(cacheKey, analyticsData, 900);

        return analyticsData;
    }

    async getGlobalLeaderboardStats(): Promise<GlobalLeaderboardStatsReportDto> {
        const cacheKey = 'global_leaderboard_stats';

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<GlobalLeaderboardStatsReportDto>(
                cacheKey,
            );

        if (cachedData) {
            return {
                ...cachedData,
                cached: true,
            };
        }

        // Total participants across all leaderboards
        const totalParticipants = await this.leaderboardRepository
            .createQueryBuilder('l')
            .select('COUNT(DISTINCT l.userId)')
            .getRawOne();

        // Average points across all participants
        const avgPointsResult = await this.leaderboardRepository
            .createQueryBuilder('l')
            .select('AVG(l.points)', 'avgPoints')
            .getRawOne();

        const averagePoints = Number(avgPointsResult?.avgPoints || 0);

        // Top performers across all courses
        const topGlobalPerformers = await this.leaderboardRepository
            .createQueryBuilder('l')
            .innerJoin('l.user', 'u')
            .select('u.userId', 'userId')
            .addSelect('u.firstName', 'firstName')
            .addSelect('u.lastName', 'lastName')
            .addSelect('SUM(l.points)', 'totalPoints')
            .addSelect('COUNT(DISTINCT l.courseId)', 'coursesParticipated')
            .groupBy('u.userId, u.firstName, u.lastName')
            .orderBy('SUM(l.points)', 'DESC')
            .limit(10)
            .getRawMany();

        // Course leaderboard activity
        const courseActivity = await this.leaderboardRepository
            .createQueryBuilder('l')
            .innerJoin('l.course', 'c')
            .select('c.courseId', 'courseId')
            .addSelect('c.title', 'title')
            .addSelect('COUNT(DISTINCT l.userId)', 'participants')
            .addSelect('AVG(l.points)', 'averagePoints')
            .addSelect('MAX(l.points)', 'topScore')
            .groupBy('c.courseId, c.title')
            .orderBy('COUNT(DISTINCT l.userId)', 'DESC')
            .limit(5)
            .getRawMany();

        // Recent activity (last 7 days)
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

        const recentActivity = await this.leaderboardRepository
            .createQueryBuilder('l')
            .where('l.lastUpdated >= :sevenDaysAgo', { sevenDaysAgo })
            .getCount();

        const statsData: GlobalLeaderboardStatsReportDto = {
            totalParticipants: Number(totalParticipants?.count || 0),
            averagePoints: Math.round(averagePoints * 100) / 100,
            topGlobalPerformers: topGlobalPerformers.map(performer => ({
                userId: performer.userId,
                name: `${performer.firstName} ${performer.lastName}`,
                totalPoints: Number(performer.totalPoints),
                coursesParticipated: Number(performer.coursesParticipated),
            })),
            mostActiveCourses: courseActivity.map(course => ({
                courseId: course.courseId,
                title: course.title,
                participants: Number(course.participants),
                averagePoints:
                    Math.round(Number(course.averagePoints) * 100) / 100,
                topScore: Number(course.topScore),
            })),
            recentActivity,
            generatedAt: new Date(),
            cached: false,
        };

        // Cache the result for 10 minutes (600 seconds)
        await this.cacheManager.set(cacheKey, statsData, 600);

        return statsData;
    }

    async getTopPerformers(
        courseId?: number,
        limit: number = 10,
    ): Promise<TopPerformerReportDto[]> {
        const cacheKey = `top_performers_${courseId || 'global'}_${limit}`;

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<TopPerformerReportDto[]>(cacheKey);

        if (cachedData) {
            return cachedData;
        }

        let query = this.leaderboardRepository
            .createQueryBuilder('l')
            .innerJoin('l.user', 'u')
            .select('u.userId', 'userId')
            .addSelect('u.firstName', 'firstName')
            .addSelect('u.lastName', 'lastName')
            .addSelect('l.points', 'points')
            .addSelect('l.rank', 'rank')
            .addSelect('l.courseId', 'courseId');

        if (courseId) {
            query = query.where('l.courseId = :courseId', { courseId });
        }

        const performers = await query
            .orderBy('l.points', 'DESC')
            .limit(limit)
            .getRawMany();

        const topPerformers: TopPerformerReportDto[] = performers.map(
            performer => ({
                userId: performer.userId,
                name: `${performer.firstName} ${performer.lastName}`,
                points: Number(performer.points),
                rank: Number(performer.rank),
                courseId: performer.courseId,
            }),
        );

        // Cache the result for 15 minutes (900 seconds)
        await this.cacheManager.set(cacheKey, topPerformers, 900);

        return topPerformers;
    }

    async getRankMovements(
        courseId?: number,
        days: number = 7,
    ): Promise<RankMovementReportDto[]> {
        const cacheKey = `rank_movements_${courseId || 'global'}_${days}`;

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<RankMovementReportDto[]>(cacheKey);

        if (cachedData) {
            return cachedData;
        }

        const daysAgo = new Date();
        daysAgo.setDate(daysAgo.getDate() - days);

        // This is a simplified implementation
        // In a real scenario, you'd want to track historical rank data
        let query = this.leaderboardRepository
            .createQueryBuilder('l')
            .innerJoin('l.user', 'u')
            .select('u.userId', 'userId')
            .addSelect('u.firstName', 'firstName')
            .addSelect('u.lastName', 'lastName')
            .addSelect('l.points', 'currentPoints')
            .addSelect('l.rank', 'currentRank')
            .addSelect('l.lastUpdated', 'lastUpdated');

        if (courseId) {
            query = query.where('l.courseId = :courseId', { courseId });
        }

        const movements = await query
            .where('l.lastUpdated >= :daysAgo', { daysAgo })
            .orderBy('l.lastUpdated', 'DESC')
            .getRawMany();

        const rankMovements: RankMovementReportDto[] = movements.map(
            movement => ({
                userId: movement.userId,
                name: `${movement.firstName} ${movement.lastName}`,
                currentRank: Number(movement.currentRank),
                previousRank:
                    Number(movement.currentRank) +
                    Math.floor(Math.random() * 5 - 2), // Simulated
                rankChange: Math.floor(Math.random() * 10 - 5), // Simulated
                currentPoints: Number(movement.currentPoints),
                pointsChange: Math.floor(Math.random() * 100 - 50), // Simulated
            }),
        );

        // Cache the result for 1 hour (3600 seconds)
        await this.cacheManager.set(cacheKey, rankMovements, 3600);

        return rankMovements;
    }

    async getCompetitiveMetrics(
        courseId?: number,
    ): Promise<CompetitiveMetricsReportDto> {
        const cacheKey = `competitive_metrics_${courseId || 'global'}`;

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<CompetitiveMetricsReportDto>(cacheKey);

        if (cachedData) {
            return cachedData;
        }

        let query = this.leaderboardRepository.createQueryBuilder('l');

        if (courseId) {
            query = query.where('l.courseId = :courseId', { courseId });
        }

        // Calculate competitive intensity metrics
        const leaderboardData = await query
            .select('l.points', 'points')
            .addSelect('l.rank', 'rank')
            .orderBy('l.points', 'DESC')
            .getRawMany();

        const points = leaderboardData.map(entry => Number(entry.points));
        const totalParticipants = points.length;

        // Calculate standard deviation to measure competition intensity
        const mean =
            points.reduce((sum, point) => sum + point, 0) / totalParticipants;
        const standardDeviation = Math.sqrt(
            points.reduce((sum, point) => sum + Math.pow(point - mean, 2), 0) /
                totalParticipants,
        );

        // Competition intensity (lower std dev = tighter competition)
        const competitionIntensity =
            standardDeviation > 0
                ? Math.max(0, 100 - (standardDeviation / mean) * 100)
                : 0;

        // Top 10% threshold
        const top10Threshold = Math.floor(totalParticipants * 0.1);
        const top10Points = points.slice(0, top10Threshold);
        const averageTop10 =
            top10Points.reduce((sum, point) => sum + point, 0) /
            top10Points.length;

        // Bottom 10% threshold
        const bottom10Threshold = Math.floor(totalParticipants * 0.9);
        const bottom10Points = points.slice(bottom10Threshold);
        const averageBottom10 =
            bottom10Points.reduce((sum, point) => sum + point, 0) /
            bottom10Points.length;

        const metrics: CompetitiveMetricsReportDto = {
            totalParticipants,
            competitionIntensity: Math.round(competitionIntensity * 100) / 100,
            averagePoints: Math.round(mean * 100) / 100,
            topPerformerThreshold: Math.round(averageTop10 * 100) / 100,
            participationGap:
                Math.round((averageTop10 - averageBottom10) * 100) / 100,
            standardDeviation: Math.round(standardDeviation * 100) / 100,
        };

        // Cache the result for 30 minutes (1800 seconds)
        await this.cacheManager.set(cacheKey, metrics, 1800);

        return metrics;
    }

    private async getLeaderboardStats(
        userId?: string,
        courseId?: number,
    ): Promise<LeaderboardStatsReportDto> {
        let query = this.leaderboardRepository.createQueryBuilder('l');

        if (userId) {
            query = query.where('l.userId = :userId', { userId });
        }

        if (courseId) {
            const courseCondition = userId ? 'AND' : 'WHERE';
            query = query.where(`${courseCondition} l.courseId = :courseId`, {
                courseId,
            });
        }

        // User's current rankings
        const userRankings = await query
            .select('l.rank', 'rank')
            .addSelect('l.points', 'points')
            .addSelect('l.courseId', 'courseId')
            .orderBy('l.points', 'DESC')
            .getRawMany();

        const totalRankings = userRankings.length;
        const averageRank =
            totalRankings > 0
                ? userRankings.reduce(
                      (sum, ranking) => sum + Number(ranking.rank),
                      0,
                  ) / totalRankings
                : 0;

        const totalPoints = userRankings.reduce(
            (sum, ranking) => sum + Number(ranking.points),
            0,
        );
        const bestRank =
            totalRankings > 0
                ? Math.min(...userRankings.map(r => Number(r.rank)))
                : 0;

        // Recent improvements
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

        let recentQuery = this.leaderboardRepository
            .createQueryBuilder('l')
            .where('l.lastUpdated >= :thirtyDaysAgo', { thirtyDaysAgo });

        if (userId) {
            recentQuery = recentQuery.andWhere('l.userId = :userId', {
                userId,
            });
        }

        if (courseId) {
            recentQuery = recentQuery.andWhere('l.courseId = :courseId', {
                courseId,
            });
        }

        const recentActivity = await recentQuery.getCount();

        return {
            totalRankings,
            averageRank: Math.round(averageRank * 100) / 100,
            bestRank,
            totalPoints,
            recentActivity,
        };
    }

    private async getLeaderboardPerformance(
        userId?: string,
        courseId?: number,
    ): Promise<LeaderboardPerformanceReportDto> {
        // Performance trends over time
        let query = this.leaderboardRepository
            .createQueryBuilder('l')
            .select('DATE(l.lastUpdated)', 'date')
            .addSelect('AVG(l.points)', 'averagePoints')
            .addSelect('AVG(l.rank)', 'averageRank')
            .groupBy('DATE(l.lastUpdated)')
            .orderBy('DATE(l.lastUpdated)', 'ASC')
            .limit(30);

        if (userId) {
            query = query.where('l.userId = :userId', { userId });
        }

        if (courseId) {
            const condition = userId ? 'AND' : 'WHERE';
            query = query.where(`${condition} l.courseId = :courseId`, {
                courseId,
            });
        }

        const trends = await query.getRawMany();

        // Course-specific performance
        let courseQuery = this.leaderboardRepository
            .createQueryBuilder('l')
            .innerJoin('l.course', 'c')
            .select('c.title', 'courseName')
            .addSelect('l.rank', 'rank')
            .addSelect('l.points', 'points')
            .addSelect('c.courseId', 'courseId')
            .orderBy('l.points', 'DESC');

        if (userId) {
            courseQuery = courseQuery.where('l.userId = :userId', { userId });
        }

        if (courseId) {
            const condition = userId ? 'AND' : 'WHERE';
            courseQuery = courseQuery.where(
                `${condition} l.courseId = :courseId`,
                { courseId },
            );
        }

        const coursePerformance = await courseQuery.getRawMany();

        return {
            performanceTrends: trends.map(trend => ({
                date: trend.date,
                averagePoints:
                    Math.round(Number(trend.averagePoints) * 100) / 100,
                averageRank: Math.round(Number(trend.averageRank) * 100) / 100,
            })),
            coursePerformance: coursePerformance.map(course => ({
                courseId: course.courseId,
                courseName: course.courseName,
                rank: Number(course.rank),
                points: Number(course.points),
            })),
        };
    }
}

/*
 * Class #217: ResultsReportsService
 * Source: reports/services/results-reports.service.ts:21
 * Type: Exported Class
 * Methods: 23
 * Properties: 89
 * Decorators: 5
 * Complexity: 417
 * Size: 24627 characters (682 lines)
 */
export class ResultsReportsService {
    constructor(
        @InjectRepository(Result)
        private resultRepository: Repository<Result>,
        @InjectRepository(TestAttempt)
        private testAttemptRepository: Repository<TestAttempt>,
        @InjectRepository(Test)
        private testRepository: Repository<Test>,
        @InjectRepository(Course)
        private courseRepository: Repository<Course>,
        @Inject(CACHE_MANAGER)
        private cacheManager: Cache,
    ) {}

    async getResultsAnalytics(
        userId: string,
    ): Promise<ResultsAnalyticsReportDto> {
        const cacheKey = `results_analytics_${userId}`;

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<ResultsAnalyticsReportDto>(cacheKey);

        if (cachedData) {
            return {
                ...cachedData,
                cached: true,
            };
        }

        // Generate fresh analytics data
        const [stats, performance, quality] = await Promise.all([
            this.getResultsStats(userId),
            this.getResultsPerformance(userId),
            this.getResultsQuality(userId),
        ]);

        const analyticsData: ResultsAnalyticsReportDto = {
            stats,
            performance,
            quality,
            generatedAt: new Date(),
            cached: false,
        };

        // Cache the result for 1 hour (3600 seconds)
        await this.cacheManager.set(cacheKey, analyticsData, 3600);

        return analyticsData;
    }

    async getCourseResultsAnalytics(
        courseId: number,
    ): Promise<ResultsAnalyticsReportDto> {
        const cacheKey = `course_results_${courseId}`;

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<ResultsAnalyticsReportDto>(cacheKey);

        if (cachedData) {
            return {
                ...cachedData,
                cached: true,
            };
        }

        // Verify course exists
        const course = await this.courseRepository.findOne({
            where: { courseId },
        });

        if (!course) {
            throw new Error(`Course with ID ${courseId} not found`);
        }

        // Generate fresh analytics data for course
        const [stats, performance, quality] = await Promise.all([
            this.getCourseResultsStats(courseId),
            this.getCourseResultsPerformance(courseId),
            this.getCourseResultsQuality(courseId),
        ]);

        const analyticsData: ResultsAnalyticsReportDto = {
            stats,
            performance,
            quality,
            generatedAt: new Date(),
            cached: false,
        };

        // Cache the result for 45 minutes (2700 seconds)
        await this.cacheManager.set(cacheKey, analyticsData, 2700);

        return analyticsData;
    }

    async getGlobalResultsStats(): Promise<GlobalResultsStatsReportDto> {
        const cacheKey = 'global_results_stats';

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<GlobalResultsStatsReportDto>(cacheKey);

        if (cachedData) {
            return {
                ...cachedData,
                cached: true,
            };
        }

        // Total results
        const totalResults = await this.resultRepository.count();

        // Passed vs Failed
        const passedResults = await this.resultRepository.count({
            where: { passed: true },
        });
        const failedResults = totalResults - passedResults;

        // Overall average score
        const avgScoreResult = await this.resultRepository
            .createQueryBuilder('r')
            .select('AVG(r.score)', 'avgScore')
            .getRawOne();

        const overallAverageScore = Number(avgScoreResult?.avgScore || 0);

        // Score distribution
        const scoreDistribution = await this.getGlobalScoreDistribution();

        // Recent performance trends (last 30 days)
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

        const recentResults = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.submitTime >= :thirtyDaysAgo', { thirtyDaysAgo })
            .getCount();

        // Top performing courses (by average score)
        const topCourses = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .innerJoin('ta.test', 't')
            .innerJoin('t.course', 'c')
            .select('c.courseId', 'courseId')
            .addSelect('c.title', 'title')
            .addSelect('AVG(r.score)', 'averageScore')
            .addSelect('COUNT(r.resultId)', 'totalResults')
            .groupBy('c.courseId, c.title')
            .having('COUNT(r.resultId) >= 10') // Only courses with at least 10 results
            .orderBy('AVG(r.score)', 'DESC')
            .limit(5)
            .getRawMany();

        const statsData: GlobalResultsStatsReportDto = {
            totalResults,
            passedResults,
            failedResults,
            passRate:
                totalResults > 0 ? (passedResults / totalResults) * 100 : 0,
            overallAverageScore: Math.round(overallAverageScore * 100) / 100,
            scoreDistribution,
            recentResults,
            topPerformingCourses: topCourses.map(course => ({
                courseId: course.courseId,
                title: course.title,
                averageScore:
                    Math.round(Number(course.averageScore) * 100) / 100,
                totalResults: Number(course.totalResults),
            })),
            generatedAt: new Date(),
            cached: false,
        };

        // Cache the result for 3 hours (10800 seconds)
        await this.cacheManager.set(cacheKey, statsData, 10800);

        return statsData;
    }

    async getPerformanceTrends(
        userId?: string,
        courseId?: number,
    ): Promise<PerformanceTrendReportDto[]> {
        const cacheKey = `performance_trends_${userId || 'global'}_${courseId || 'all'}`;

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<PerformanceTrendReportDto[]>(cacheKey);

        if (cachedData) {
            return cachedData;
        }

        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

        let query = this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.submitTime >= :thirtyDaysAgo', { thirtyDaysAgo });

        if (userId) {
            query = query.andWhere('ta.userId = :userId', { userId });
        }

        if (courseId) {
            query = query
                .innerJoin('ta.test', 't')
                .andWhere('t.courseId = :courseId', { courseId });
        }

        const trends = await query
            .select('DATE(ta.submitTime)', 'date')
            .addSelect('AVG(r.score)', 'averageScore')
            .addSelect('COUNT(r.resultId)', 'totalResults')
            .addSelect(
                'COUNT(CASE WHEN r.passed = true THEN 1 END)',
                'passedResults',
            )
            .groupBy('DATE(ta.submitTime)')
            .orderBy('DATE(ta.submitTime)', 'ASC')
            .getRawMany();

        const trendsData: PerformanceTrendReportDto[] = trends.map(trend => ({
            date: trend.date,
            averageScore: Math.round(Number(trend.averageScore) * 100) / 100,
            totalResults: Number(trend.totalResults),
            passedResults: Number(trend.passedResults),
            passRate:
                Number(trend.totalResults) > 0
                    ? Math.round(
                          (Number(trend.passedResults) /
                              Number(trend.totalResults)) *
                              100 *
                              100,
                      ) / 100
                    : 0,
        }));

        // Cache the result for 2 hours (7200 seconds)
        await this.cacheManager.set(cacheKey, trendsData, 7200);

        return trendsData;
    }

    private async getResultsStats(
        userId: string,
    ): Promise<ResultsStatsReportDto> {
        // Total results for user
        const totalResults = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.userId = :userId', { userId })
            .getCount();

        // Passed vs Failed
        const passedResults = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.userId = :userId', { userId })
            .andWhere('r.passed = true')
            .getCount();

        const failedResults = totalResults - passedResults;

        // Average score
        const avgScoreResult = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.userId = :userId', { userId })
            .select('AVG(r.score)', 'avgScore')
            .getRawOne();

        const averageScore = Number(avgScoreResult?.avgScore || 0);

        // Best score
        const bestScoreResult = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.userId = :userId', { userId })
            .select('MAX(r.score)', 'bestScore')
            .getRawOne();

        const bestScore = Number(bestScoreResult?.bestScore || 0);

        // Recent performance (last 7 days)
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

        const recentResults = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.userId = :userId', { userId })
            .andWhere('ta.submitTime >= :sevenDaysAgo', { sevenDaysAgo })
            .getCount();

        return {
            totalResults,
            passedResults,
            failedResults,
            passRate:
                totalResults > 0 ? (passedResults / totalResults) * 100 : 0,
            averageScore: Math.round(averageScore * 100) / 100,
            bestScore: Math.round(bestScore * 100) / 100,
            recentResults,
        };
    }

    private async getCourseResultsStats(
        courseId: number,
    ): Promise<ResultsStatsReportDto> {
        // Total results for course
        const totalResults = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .getCount();

        // Passed vs Failed
        const passedResults = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .andWhere('r.passed = true')
            .getCount();

        const failedResults = totalResults - passedResults;

        // Average score
        const avgScoreResult = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .select('AVG(r.score)', 'avgScore')
            .getRawOne();

        const averageScore = Number(avgScoreResult?.avgScore || 0);

        // Best score
        const bestScoreResult = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .select('MAX(r.score)', 'bestScore')
            .getRawOne();

        const bestScore = Number(bestScoreResult?.bestScore || 0);

        // Recent results (last 7 days)
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

        const recentResults = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .andWhere('ta.submitTime >= :sevenDaysAgo', { sevenDaysAgo })
            .getCount();

        return {
            totalResults,
            passedResults,
            failedResults,
            passRate:
                totalResults > 0 ? (passedResults / totalResults) * 100 : 0,
            averageScore: Math.round(averageScore * 100) / 100,
            bestScore: Math.round(bestScore * 100) / 100,
            recentResults,
        };
    }

    private async getResultsPerformance(
        userId: string,
    ): Promise<ResultsPerformanceReportDto> {
        // Score trends over time
        const scoreHistory = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.userId = :userId', { userId })
            .select('DATE(ta.submitTime)', 'date')
            .addSelect('AVG(r.score)', 'averageScore')
            .groupBy('DATE(ta.submitTime)')
            .orderBy('DATE(ta.submitTime)', 'ASC')
            .limit(30) // Last 30 data points
            .getRawMany();

        // Subject performance (based on course performance)
        const subjectPerformance = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .innerJoin('ta.test', 't')
            .innerJoin('t.course', 'c')
            .where('ta.userId = :userId', { userId })
            .select('c.title', 'subject')
            .addSelect('AVG(r.score)', 'averageScore')
            .addSelect('COUNT(r.resultId)', 'totalAttempts')
            .addSelect(
                'COUNT(CASE WHEN r.passed = true THEN 1 END)',
                'passedAttempts',
            )
            .groupBy('c.courseId, c.title')
            .orderBy('AVG(r.score)', 'DESC')
            .getRawMany();

        // Improvement analysis
        const firstResult = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.userId = :userId', { userId })
            .orderBy('ta.submitTime', 'ASC')
            .select('r.score')
            .getOne();

        const lastResult = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.userId = :userId', { userId })
            .orderBy('ta.submitTime', 'DESC')
            .select('r.score')
            .getOne();

        const improvement =
            firstResult && lastResult
                ? lastResult.score - firstResult.score
                : 0;

        return {
            scoreHistory: scoreHistory.map(sh => ({
                date: sh.date,
                averageScore: Math.round(Number(sh.averageScore) * 100) / 100,
            })),
            subjectPerformance: subjectPerformance.map(sp => ({
                subject: sp.subject,
                averageScore: Math.round(Number(sp.averageScore) * 100) / 100,
                totalAttempts: Number(sp.totalAttempts),
                passRate:
                    Number(sp.totalAttempts) > 0
                        ? Math.round(
                              (Number(sp.passedAttempts) /
                                  Number(sp.totalAttempts)) *
                                  100 *
                                  100,
                          ) / 100
                        : 0,
            })),
            improvement: Math.round(improvement * 100) / 100,
            improvementPercentage: firstResult?.score
                ? Math.round((improvement / firstResult.score) * 100 * 100) /
                  100
                : 0,
        };
    }

    private async getCourseResultsPerformance(
        courseId: number,
    ): Promise<ResultsPerformanceReportDto> {
        // Score trends over time for course
        const scoreHistory = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .select('DATE(ta.submitTime)', 'date')
            .addSelect('AVG(r.score)', 'averageScore')
            .groupBy('DATE(ta.submitTime)')
            .orderBy('DATE(ta.submitTime)', 'ASC')
            .limit(30) // Last 30 data points
            .getRawMany();

        // Test performance within course
        const testPerformance = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .select('t.title', 'subject')
            .addSelect('AVG(r.score)', 'averageScore')
            .addSelect('COUNT(r.resultId)', 'totalAttempts')
            .addSelect(
                'COUNT(CASE WHEN r.passed = true THEN 1 END)',
                'passedAttempts',
            )
            .groupBy('t.testId, t.title')
            .orderBy('AVG(r.score)', 'DESC')
            .getRawMany();

        // Overall course improvement over time
        const firstResults = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .orderBy('ta.submitTime', 'ASC')
            .limit(100)
            .select('AVG(r.score)', 'avgScore')
            .getRawOne();

        const lastResults = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .orderBy('ta.submitTime', 'DESC')
            .limit(100)
            .select('AVG(r.score)', 'avgScore')
            .getRawOne();

        const improvement =
            firstResults && lastResults
                ? Number(lastResults.avgScore) - Number(firstResults.avgScore)
                : 0;

        return {
            scoreHistory: scoreHistory.map(sh => ({
                date: sh.date,
                averageScore: Math.round(Number(sh.averageScore) * 100) / 100,
            })),
            subjectPerformance: testPerformance.map(tp => ({
                subject: tp.subject,
                averageScore: Math.round(Number(tp.averageScore) * 100) / 100,
                totalAttempts: Number(tp.totalAttempts),
                passRate:
                    Number(tp.totalAttempts) > 0
                        ? Math.round(
                              (Number(tp.passedAttempts) /
                                  Number(tp.totalAttempts)) *
                                  100 *
                                  100,
                          ) / 100
                        : 0,
            })),
            improvement: Math.round(improvement * 100) / 100,
            improvementPercentage: firstResults
                ? Math.round(
                      (improvement / Number(firstResults.avgScore)) * 100 * 100,
                  ) / 100
                : 0,
        };
    }

    private async getResultsQuality(
        userId: string,
    ): Promise<ResultsQualityReportDto> {
        // Score consistency analysis
        const scores = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.userId = :userId', { userId })
            .select('r.score')
            .orderBy('ta.submitTime', 'ASC')
            .getMany();

        const scoreValues = scores.map(s => s.score);
        const standardDeviation = this.calculateStandardDeviation(scoreValues);
        const mean =
            scoreValues.reduce((sum, score) => sum + score, 0) /
            scoreValues.length;

        // Score reliability (lower standard deviation = more reliable)
        const reliability =
            mean > 0 ? Math.max(0, 100 - (standardDeviation / mean) * 100) : 0;

        // Outlier detection
        const outliers = scoreValues.filter(
            score => Math.abs(score - mean) > 2 * standardDeviation,
        );

        // Performance validation
        const expectedDifficulty = 70; // Assuming 70% is the expected average
        const actualPerformance = mean;
        const performanceVariance = Math.abs(
            actualPerformance - expectedDifficulty,
        );

        return {
            scoreConsistency: Math.round((100 - standardDeviation) * 100) / 100,
            reliability: Math.round(reliability * 100) / 100,
            outlierCount: outliers.length,
            performanceVariance: Math.round(performanceVariance * 100) / 100,
            standardDeviation: Math.round(standardDeviation * 100) / 100,
        };
    }

    private async getCourseResultsQuality(
        courseId: number,
    ): Promise<ResultsQualityReportDto> {
        // Score consistency analysis for course
        const scores = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .innerJoin('ta.test', 't')
            .where('t.courseId = :courseId', { courseId })
            .select('r.score')
            .orderBy('ta.submitTime', 'ASC')
            .getMany();

        const scoreValues = scores.map(s => s.score);
        if (scoreValues.length === 0) {
            return {
                scoreConsistency: 0,
                reliability: 0,
                outlierCount: 0,
                performanceVariance: 0,
                standardDeviation: 0,
            };
        }

        const standardDeviation = this.calculateStandardDeviation(scoreValues);
        const mean =
            scoreValues.reduce((sum, score) => sum + score, 0) /
            scoreValues.length;

        // Score reliability (lower standard deviation = more reliable)
        const reliability =
            mean > 0 ? Math.max(0, 100 - (standardDeviation / mean) * 100) : 0;

        // Outlier detection
        const outliers = scoreValues.filter(
            score => Math.abs(score - mean) > 2 * standardDeviation,
        );

        // Performance validation
        const expectedDifficulty = 70; // Assuming 70% is the expected average
        const actualPerformance = mean;
        const performanceVariance = Math.abs(
            actualPerformance - expectedDifficulty,
        );

        return {
            scoreConsistency: Math.round((100 - standardDeviation) * 100) / 100,
            reliability: Math.round(reliability * 100) / 100,
            outlierCount: outliers.length,
            performanceVariance: Math.round(performanceVariance * 100) / 100,
            standardDeviation: Math.round(standardDeviation * 100) / 100,
        };
    }

    private async getGlobalScoreDistribution(): Promise<ScoreDistributionReportDto> {
        const distribution = await this.resultRepository
            .createQueryBuilder('r')
            .select([
                'COUNT(CASE WHEN r.score >= 90 THEN 1 END) as a_grade',
                'COUNT(CASE WHEN r.score >= 80 AND r.score < 90 THEN 1 END) as b_grade',
                'COUNT(CASE WHEN r.score >= 70 AND r.score < 80 THEN 1 END) as c_grade',
                'COUNT(CASE WHEN r.score >= 60 AND r.score < 70 THEN 1 END) as d_grade',
                'COUNT(CASE WHEN r.score < 60 THEN 1 END) as f_grade',
            ])
            .getRawOne();

        return {
            aGrade: Number(distribution.a_grade),
            bGrade: Number(distribution.b_grade),
            cGrade: Number(distribution.c_grade),
            dGrade: Number(distribution.d_grade),
            fGrade: Number(distribution.f_grade),
        };
    }

    private calculateStandardDeviation(values: number[]): number {
        if (values.length === 0) return 0;

        const mean =
            values.reduce((sum, value) => sum + value, 0) / values.length;
        const squaredDifferences = values.map(value =>
            Math.pow(value - mean, 2),
        );
        const averageSquaredDifference =
            squaredDifferences.reduce((sum, diff) => sum + diff, 0) /
            values.length;

        return Math.sqrt(averageSquaredDifference);
    }
}

/*
 * Class #218: TestReportsService
 * Source: reports/services/test-reports.service.ts:23
 * Type: Exported Class
 * Methods: 17
 * Properties: 57
 * Decorators: 6
 * Complexity: 325
 * Size: 20360 characters (563 lines)
 */
export class TestReportsService {
    constructor(
        @InjectRepository(Test)
        private testRepository: Repository<Test>,
        @InjectRepository(TestAttempt)
        private testAttemptRepository: Repository<TestAttempt>,
        @InjectRepository(Result)
        private resultRepository: Repository<Result>,
        @InjectRepository(Question)
        private questionRepository: Repository<Question>,
        @InjectRepository(Answer)
        private answerRepository: Repository<Answer>,
        @Inject(CACHE_MANAGER)
        private cacheManager: Cache,
    ) {}

    async getTestAnalytics(testId: number): Promise<TestAnalyticsResponseDto> {
        const cacheKey = `test_analytics_${testId}`;

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<TestAnalyticsResponseDto>(cacheKey);

        if (cachedData) {
            return {
                ...cachedData,
                cached: true,
            };
        }

        // Verify test exists
        const test = await this.testRepository.findOne({
            where: { testId },
        });

        if (!test) {
            throw new Error(`Test with ID ${testId} not found`);
        }

        // Generate fresh analytics data
        const [stats, performance, quality] = await Promise.all([
            this.getTestStats(testId),
            this.getTestPerformance(testId, test),
            this.getTestQuality(testId),
        ]);

        const analyticsData: TestAnalyticsResponseDto = {
            stats,
            performance,
            quality,
            generatedAt: new Date(),
            cached: false,
        };

        // Cache the result for 1 hour (3600 seconds)
        await this.cacheManager.set(cacheKey, analyticsData, 3600);

        return analyticsData;
    }

    private async getTestStats(testId: number): Promise<TestStatsDto> {
        // Get total attempts
        const totalAttempts = await this.testAttemptRepository.count({
            where: { testId },
        });

        // Get completed attempts
        const completedAttempts = await this.testAttemptRepository.count({
            where: { testId, status: AttemptStatus.SUBMITTED },
        });

        // Calculate completion rate
        const completionRate =
            totalAttempts > 0 ? (completedAttempts / totalAttempts) * 100 : 0;

        // Calculate average duration
        const durationResult = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.testId = :testId', { testId })
            .andWhere('ta.status = :status', {
                status: AttemptStatus.SUBMITTED,
            })
            .andWhere('ta.submitTime IS NOT NULL')
            .select(
                'AVG(EXTRACT(EPOCH FROM (ta.submitTime - ta.startTime)))',
                'avgSeconds',
            )
            .getRawOne();

        const averageDurationMinutes =
            Number(durationResult?.avgSeconds || 0) / 60;

        // Get average score
        const avgScoreResult = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.testId = :testId', { testId })
            .andWhere('ta.status = :status', {
                status: AttemptStatus.SUBMITTED,
            })
            .select('AVG(r.score)', 'avgScore')
            .getRawOne();

        const averageScore = Number(avgScoreResult?.avgScore || 0);

        // Calculate pass rate (assuming 70% is passing)
        const passedResults = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.testId = :testId', { testId })
            .andWhere('ta.status = :status', {
                status: AttemptStatus.SUBMITTED,
            })
            .andWhere('r.passed = true')
            .getCount();

        const passRate =
            completedAttempts > 0
                ? (passedResults / completedAttempts) * 100
                : 0;

        // Calculate average attempts per user
        const attemptsPerUser = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.testId = :testId', { testId })
            .select('ta.userId')
            .addSelect('COUNT(*)', 'attemptCount')
            .groupBy('ta.userId')
            .getRawMany();

        const averageAttemptsPerUser =
            attemptsPerUser.length > 0
                ? attemptsPerUser.reduce(
                      (sum, user) => sum + Number(user.attemptCount),
                      0,
                  ) / attemptsPerUser.length
                : 0;

        // Calculate first attempt success rate
        const firstAttempts = await this.testAttemptRepository.count({
            where: {
                testId,
                attemptNumber: 1,
                status: AttemptStatus.SUBMITTED,
            },
        });

        const firstAttemptSuccesses = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .innerJoin('ta.results', 'r')
            .where('ta.testId = :testId', { testId })
            .andWhere('ta.attemptNumber = 1')
            .andWhere('ta.status = :status', {
                status: AttemptStatus.SUBMITTED,
            })
            .andWhere('r.passed = true')
            .getCount();

        const firstAttemptSuccessRate =
            firstAttempts > 0
                ? (firstAttemptSuccesses / firstAttempts) * 100
                : 0;

        return {
            totalAttempts,
            completedAttempts,
            completionRate: Math.round(completionRate * 100) / 100,
            averageDurationMinutes:
                Math.round(averageDurationMinutes * 100) / 100,
            averageScore: Math.round(averageScore * 100) / 100,
            passRate: Math.round(passRate * 100) / 100,
            averageAttemptsPerUser:
                Math.round(averageAttemptsPerUser * 100) / 100,
            firstAttemptSuccessRate:
                Math.round(firstAttemptSuccessRate * 100) / 100,
        };
    }

    private async getTestPerformance(
        testId: number,
        test: Test,
    ): Promise<TestPerformanceDto> {
        // Get score statistics
        const scoreStats = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.testId = :testId', { testId })
            .andWhere('ta.status = :status', {
                status: AttemptStatus.SUBMITTED,
            })
            .select('MAX(r.score)', 'highestScore')
            .addSelect('MIN(r.score)', 'lowestScore')
            .addSelect('STDDEV(r.score)', 'scoreStdDev')
            .getRawOne();

        const highestScore = Number(scoreStats?.highestScore || 0);
        const lowestScore = Number(scoreStats?.lowestScore || 0);
        const scoreStandardDeviation = Number(scoreStats?.scoreStdDev || 0);

        // Find most challenging and easiest questions
        const questionStats = await this.answerRepository
            .createQueryBuilder('a')
            .innerJoin('a.question', 'q')
            .innerJoin('a.attempt', 'ta')
            .where('ta.testId = :testId', { testId })
            .andWhere('ta.status = :status', {
                status: AttemptStatus.SUBMITTED,
            })
            .select('q.questionId', 'questionId')
            .addSelect('q.text', 'questionText')
            .addSelect('COUNT(*)', 'totalAnswers')
            .addSelect(
                'COUNT(CASE WHEN a.isCorrect = true THEN 1 END)',
                'correctAnswers',
            )
            .groupBy('q.questionId, q.text')
            .having('COUNT(*) > 0')
            .getRawMany();

        let mostChallengingQuestion = undefined;
        let easiestQuestion = undefined;
        let lowestSuccessRate = 100;
        let highestSuccessRate = 0;

        for (const question of questionStats) {
            const successRate =
                (Number(question.correctAnswers) /
                    Number(question.totalAnswers)) *
                100;
            if (successRate < lowestSuccessRate) {
                lowestSuccessRate = successRate;
                mostChallengingQuestion = question.questionText;
            }
            if (successRate > highestSuccessRate) {
                highestSuccessRate = successRate;
                easiestQuestion = question.questionText;
            }
        }

        // Calculate average time per question
        const avgTimeResult = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.testId = :testId', { testId })
            .andWhere('ta.status = :status', {
                status: AttemptStatus.SUBMITTED,
            })
            .andWhere('ta.submitTime IS NOT NULL')
            .select(
                'AVG(EXTRACT(EPOCH FROM (ta.submitTime - ta.startTime)))',
                'avgSeconds',
            )
            .getRawOne();

        // Get question count for this test
        const questionCount = await this.questionRepository.count({
            where: { testId },
        });

        const averageTimePerQuestion =
            questionCount > 0
                ? Number(avgTimeResult?.avgSeconds || 0) / questionCount
                : 0;

        return {
            testId,
            testTitle: test.title,
            testType: test.testType || 'UNKNOWN',
            highestScore,
            lowestScore,
            scoreStandardDeviation:
                Math.round(scoreStandardDeviation * 100) / 100,
            mostChallengingQuestion,
            easiestQuestion,
            averageTimePerQuestion:
                Math.round(averageTimePerQuestion * 100) / 100,
        };
    }

    private async getTestQuality(testId: number): Promise<TestQualityDto> {
        // Calculate difficulty score (inverse of average score)
        const avgScoreResult = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.testId = :testId', { testId })
            .andWhere('ta.status = :status', {
                status: AttemptStatus.SUBMITTED,
            })
            .select('AVG(r.score)', 'avgScore')
            .getRawOne();

        const avgScore = Number(avgScoreResult?.avgScore || 50);
        const difficultyScore = 100 - avgScore; // Inverse relationship

        // Calculate reliability coefficient (simplified Cronbach's alpha estimation)
        const results = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.testId = :testId', { testId })
            .andWhere('ta.status = :status', {
                status: AttemptStatus.SUBMITTED,
            })
            .select(['r.score'])
            .getMany();

        let reliabilityCoefficient = 0.5; // Default moderate reliability
        if (results.length > 1) {
            const scores = results.map(r => r.score);
            const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
            const variance =
                scores.reduce((a, b) => a + Math.pow(b - mean, 2), 0) /
                scores.length;
            // Simplified reliability estimate
            reliabilityCoefficient = Math.min(
                1,
                Math.max(0, variance > 0 ? 1 - 1 / variance : 0.5),
            );
        }

        // Calculate discrimination index (how well test distinguishes performance)
        const discriminationIndex = reliabilityCoefficient; // Simplified

        // Calculate effective questions percentage
        const questionStats = await this.answerRepository
            .createQueryBuilder('a')
            .innerJoin('a.question', 'q')
            .innerJoin('a.attempt', 'ta')
            .where('ta.testId = :testId', { testId })
            .andWhere('ta.status = :status', {
                status: AttemptStatus.SUBMITTED,
            })
            .select('q.questionId', 'questionId')
            .addSelect('COUNT(*)', 'totalAnswers')
            .addSelect(
                'COUNT(CASE WHEN a.isCorrect = true THEN 1 END)',
                'correctAnswers',
            )
            .groupBy('q.questionId')
            .having('COUNT(*) > 0')
            .getRawMany();

        const effectiveQuestions = questionStats.filter(q => {
            const successRate =
                (Number(q.correctAnswers) / Number(q.totalAnswers)) * 100;
            return successRate >= 20 && successRate <= 80; // Good discrimination range
        });

        const effectiveQuestionsPercentage =
            questionStats.length > 0
                ? (effectiveQuestions.length / questionStats.length) * 100
                : 0;

        // Calculate optimal duration
        const avgDurationResult = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.testId = :testId', { testId })
            .andWhere('ta.status = :status', {
                status: AttemptStatus.SUBMITTED,
            })
            .andWhere('ta.submitTime IS NOT NULL')
            .select(
                'AVG(EXTRACT(EPOCH FROM (ta.submitTime - ta.startTime)))',
                'avgSeconds',
            )
            .getRawOne();

        const optimalDurationMinutes = Math.round(
            Number(avgDurationResult?.avgSeconds || 3600) / 60,
        ); // Default 1 hour

        // Determine time pressure factor
        const completionTimes = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.testId = :testId', { testId })
            .andWhere('ta.status = :status', {
                status: AttemptStatus.SUBMITTED,
            })
            .andWhere('ta.submitTime IS NOT NULL')
            .select(
                'EXTRACT(EPOCH FROM (ta.submitTime - ta.startTime))',
                'duration',
            )
            .getRawMany();

        let timePressureFactor = 'moderate';
        if (completionTimes.length > 0) {
            const durations = completionTimes.map(ct => Number(ct.duration));
            const avgDuration =
                durations.reduce((a, b) => a + b, 0) / durations.length;
            const variance =
                durations.reduce(
                    (a, b) => a + Math.pow(b - avgDuration, 2),
                    0,
                ) / durations.length;
            const stdDev = Math.sqrt(variance);

            // Low variance suggests time pressure
            if (stdDev < avgDuration * 0.2) {
                timePressureFactor = 'high';
            } else if (stdDev > avgDuration * 0.5) {
                timePressureFactor = 'low';
            }
        }

        return {
            difficultyScore:
                Math.round(Math.max(0, Math.min(100, difficultyScore)) * 100) /
                100,
            reliabilityCoefficient:
                Math.round(reliabilityCoefficient * 100) / 100,
            discriminationIndex: Math.round(discriminationIndex * 100) / 100,
            effectiveQuestionsPercentage:
                Math.round(effectiveQuestionsPercentage * 100) / 100,
            optimalDurationMinutes,
            timePressureFactor,
        };
    }

    async getGlobalTestStats(): Promise<GlobalTestStatsDto> {
        const cacheKey = 'global_test_stats';

        const cachedData =
            await this.cacheManager.get<GlobalTestStatsDto>(cacheKey);
        if (cachedData) {
            return cachedData;
        }

        const now = new Date();
        const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

        // Total tests
        const totalTests = await this.testRepository.count();

        // Total attempts
        const totalAttempts = await this.testAttemptRepository.count();

        // Tests taken today
        const testsToday = await this.testAttemptRepository.count({
            where: {
                createdAt: oneDayAgo,
            },
        });

        // Tests taken this week
        const testsThisWeek = await this.testAttemptRepository.count({
            where: {
                createdAt: oneWeekAgo,
            },
        });

        // Average completion rate
        const completionStats = await this.testRepository
            .createQueryBuilder('t')
            .leftJoin('t.testAttempts', 'ta')
            .select('t.testId')
            .addSelect('COUNT(ta.attemptId)', 'totalAttempts')
            .addSelect(
                'COUNT(CASE WHEN ta.status = :submitted THEN 1 END)',
                'completedAttempts',
            )
            .setParameter('submitted', AttemptStatus.SUBMITTED)
            .groupBy('t.testId')
            .having('COUNT(ta.attemptId) > 0')
            .getRawMany();

        const averageCompletionRate =
            completionStats.length > 0
                ? completionStats.reduce((sum, test) => {
                      const rate =
                          (Number(test.completedAttempts) /
                              Number(test.totalAttempts)) *
                          100;
                      return sum + rate;
                  }, 0) / completionStats.length
                : 0;

        // Average score across all tests
        const avgScoreResult = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.status = :status', { status: AttemptStatus.SUBMITTED })
            .select('AVG(r.score)', 'avgScore')
            .getRawOne();

        const averageScore = Number(avgScoreResult?.avgScore || 0);

        // Most popular test type
        const testTypeStats = await this.testRepository
            .createQueryBuilder('t')
            .select('t.testType', 'testType')
            .addSelect('COUNT(*)', 'count')
            .groupBy('t.testType')
            .orderBy('count', 'DESC')
            .limit(1)
            .getRawOne();

        const mostPopularTestType = testTypeStats?.testType || 'UNKNOWN';

        // Peak testing hours
        const hourlyStats = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .select('EXTRACT(HOUR FROM ta.startTime)', 'hour')
            .addSelect('COUNT(*)', 'count')
            .groupBy('EXTRACT(HOUR FROM ta.startTime)')
            .orderBy('count', 'DESC')
            .limit(3)
            .getRawMany();

        const peakTestingHours = hourlyStats.map(stat =>
            parseInt(String(stat.hour)),
        );

        const globalStats: GlobalTestStatsDto = {
            totalTests,
            totalAttempts,
            testsToday,
            testsThisWeek,
            averageCompletionRate:
                Math.round(averageCompletionRate * 100) / 100,
            averageScore: Math.round(averageScore * 100) / 100,
            mostPopularTestType,
            peakTestingHours,
        };

        // Cache for 3 hours
        await this.cacheManager.set(cacheKey, globalStats, 10800);

        return globalStats;
    }

    async getTestAttemptTrends(testId: number): Promise<any> {
        const cacheKey = `test_attempt_trends_${testId}`;

        const cachedData = await this.cacheManager.get(cacheKey);
        if (cachedData) {
            return cachedData;
        }

        // Get attempt trends over the last 30 days
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

        const trendData = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.testId = :testId', { testId })
            .andWhere('ta.createdAt >= :thirtyDaysAgo', { thirtyDaysAgo })
            .select('DATE(ta.createdAt)', 'date')
            .addSelect('COUNT(*)', 'attempts')
            .addSelect(
                'COUNT(CASE WHEN ta.status = :submitted THEN 1 END)',
                'completed',
            )
            .setParameter('submitted', AttemptStatus.SUBMITTED)
            .groupBy('DATE(ta.createdAt)')
            .orderBy('date', 'ASC')
            .getRawMany();

        // Cache for 30 minutes
        await this.cacheManager.set(cacheKey, trendData, 1800);

        return trendData;
    }
}

/*
 * Class #219: TrainingProgressReportsService
 * Source: reports/services/training-progress-reports.service.ts:23
 * Type: Exported Class
 * Methods: 24
 * Properties: 86
 * Decorators: 7
 * Complexity: 277
 * Size: 19026 characters (516 lines)
 */
export class TrainingProgressReportsService {
    constructor(
        @InjectRepository(TrainingProgress)
        private trainingProgressRepository: Repository<TrainingProgress>,
        @InjectRepository(Result)
        private resultRepository: Repository<Result>,
        @InjectRepository(TestAttempt)
        private testAttemptRepository: Repository<TestAttempt>,
        @InjectRepository(User)
        private userRepository: Repository<User>,
        @InjectRepository(Course)
        private courseRepository: Repository<Course>,
        @InjectRepository(Test)
        private testRepository: Repository<Test>,
        @Inject(CACHE_MANAGER)
        private cacheManager: Cache,
    ) {}

    async getTrainingProgressAnalytics(
        userId: string,
        courseId?: number,
    ): Promise<TrainingProgressAnalyticsReportDto> {
        const cacheKey = `training_progress_analytics_${userId}_${courseId || 'all'}`;

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<TrainingProgressAnalyticsReportDto>(
                cacheKey,
            );

        if (cachedData) {
            return {
                ...cachedData,
                cached: true,
            };
        }

        // Generate fresh analytics data
        const [stats, performance] = await Promise.all([
            this.getTrainingProgressStats(userId, courseId),
            this.getTrainingProgressPerformance(userId, courseId),
        ]);

        const analyticsData: TrainingProgressAnalyticsReportDto = {
            stats,
            performance,
            generatedAt: new Date(),
            cached: false,
        };

        // Cache the result for 30 minutes (1800 seconds)
        await this.cacheManager.set(cacheKey, analyticsData, 1800);

        return analyticsData;
    }

    async getGlobalTrainingProgressStats(): Promise<GlobalTrainingProgressStatsReportDto> {
        const cacheKey = 'global_training_progress_stats';

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<GlobalTrainingProgressStatsReportDto>(
                cacheKey,
            );

        if (cachedData) {
            return {
                ...cachedData,
                cached: true,
            };
        }

        // Total learning paths
        const totalLearningPaths =
            await this.trainingProgressRepository.count();

        // Average completion percentage
        const avgCompletionResult = await this.trainingProgressRepository
            .createQueryBuilder('tp')
            .select('AVG(tp.completionPercentage)', 'avgCompletion')
            .getRawOne();

        const averageCompletion = Number(
            avgCompletionResult?.avgCompletion || 0,
        );

        // Active learners (progress updated in last 7 days)
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

        const activeLearners = await this.trainingProgressRepository
            .createQueryBuilder('tp')
            .where('tp.lastUpdated >= :sevenDaysAgo', { sevenDaysAgo })
            .select('COUNT(DISTINCT tp.userId)')
            .getRawOne();

        // Completion distribution
        const completionDistribution = await this.trainingProgressRepository
            .createQueryBuilder('tp')
            .select([
                'COUNT(CASE WHEN tp.completionPercentage = 100 THEN 1 END) as completed',
                'COUNT(CASE WHEN tp.completionPercentage >= 75 AND tp.completionPercentage < 100 THEN 1 END) as nearly_completed',
                'COUNT(CASE WHEN tp.completionPercentage >= 50 AND tp.completionPercentage < 75 THEN 1 END) as halfway',
                'COUNT(CASE WHEN tp.completionPercentage >= 25 AND tp.completionPercentage < 50 THEN 1 END) as started',
                'COUNT(CASE WHEN tp.completionPercentage < 25 THEN 1 END) as just_started',
            ])
            .getRawOne();

        // Most popular learning paths
        const popularPaths = await this.trainingProgressRepository
            .createQueryBuilder('tp')
            .innerJoin('tp.course', 'c')
            .select('c.courseId', 'courseId')
            .addSelect('c.title', 'title')
            .addSelect('COUNT(tp.userId)', 'enrollments')
            .addSelect('AVG(tp.completionPercentage)', 'averageCompletion')
            .groupBy('c.courseId, c.title')
            .orderBy('COUNT(tp.userId)', 'DESC')
            .limit(5)
            .getRawMany();

        // Learning velocity trends
        const velocityTrends = await this.getGlobalLearningVelocity();

        const statsData: GlobalTrainingProgressStatsReportDto = {
            totalLearningPaths,
            averageCompletion: Math.round(averageCompletion * 100) / 100,
            activeLearners: Number(activeLearners?.count || 0),
            completionDistribution: {
                completed: Number(completionDistribution.completed),
                nearlyCompleted: Number(
                    completionDistribution.nearly_completed,
                ),
                halfway: Number(completionDistribution.halfway),
                started: Number(completionDistribution.started),
                justStarted: Number(completionDistribution.just_started),
            },
            popularLearningPaths: popularPaths.map(path => ({
                courseId: path.courseId,
                title: path.title,
                enrollments: Number(path.enrollments),
                averageCompletion:
                    Math.round(Number(path.averageCompletion) * 100) / 100,
            })),
            learningVelocityTrends: velocityTrends,
            generatedAt: new Date(),
            cached: false,
        };

        // Cache the result for 2 hours (7200 seconds)
        await this.cacheManager.set(cacheKey, statsData, 7200);

        return statsData;
    }

    async getLearningPathCompletion(
        userId?: string,
        courseId?: number,
    ): Promise<LearningPathCompletionReportDto[]> {
        const cacheKey = `learning_path_completion_${userId || 'global'}_${courseId || 'all'}`;

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<LearningPathCompletionReportDto[]>(
                cacheKey,
            );

        if (cachedData) {
            return cachedData;
        }

        let query = this.trainingProgressRepository
            .createQueryBuilder('tp')
            .innerJoin('tp.course', 'c')
            .select('c.courseId', 'courseId')
            .addSelect('c.title', 'title')
            .addSelect('tp.completionPercentage', 'completionPercentage')
            .addSelect('tp.currentModule', 'currentModule')
            .addSelect('tp.lastUpdated', 'lastUpdated')
            .addSelect('tp.timeSpentMinutes', 'timeSpentMinutes');

        if (userId) {
            query = query.where('tp.userId = :userId', { userId });
        }

        if (courseId) {
            const condition = userId ? 'AND' : 'WHERE';
            query = query.where(`${condition} tp.courseId = :courseId`, {
                courseId,
            });
        }

        const completions = await query
            .orderBy('tp.completionPercentage', 'DESC')
            .getRawMany();

        const learningPaths: LearningPathCompletionReportDto[] =
            completions.map(completion => ({
                courseId: completion.courseId,
                title: completion.title,
                completionPercentage: Number(completion.completionPercentage),
                currentModule: completion.currentModule,
                timeSpent: Number(completion.timeSpentMinutes || 0),
                lastActivity: completion.lastUpdated,
                estimatedTimeToComplete: this.calculateEstimatedTimeToComplete(
                    Number(completion.completionPercentage),
                    Number(completion.timeSpentMinutes || 0),
                ),
            }));

        // Cache the result for 45 minutes (2700 seconds)
        await this.cacheManager.set(cacheKey, learningPaths, 2700);

        return learningPaths;
    }

    async getSkillDevelopment(
        userId: string,
        courseId?: number,
    ): Promise<SkillDevelopmentReportDto[]> {
        const cacheKey = `skill_development_${userId}_${courseId || 'all'}`;

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<SkillDevelopmentReportDto[]>(cacheKey);

        if (cachedData) {
            return cachedData;
        }

        // Get training progress with related test results
        let query = this.trainingProgressRepository
            .createQueryBuilder('tp')
            .innerJoin('tp.course', 'c')
            .leftJoin('c.tests', 't')
            .leftJoin('t.attempts', 'ta', 'ta.userId = :userId', { userId })
            .leftJoin('ta.results', 'r')
            .select('c.title', 'courseName')
            .addSelect('tp.completionPercentage', 'progressPercentage')
            .addSelect('AVG(r.score)', 'averageTestScore')
            .addSelect('COUNT(ta.attemptId)', 'totalAttempts')
            .addSelect('tp.timeSpentMinutes', 'timeSpentMinutes')
            .where('tp.userId = :userId', { userId })
            .groupBy(
                'c.courseId, c.title, tp.completionPercentage, tp.timeSpentMinutes',
            );

        if (courseId) {
            query = query.andWhere('tp.courseId = :courseId', { courseId });
        }

        const skills = await query.getRawMany();

        const skillDevelopment: SkillDevelopmentReportDto[] = skills.map(
            skill => {
                const averageScore = Number(skill.averageTestScore || 0);
                const progressPercentage = Number(skill.progressPercentage);
                const timeSpent = Number(skill.timeSpentMinutes || 0);

                // Calculate skill level based on progress and performance
                const skillLevel = this.calculateSkillLevel(
                    progressPercentage,
                    averageScore,
                );

                return {
                    skillArea: skill.courseName,
                    skillLevel,
                    progressPercentage,
                    averageTestScore: Math.round(averageScore * 100) / 100,
                    totalAttempts: Number(skill.totalAttempts || 0),
                    timeSpent,
                    improvementRate: this.calculateImprovementRate(
                        progressPercentage,
                        averageScore,
                    ),
                };
            },
        );

        // Cache the result for 1 hour (3600 seconds)
        await this.cacheManager.set(cacheKey, skillDevelopment, 3600);

        return skillDevelopment;
    }

    async getProgressMilestones(
        userId: string,
        courseId?: number,
    ): Promise<ProgressMilestoneReportDto[]> {
        const cacheKey = `progress_milestones_${userId}_${courseId || 'all'}`;

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<ProgressMilestoneReportDto[]>(cacheKey);

        if (cachedData) {
            return cachedData;
        }

        let query = this.trainingProgressRepository
            .createQueryBuilder('tp')
            .innerJoin('tp.course', 'c')
            .select('c.title', 'courseName')
            .addSelect('tp.completionPercentage', 'completionPercentage')
            .addSelect('tp.currentModule', 'currentModule')
            .addSelect('tp.lastUpdated', 'lastUpdated')
            .where('tp.userId = :userId', { userId });

        if (courseId) {
            query = query.andWhere('tp.courseId = :courseId', { courseId });
        }

        const progressData = await query.getRawMany();

        const milestones: ProgressMilestoneReportDto[] = progressData.map(
            progress => {
                const completionPercentage = Number(
                    progress.completionPercentage,
                );
                const milestones =
                    this.generateMilestones(completionPercentage);

                return {
                    courseName: progress.courseName,
                    currentProgress: completionPercentage,
                    currentModule: progress.currentModule,
                    milestonesAchieved: milestones.achieved,
                    nextMilestone: milestones.next,
                    lastUpdate: progress.lastUpdated,
                };
            },
        );

        // Cache the result for 1 hour (3600 seconds)
        await this.cacheManager.set(cacheKey, milestones, 3600);

        return milestones;
    }

    private async getTrainingProgressStats(
        userId: string,
        courseId?: number,
    ): Promise<TrainingProgressStatsReportDto> {
        let query = this.trainingProgressRepository
            .createQueryBuilder('tp')
            .where('tp.userId = :userId', { userId });

        if (courseId) {
            query = query.andWhere('tp.courseId = :courseId', { courseId });
        }

        const progressData = await query.getMany();

        const totalCourses = progressData.length;
        const completedCourses = progressData.filter(
            p => p.completionPercentage === 100,
        ).length;
        const averageCompletion =
            totalCourses > 0
                ? progressData.reduce(
                      (sum, p) => sum + p.completionPercentage,
                      0,
                  ) / totalCourses
                : 0;

        const totalTimeSpent = progressData.reduce(
            (sum, p) => sum + (p.timeSpentMinutes || 0),
            0,
        );

        // Recent activity
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

        const recentActivity = progressData.filter(
            p => p.lastUpdated && p.lastUpdated >= sevenDaysAgo,
        ).length;

        return {
            totalCourses,
            completedCourses,
            averageCompletion: Math.round(averageCompletion * 100) / 100,
            totalTimeSpent: Math.round(totalTimeSpent),
            recentActivity,
        };
    }

    private async getTrainingProgressPerformance(
        userId: string,
        courseId?: number,
    ): Promise<TrainingProgressPerformanceReportDto> {
        // Learning velocity over time
        let query = this.trainingProgressRepository
            .createQueryBuilder('tp')
            .where('tp.userId = :userId', { userId })
            .select('DATE(tp.lastUpdated)', 'date')
            .addSelect('AVG(tp.completionPercentage)', 'averageCompletion')
            .groupBy('DATE(tp.lastUpdated)')
            .orderBy('DATE(tp.lastUpdated)', 'ASC')
            .limit(30);

        if (courseId) {
            query = query.andWhere('tp.courseId = :courseId', { courseId });
        }

        const velocityTrends = await query.getRawMany();

        // Course-specific progress
        let courseQuery = this.trainingProgressRepository
            .createQueryBuilder('tp')
            .innerJoin('tp.course', 'c')
            .where('tp.userId = :userId', { userId })
            .select('c.title', 'courseName')
            .addSelect('tp.completionPercentage', 'completionPercentage')
            .addSelect('tp.timeSpentMinutes', 'timeSpentMinutes')
            .orderBy('tp.completionPercentage', 'DESC');

        if (courseId) {
            courseQuery = courseQuery.andWhere('tp.courseId = :courseId', {
                courseId,
            });
        }

        const courseProgress = await courseQuery.getRawMany();

        return {
            learningVelocity: velocityTrends.map(trend => ({
                date: trend.date,
                averageCompletion:
                    Math.round(Number(trend.averageCompletion) * 100) / 100,
            })),
            courseProgress: courseProgress.map(course => ({
                courseName: course.courseName,
                completionPercentage: Number(course.completionPercentage),
                timeSpent: Number(course.timeSpentMinutes || 0),
            })),
        };
    }

    private async getGlobalLearningVelocity() {
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

        return await this.trainingProgressRepository
            .createQueryBuilder('tp')
            .where('tp.lastUpdated >= :thirtyDaysAgo', { thirtyDaysAgo })
            .select('DATE(tp.lastUpdated)', 'date')
            .addSelect('AVG(tp.completionPercentage)', 'averageCompletion')
            .addSelect('COUNT(tp.userId)', 'activeUsers')
            .groupBy('DATE(tp.lastUpdated)')
            .orderBy('DATE(tp.lastUpdated)', 'ASC')
            .getRawMany()
            .then(trends =>
                trends.map(trend => ({
                    date: trend.date,
                    averageCompletion:
                        Math.round(Number(trend.averageCompletion) * 100) / 100,
                    activeUsers: Number(trend.activeUsers),
                })),
            );
    }

    private calculateEstimatedTimeToComplete(
        completionPercentage: number,
        timeSpent: number,
    ): number {
        if (completionPercentage === 0) return 0;
        const remainingPercentage = 100 - completionPercentage;
        const timePerPercentage = timeSpent / completionPercentage;
        return Math.round(remainingPercentage * timePerPercentage);
    }

    private calculateSkillLevel(
        progressPercentage: number,
        averageScore: number,
    ): 'Beginner' | 'Intermediate' | 'Advanced' | 'Expert' {
        const combinedScore = (progressPercentage + averageScore) / 2;

        if (combinedScore >= 90) return 'Expert';
        if (combinedScore >= 75) return 'Advanced';
        if (combinedScore >= 50) return 'Intermediate';
        return 'Beginner';
    }

    private calculateImprovementRate(
        progressPercentage: number,
        averageScore: number,
    ): number {
        // Simplified improvement rate calculation
        // In a real scenario, you'd track historical data
        return Math.round(((progressPercentage + averageScore) / 2) * 0.8);
    }

    private generateMilestones(completionPercentage: number): {
        achieved: string[];
        next: string;
    } {
        const milestones = [
            { threshold: 25, name: 'Getting Started' },
            { threshold: 50, name: 'Halfway Point' },
            { threshold: 75, name: 'Almost There' },
            { threshold: 100, name: 'Course Completed' },
        ];

        const achieved = milestones
            .filter(m => completionPercentage >= m.threshold)
            .map(m => m.name);

        const next =
            milestones.find(m => completionPercentage < m.threshold)?.name ||
            'All Milestones Achieved';

        return { achieved, next };
    }
}

/*
 * Class #220: UserReportsService
 * Source: reports/services/user-reports.service.ts:22
 * Type: Exported Class
 * Methods: 18
 * Properties: 40
 * Decorators: 5
 * Complexity: 309
 * Size: 18301 characters (502 lines)
 */
export class UserReportsService {
    constructor(
        @InjectRepository(User)
        private userRepository: Repository<User>,
        @InjectRepository(TestAttempt)
        private testAttemptRepository: Repository<TestAttempt>,
        @InjectRepository(Result)
        private resultRepository: Repository<Result>,
        @InjectRepository(Test)
        private testRepository: Repository<Test>,
        @Inject(CACHE_MANAGER)
        private cacheManager: Cache,
    ) {}

    async getUserAnalytics(userId: string): Promise<UserAnalyticsResponseDto> {
        const cacheKey = `user_analytics_${userId}`;

        // Try to get from cache first
        const cachedData =
            await this.cacheManager.get<UserAnalyticsResponseDto>(cacheKey);

        if (cachedData) {
            return {
                ...cachedData,
                cached: true,
            };
        }

        // Verify user exists
        const user = await this.userRepository.findOne({
            where: { id: userId },
        });

        if (!user) {
            throw new Error(`User with ID ${userId} not found`);
        }

        // Generate fresh analytics data
        const [stats, engagement, performance] = await Promise.all([
            this.getUserStats(userId),
            this.getUserEngagement(userId, user),
            this.getUserPerformance(userId),
        ]);

        const analyticsData: UserAnalyticsResponseDto = {
            stats,
            engagement,
            performance,
            generatedAt: new Date(),
            cached: false,
        };

        // Cache the result for 45 minutes (2700 seconds)
        await this.cacheManager.set(cacheKey, analyticsData, 2700);

        return analyticsData;
    }

    private async getUserStats(userId: string): Promise<UserStatsDto> {
        // Get total test attempts
        const totalTestsAttempted = await this.testAttemptRepository.count({
            where: { userId },
        });

        // Get completed tests
        const testsCompleted = await this.testAttemptRepository.count({
            where: { userId, status: AttemptStatus.SUBMITTED },
        });

        // Calculate success rate
        const successRate =
            totalTestsAttempted > 0
                ? (testsCompleted / totalTestsAttempted) * 100
                : 0;

        // Get average score from results
        const avgScoreResult = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.userId = :userId', { userId })
            .andWhere('ta.status = :status', {
                status: AttemptStatus.SUBMITTED,
            })
            .select('AVG(r.score)', 'avgScore')
            .getRawOne();

        const averageScore = Number(avgScoreResult?.avgScore) || 0;

        // Calculate total study time (sum of all attempt durations)
        const studyTimeResult = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.userId = :userId', { userId })
            .andWhere('ta.submitTime IS NOT NULL')
            .select(
                'SUM(EXTRACT(EPOCH FROM (ta.submitTime - ta.startTime)))',
                'totalSeconds',
            )
            .getRawOne();

        const totalStudyTimeHours =
            Number(studyTimeResult?.totalSeconds || 0) / 3600;

        // Calculate average session duration
        const sessionDurations = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.userId = :userId', { userId })
            .andWhere('ta.submitTime IS NOT NULL')
            .select(
                'EXTRACT(EPOCH FROM (ta.submitTime - ta.startTime))',
                'duration',
            )
            .getRawMany();

        const averageSessionDurationMinutes =
            sessionDurations.length > 0
                ? sessionDurations.reduce(
                      (sum, session) => sum + Number(session.duration || 0),
                      0,
                  ) /
                  sessionDurations.length /
                  60
                : 0;

        // Get number of different courses engaged with
        const coursesEngaged = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .innerJoin('ta.test', 't')
            .where('ta.userId = :userId', { userId })
            .select('COUNT(DISTINCT t.courseId)', 'count')
            .getRawOne()
            .then(result => parseInt(String(result?.count)) || 0);

        // Calculate current streak (consecutive successful tests)
        const recentAttempts = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .leftJoin('ta.results', 'r')
            .where('ta.userId = :userId', { userId })
            .andWhere('ta.status = :status', {
                status: AttemptStatus.SUBMITTED,
            })
            .orderBy('ta.submitTime', 'DESC')
            .select(['ta.attemptId', 'r.passed'])
            .limit(20)
            .getMany();

        let currentStreak = 0;
        for (const attempt of recentAttempts) {
            if (attempt.results?.[0]?.passed) {
                currentStreak++;
            } else {
                break;
            }
        }

        return {
            totalTestsAttempted,
            testsCompleted,
            averageScore: Math.round(averageScore * 100) / 100,
            successRate: Math.round(successRate * 100) / 100,
            totalStudyTimeHours: Math.round(totalStudyTimeHours * 100) / 100,
            averageSessionDurationMinutes:
                Math.round(averageSessionDurationMinutes * 100) / 100,
            coursesEngaged,
            currentStreak,
        };
    }

    private async getUserEngagement(
        userId: string,
        user: User,
    ): Promise<UserEngagementDto> {
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

        // Count login sessions (distinct days with activity)
        const loginSessions = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.userId = :userId', { userId })
            .andWhere('ta.createdAt >= :thirtyDaysAgo', { thirtyDaysAgo })
            .select('COUNT(DISTINCT DATE(ta.createdAt))', 'count')
            .getRawOne()
            .then(result => parseInt(result.count) || 0);

        // Active days in last 30 days
        const activeDays = loginSessions; // Same as login sessions for now

        // Calculate engagement score based on activity frequency
        const engagementScore = Math.min(100, (activeDays / 30) * 100);

        // Get last activity
        const lastActivityResult = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.userId = :userId', { userId })
            .orderBy('ta.createdAt', 'DESC')
            .limit(1)
            .getOne();

        const lastActivity = lastActivityResult?.createdAt || user.createdAt;

        // Analyze preferred study time (hour of day with most activity)
        const hourlyActivity = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.userId = :userId', { userId })
            .select('EXTRACT(HOUR FROM ta.startTime)', 'hour')
            .addSelect('COUNT(*)', 'count')
            .groupBy('EXTRACT(HOUR FROM ta.startTime)')
            .orderBy('count', 'DESC')
            .limit(1)
            .getRawOne();

        const preferredStudyHour = hourlyActivity
            ? parseInt(hourlyActivity.hour)
            : undefined;

        // Analyze most active day of week
        const dailyActivity = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.userId = :userId', { userId })
            .select('EXTRACT(DOW FROM ta.startTime)', 'dayOfWeek')
            .addSelect('COUNT(*)', 'count')
            .groupBy('EXTRACT(DOW FROM ta.startTime)')
            .orderBy('count', 'DESC')
            .limit(1)
            .getRawOne();

        const mostActiveDayOfWeek = dailyActivity
            ? parseInt(dailyActivity.dayOfWeek)
            : undefined;

        return {
            userId,
            userName: `${user.firstName} ${user.lastName}`,
            loginSessions,
            activeDays,
            engagementScore: Math.round(engagementScore * 100) / 100,
            lastActivity,
            preferredStudyHour,
            mostActiveDayOfWeek,
        };
    }

    private async getUserPerformance(
        userId: string,
    ): Promise<UserPerformanceDto> {
        // Get recent results for trend analysis
        const recentResults = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .where('ta.userId = :userId', { userId })
            .andWhere('ta.status = :status', { status: 'submitted' })
            .orderBy('ta.submitTime', 'ASC')
            .select(['r.score', 'ta.submitTime'])
            .limit(10)
            .getMany();

        // Calculate performance trend
        let performanceTrend = 'stable';
        let improvementRate = 0;

        if (recentResults.length >= 3) {
            const firstHalf =
                recentResults
                    .slice(0, Math.floor(recentResults.length / 2))
                    .reduce((sum, r) => sum + r.score, 0) /
                Math.floor(recentResults.length / 2);
            const secondHalf =
                recentResults
                    .slice(Math.floor(recentResults.length / 2))
                    .reduce((sum, r) => sum + r.score, 0) /
                Math.ceil(recentResults.length / 2);

            improvementRate = ((secondHalf - firstHalf) / firstHalf) * 100;

            if (improvementRate > 5) {
                performanceTrend = 'improving';
            } else if (improvementRate < -5) {
                performanceTrend = 'declining';
            }
        }

        // Find strongest and weakest subjects (by course)
        const coursePerformance = await this.resultRepository
            .createQueryBuilder('r')
            .innerJoin('r.attempt', 'ta')
            .innerJoin('ta.test', 't')
            .innerJoin('t.course', 'c')
            .where('ta.userId = :userId', { userId })
            .andWhere('ta.status = :status', { status: 'submitted' })
            .select('c.title', 'courseTitle')
            .addSelect('AVG(r.score)', 'avgScore')
            .addSelect('COUNT(*)', 'testCount')
            .groupBy('c.courseId, c.title')
            .having('COUNT(*) >= 2') // At least 2 tests for statistical relevance
            .orderBy('avgScore', 'DESC')
            .getRawMany();

        const strongestSubject =
            coursePerformance.length > 0
                ? coursePerformance[0].courseTitle
                : undefined;
        const weakestSubject =
            coursePerformance.length > 1
                ? coursePerformance[coursePerformance.length - 1].courseTitle
                : undefined;

        // Calculate average attempts to success
        const attemptsToSuccess = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .innerJoin('ta.results', 'r')
            .where('ta.userId = :userId', { userId })
            .andWhere('r.passed = true')
            .select('ta.testId')
            .addSelect('MIN(ta.attemptNumber)', 'attemptsNeeded')
            .groupBy('ta.testId')
            .getRawMany();

        const averageAttemptsToSuccess =
            attemptsToSuccess.length > 0
                ? attemptsToSuccess.reduce(
                      (sum, test) => sum + test.attemptsNeeded,
                      0,
                  ) / attemptsToSuccess.length
                : 0;

        // Calculate first attempt success rate
        const firstAttempts = await this.testAttemptRepository.count({
            where: {
                userId,
                attemptNumber: 1,
                status: AttemptStatus.SUBMITTED,
            },
        });

        const firstAttemptSuccesses = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .innerJoin('ta.results', 'r')
            .where('ta.userId = :userId', { userId })
            .andWhere('ta.attemptNumber = 1')
            .andWhere('ta.status = :status', { status: 'submitted' })
            .andWhere('r.passed = true')
            .getCount();

        const firstAttemptSuccessRate =
            firstAttempts > 0
                ? (firstAttemptSuccesses / firstAttempts) * 100
                : 0;

        // Calculate time efficiency score (based on completion time vs average)
        const userAvgTime = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.userId = :userId', { userId })
            .andWhere('ta.submitTime IS NOT NULL')
            .select(
                'AVG(EXTRACT(EPOCH FROM (ta.submitTime - ta.startTime)))',
                'avgTime',
            )
            .getRawOne();

        const globalAvgTime = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.submitTime IS NOT NULL')
            .select(
                'AVG(EXTRACT(EPOCH FROM (ta.submitTime - ta.startTime)))',
                'avgTime',
            )
            .getRawOne();

        const timeEfficiencyScore =
            userAvgTime?.avgTime && globalAvgTime?.avgTime
                ? Math.min(
                      100,
                      100 -
                          ((userAvgTime.avgTime - globalAvgTime.avgTime) /
                              globalAvgTime.avgTime) *
                              100,
                  )
                : 50; // Default neutral score

        return {
            performanceTrend,
            improvementRate: Math.round(improvementRate * 100) / 100,
            strongestSubject,
            weakestSubject,
            averageAttemptsToSuccess:
                Math.round(averageAttemptsToSuccess * 100) / 100,
            firstAttemptSuccessRate:
                Math.round(firstAttemptSuccessRate * 100) / 100,
            timeEfficiencyScore: Math.max(
                0,
                Math.round(timeEfficiencyScore * 100) / 100,
            ),
        };
    }

    async getGlobalUserStats(): Promise<GlobalUserStatsDto> {
        const cacheKey = 'global_user_stats';

        const cachedData =
            await this.cacheManager.get<GlobalUserStatsDto>(cacheKey);
        if (cachedData) {
            return cachedData;
        }

        const now = new Date();
        const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        const oneMonthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

        // Total users
        const totalUsers = await this.userRepository.count();

        // Daily active users (users with test attempts in last 24 hours)
        const dailyActiveUsers = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.createdAt >= :oneDayAgo', { oneDayAgo })
            .select('COUNT(DISTINCT ta.userId)', 'count')
            .getRawOne()
            .then(result => parseInt(result.count) || 0);

        // Weekly active users
        const weeklyActiveUsers = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.createdAt >= :oneWeekAgo', { oneWeekAgo })
            .select('COUNT(DISTINCT ta.userId)', 'count')
            .getRawOne()
            .then(result => parseInt(result.count) || 0);

        // Monthly active users
        const monthlyActiveUsers = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.createdAt >= :oneMonthAgo', { oneMonthAgo })
            .select('COUNT(DISTINCT ta.userId)', 'count')
            .getRawOne()
            .then(result => parseInt(result.count) || 0);

        // New users this week
        const newUsersThisWeek = await this.userRepository.count({
            where: {
                createdAt: oneWeekAgo,
            },
        });

        // Average session duration
        const avgSessionResult = await this.testAttemptRepository
            .createQueryBuilder('ta')
            .where('ta.submitTime IS NOT NULL')
            .select(
                'AVG(EXTRACT(EPOCH FROM (ta.submitTime - ta.startTime)))',
                'avgSeconds',
            )
            .getRawOne();

        const averageSessionDuration = (avgSessionResult?.avgSeconds || 0) / 60; // Convert to minutes

        // User retention rate (users active in last 30 days / total users)
        const retentionRate =
            totalUsers > 0 ? (monthlyActiveUsers / totalUsers) * 100 : 0;

        const globalStats: GlobalUserStatsDto = {
            totalUsers,
            dailyActiveUsers,
            weeklyActiveUsers,
            monthlyActiveUsers,
            newUsersThisWeek,
            averageSessionDuration:
                Math.round(averageSessionDuration * 100) / 100,
            retentionRate: Math.round(retentionRate * 100) / 100,
        };

        // Cache for 2 hours
        await this.cacheManager.set(cacheKey, globalStats, 7200);

        return globalStats;
    }

    async getUserRegistrationTrends(): Promise<any> {
        const cacheKey = 'user_registration_trends';

        const cachedData = await this.cacheManager.get(cacheKey);
        if (cachedData) {
            return cachedData;
        }

        // Get registration trends over the last 30 days
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

        const registrationData = await this.userRepository
            .createQueryBuilder('u')
            .where('u.createdAt >= :thirtyDaysAgo', { thirtyDaysAgo })
            .select('DATE(u.createdAt)', 'date')
            .addSelect('COUNT(*)', 'newRegistrations')
            .groupBy('DATE(u.createdAt)')
            .orderBy('date', 'ASC')
            .getRawMany();

        // Cache for 1 hour
        await this.cacheManager.set(cacheKey, registrationData, 3600);

        return registrationData;
    }
}

/*
 * Class #221: CreateResultDto
 * Source: results/dto/create-result.dto.ts:10
 * Type: Exported Class
 * Methods: 0
 * Properties: 13
 * Decorators: 19
 * Complexity: 44
 * Size: 1475 characters (70 lines)
 */
export class CreateResultDto {
    @ApiProperty({
        description: 'Test attempt ID this result belongs to',
        example: 1,
    })
    @IsNumber()
    attemptId: number;

    @ApiProperty({
        description: 'User ID who took the test',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @IsUUID()
    userId: string;

    @ApiProperty({
        description: 'Test ID for this result',
        example: 1,
    })
    @IsNumber()
    testId: number;

    @ApiProperty({
        description: 'Course ID for this result',
        example: 1,
    })
    @IsNumber()
    courseId: number;

    @ApiProperty({
        description: 'Total score achieved',
        example: 85.5,
        minimum: 0,
    })
    @IsNumber()
    score: number;

    @ApiProperty({
        description: 'Maximum possible score for the test',
        example: 100,
        minimum: 0,
    })
    @IsNumber()
    maxScore: number;

    @ApiProperty({
        description: 'Percentage score (0-100)',
        example: 85.5,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    percentage: number;

    @ApiProperty({
        description: 'Whether the student passed the test',
        example: true,
    })
    @IsBoolean()
    passed: boolean;

    @ApiProperty({
        description: 'When the result was calculated',
        example: '2024-01-01T11:00:00.000Z',
        required: false,
    })
    @IsOptional()
    @IsDateString()
    calculatedAt?: Date;
}

/*
 * Class #222: ResultAnalyticsDto
 * Source: results/dto/result-analytics.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 10
 * Decorators: 20
 * Complexity: 41
 * Size: 1686 characters (83 lines)
 */
export class ResultAnalyticsDto {
    @ApiProperty({
        description: 'Total number of results',
        example: 150,
    })
    @Expose()
    totalResults: number;

    @ApiProperty({
        description: 'Average percentage score',
        example: 78.5,
    })
    @Expose()
    averagePercentage: number;

    @ApiProperty({
        description: 'Average raw score',
        example: 82.3,
    })
    @Expose()
    averageScore: number;

    @ApiProperty({
        description: 'Highest percentage score',
        example: 98.5,
    })
    @Expose()
    highestPercentage: number;

    @ApiProperty({
        description: 'Lowest percentage score',
        example: 45.2,
    })
    @Expose()
    lowestPercentage: number;

    @ApiProperty({
        description: 'Number of passed results',
        example: 120,
    })
    @Expose()
    passedCount: number;

    @ApiProperty({
        description: 'Number of failed results',
        example: 30,
    })
    @Expose()
    failedCount: number;

    @ApiProperty({
        description: 'Pass rate percentage',
        example: 80,
    })
    @Expose()
    passRate: number;

    @ApiProperty({
        description: 'Score distribution by ranges',
        example: {
            '0-20': 5,
            '21-40': 10,
            '41-60': 25,
            '61-80': 50,
            '81-100': 60,
        },
    })
    @Expose()
    scoreDistribution: Record<string, number>;

    @ApiProperty({
        description: 'Grade distribution',
        example: {
            A: 30,
            B: 40,
            C: 35,
            D: 20,
            F: 25,
        },
    })
    @Expose()
    gradeDistribution: Record<string, number>;
}

/*
 * Class #223: TestDetailDto
 * Source: results/dto/result-detail.dto.ts:11
 * Type: Exported Class
 * Methods: 0
 * Properties: 6
 * Decorators: 12
 * Complexity: 25
 * Size: 909 characters (44 lines)
 */
export class TestDetailDto {
    @ApiProperty({
        description: 'Test ID',
        example: 1,
    })
    @IsNumber()
    testId: number;

    @ApiProperty({
        description: 'Test title',
        example: 'JavaScript Fundamentals Quiz',
    })
    @IsString()
    title: string;

    @ApiProperty({
        description: 'Test description',
        example: 'A comprehensive quiz covering JavaScript basics',
    })
    @IsString()
    description: string;

    @ApiProperty({
        description: 'Test type',
        example: 'quiz',
        enum: ['exam', 'quiz', 'training'],
    })
    @IsString()
    testType: string;

    @ApiProperty({
        description: 'Duration in minutes',
        example: 60,
    })
    @IsNumber()
    durationMinutes: number;

    @ApiProperty({
        description: 'Maximum attempts allowed',
        example: 3,
    })
    @IsNumber()
    maxAttempts: number;
}

/*
 * Class #224: CourseDetailDto
 * Source: results/dto/result-detail.dto.ts:56
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 8
 * Complexity: 17
 * Size: 646 characters (30 lines)
 */
export class CourseDetailDto {
    @ApiProperty({
        description: 'Course ID',
        example: 1,
    })
    @IsNumber()
    courseId: number;

    @ApiProperty({
        description: 'Course title',
        example: 'Web Development Bootcamp',
    })
    @IsString()
    title: string;

    @ApiProperty({
        description: 'Course description',
        example:
            'Complete web development course covering frontend and backend',
    })
    @IsString()
    description: string;

    @ApiProperty({
        description: 'Course creator name',
        example: 'Dr. Jane Smith',
    })
    @IsString()
    creatorName: string;
}

/*
 * Class #225: UserDetailDto
 * Source: results/dto/result-detail.dto.ts:87
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 8
 * Complexity: 18
 * Size: 550 characters (29 lines)
 */
export class UserDetailDto {
    @ApiProperty({
        description: 'User ID',
        example: 'user-123',
    })
    @IsString()
    userId: string;

    @ApiProperty({
        description: 'User first name',
        example: 'John',
    })
    @IsString()
    firstName: string;

    @ApiProperty({
        description: 'User last name',
        example: 'Doe',
    })
    @IsString()
    lastName: string;

    @ApiProperty({
        description: 'User email',
        example: 'john.doe@example.com',
    })
    @IsString()
    email: string;
}

/*
 * Class #226: AttemptDetailDto
 * Source: results/dto/result-detail.dto.ts:117
 * Type: Exported Class
 * Methods: 0
 * Properties: 12
 * Decorators: 14
 * Complexity: 30
 * Size: 974 characters (46 lines)
 */
export class AttemptDetailDto {
    @ApiProperty({
        description: 'Attempt ID',
        example: 1,
    })
    @IsNumber()
    attemptId: number;

    @ApiProperty({
        description: 'Attempt number (1st, 2nd, etc.)',
        example: 2,
    })
    @IsNumber()
    attemptNumber: number;

    @ApiProperty({
        description: 'Attempt start time',
        example: '2024-01-15T10:00:00.000Z',
    })
    @IsDate()
    @Type(() => Date)
    startTime: Date;

    @ApiProperty({
        description: 'Attempt end time',
        example: '2024-01-15T11:30:00.000Z',
    })
    @IsDate()
    @Type(() => Date)
    endTime: Date;

    @ApiProperty({
        description: 'Time spent in minutes',
        example: 90,
    })
    @IsNumber()
    timeSpent: number;

    @ApiProperty({
        description: 'Attempt status',
        example: 'completed',
        enum: ['in_progress', 'completed', 'submitted', 'timed_out'],
    })
    @IsString()
    status: string;
}

/*
 * Class #227: ResultDetailDto
 * Source: results/dto/result-detail.dto.ts:164
 * Type: Exported Class
 * Methods: 0
 * Properties: 33
 * Decorators: 39
 * Complexity: 82
 * Size: 2576 characters (121 lines)
 */
export class ResultDetailDto {
    @ApiProperty({
        description: 'Result ID',
        example: 1,
    })
    @IsNumber()
    resultId: number;

    @ApiProperty({
        description: 'Score achieved',
        example: 85,
    })
    @IsNumber()
    score: number;

    @ApiProperty({
        description: 'Maximum possible score',
        example: 100,
    })
    @IsNumber()
    maxScore: number;

    @ApiProperty({
        description: 'Percentage score',
        example: 85.0,
    })
    @IsNumber()
    percentage: number;

    @ApiProperty({
        description: 'Whether the test was passed',
        example: true,
    })
    @IsBoolean()
    passed: boolean;

    @ApiProperty({
        description: 'Test completion date',
        example: '2024-01-15T11:30:00.000Z',
    })
    @IsDate()
    @Type(() => Date)
    completedAt: Date;

    @ApiProperty({
        description: 'Result creation date',
        example: '2024-01-15T11:35:00.000Z',
    })
    @IsDate()
    @Type(() => Date)
    createdAt: Date;

    @ApiProperty({
        description: 'Last update date',
        example: '2024-01-15T11:35:00.000Z',
    })
    @IsDate()
    @Type(() => Date)
    updatedAt: Date;

    @ApiProperty({
        description: 'Test details',
        type: TestDetailDto,
    })
    @ValidateNested()
    @Type(() => TestDetailDto)
    test: TestDetailDto;

    @ApiProperty({
        description: 'Course details',
        type: CourseDetailDto,
    })
    @ValidateNested()
    @Type(() => CourseDetailDto)
    course: CourseDetailDto;

    @ApiProperty({
        description: 'User details',
        type: UserDetailDto,
    })
    @ValidateNested()
    @Type(() => UserDetailDto)
    user: UserDetailDto;

    @ApiProperty({
        description: 'Attempt details',
        type: AttemptDetailDto,
    })
    @ValidateNested()
    @Type(() => AttemptDetailDto)
    attempt: AttemptDetailDto;

    @ApiProperty({
        description: 'Rank among all students for this test',
        example: 5,
    })
    @IsNumber()
    rank: number;

    @ApiProperty({
        description: 'Percentile rank',
        example: 78.5,
    })
    @IsNumber()
    percentileRank: number;

    @ApiProperty({
        description: 'Average score for this test',
        example: 72.5,
    })
    @IsNumber()
    testAverage: number;

    @ApiProperty({
        description: 'Performance compared to average (above/below/average)',
        example: 'above',
        enum: ['well_above', 'above', 'average', 'below', 'well_below'],
    })
    @IsString()
    performanceLevel: string;
}

/*
 * Class #228: ResultFilterDto
 * Source: results/dto/result-filter.dto.ts:12
 * Type: Exported Class
 * Methods: 0
 * Properties: 33
 * Decorators: 43
 * Complexity: 108
 * Size: 2725 characters (113 lines)
 */
export class ResultFilterDto {
    @ApiPropertyOptional({
        description: 'Filter by user ID',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @IsOptional()
    @IsUUID()
    userId?: string;

    @ApiPropertyOptional({
        description: 'Filter by test ID',
        example: 1,
    })
    @IsOptional()
    @Transform(({ value }) => parseInt(value))
    @IsNumber()
    testId?: number;

    @ApiPropertyOptional({
        description: 'Filter by course ID',
        example: 1,
    })
    @IsOptional()
    @Transform(({ value }) => parseInt(value))
    @IsNumber()
    courseId?: number;

    @ApiPropertyOptional({
        description: 'Filter by pass status',
        example: true,
    })
    @IsOptional()
    @Transform(({ value }) => value === 'true')
    @IsBoolean()
    passed?: boolean;

    @ApiPropertyOptional({
        description: 'Minimum percentage score',
        example: 70,
        minimum: 0,
        maximum: 100,
    })
    @IsOptional()
    @Transform(({ value }) => parseFloat(value))
    @IsNumber()
    minPercentage?: number;

    @ApiPropertyOptional({
        description: 'Maximum percentage score',
        example: 100,
        minimum: 0,
        maximum: 100,
    })
    @IsOptional()
    @Transform(({ value }) => parseFloat(value))
    @IsNumber()
    maxPercentage?: number;

    @ApiPropertyOptional({
        description: 'Start date for filtering results',
        example: '2024-01-01T00:00:00.000Z',
    })
    @IsOptional()
    @IsDateString()
    startDate?: string;

    @ApiPropertyOptional({
        description: 'End date for filtering results',
        example: '2024-12-31T23:59:59.999Z',
    })
    @IsOptional()
    @IsDateString()
    endDate?: string;

    @ApiPropertyOptional({
        description: 'Page number for pagination',
        example: 1,
        minimum: 1,
    })
    @IsOptional()
    @Transform(({ value }) => parseInt(value))
    @IsNumber()
    page?: number = 1;

    @ApiPropertyOptional({
        description: 'Number of items per page',
        example: 10,
        minimum: 1,
        maximum: 100,
    })
    @IsOptional()
    @Transform(({ value }) => parseInt(value))
    @IsNumber()
    limit?: number = 10;

    @ApiPropertyOptional({
        description: 'Sort field',
        enum: ['percentage', 'score', 'calculatedAt', 'createdAt'],
        example: 'percentage',
    })
    @IsOptional()
    @IsEnum(['percentage', 'score', 'calculatedAt', 'createdAt'])
    sortBy?: string = 'createdAt';

    @ApiPropertyOptional({
        description: 'Sort order',
        enum: ['ASC', 'DESC'],
        example: 'DESC',
    })
    @IsOptional()
    @IsEnum(['ASC', 'DESC'])
    sortOrder?: 'ASC' | 'DESC' = 'DESC';
}

/*
 * Class #229: ResultListSummaryDto
 * Source: results/dto/result-list-response.dto.ts:6
 * Type: Exported Class
 * Methods: 0
 * Properties: 8
 * Decorators: 16
 * Complexity: 33
 * Size: 1166 characters (57 lines)
 */
export class ResultListSummaryDto {
    @ApiProperty({
        description: 'Total number of results',
        example: 150,
    })
    @IsNumber()
    totalResults: number;

    @ApiProperty({
        description: 'Average score across all results',
        example: 85.5,
    })
    @IsNumber()
    averageScore: number;

    @ApiProperty({
        description: 'Average percentage across all results',
        example: 78.2,
    })
    @IsNumber()
    averagePercentage: number;

    @ApiProperty({
        description: 'Number of passed results',
        example: 120,
    })
    @IsNumber()
    passedCount: number;

    @ApiProperty({
        description: 'Number of failed results',
        example: 30,
    })
    @IsNumber()
    failedCount: number;

    @ApiProperty({
        description: 'Pass rate percentage',
        example: 80.0,
    })
    @IsNumber()
    passRate: number;

    @ApiProperty({
        description: 'Highest score achieved',
        example: 100,
    })
    @IsNumber()
    highestScore: number;

    @ApiProperty({
        description: 'Lowest score achieved',
        example: 45,
    })
    @IsNumber()
    lowestScore: number;
}

/*
 * Class #230: ResultListResponseDto
 * Source: results/dto/result-list-response.dto.ts:64
 * Type: Exported Class
 * Methods: 0
 * Properties: 15
 * Decorators: 16
 * Complexity: 35
 * Size: 1273 characters (57 lines)
 */
export class ResultListResponseDto {
    @ApiProperty({
        description: 'Array of result objects',
        type: [ResultResponseDto],
    })
    @ValidateNested({ each: true })
    @Type(() => ResultResponseDto)
    results: ResultResponseDto[];

    @ApiProperty({
        description: 'Summary statistics for the results',
        type: ResultListSummaryDto,
    })
    @ValidateNested()
    @Type(() => ResultListSummaryDto)
    summary: ResultListSummaryDto;

    @ApiProperty({
        description: 'Total number of results (before pagination)',
        example: 150,
    })
    @IsNumber()
    total: number;

    @ApiProperty({
        description: 'Current page number',
        example: 1,
    })
    @IsNumber()
    page: number;

    @ApiProperty({
        description: 'Number of results per page',
        example: 10,
    })
    @IsNumber()
    limit: number;

    @ApiProperty({
        description: 'Total number of pages',
        example: 15,
    })
    @IsNumber()
    totalPages: number;

    @ApiProperty({
        description: 'Whether there is a next page',
        example: true,
    })
    hasNext: boolean;

    @ApiProperty({
        description: 'Whether there is a previous page',
        example: false,
    })
    hasPrevious: boolean;
}

/*
 * Class #231: UserInfo
 * Source: results/dto/result-response.dto.ts:4
 * Type: Internal Class
 * Methods: 0
 * Properties: 3
 * Decorators: 6
 * Complexity: 13
 * Size: 418 characters (22 lines)
 */
class UserInfo {
    @ApiProperty({
        description: 'User ID',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @Expose()
    id: string;

    @ApiProperty({
        description: 'Username',
        example: 'johndoe',
    })
    @Expose()
    username: string;

    @ApiProperty({
        description: 'User full name',
        example: 'John Doe',
    })
    @Expose()
    fullName: string;
}

/*
 * Class #232: TestInfo
 * Source: results/dto/result-response.dto.ts:27
 * Type: Internal Class
 * Methods: 0
 * Properties: 4
 * Decorators: 8
 * Complexity: 17
 * Size: 572 characters (30 lines)
 */
class TestInfo {
    @ApiProperty({
        description: 'Test ID',
        example: 1,
    })
    @Expose()
    testId: number;

    @ApiProperty({
        description: 'Test title',
        example: 'Advanced Mathematics Quiz',
    })
    @Expose()
    title: string;

    @ApiProperty({
        description: 'Test type',
        enum: ['exam', 'quiz', 'training'],
        example: 'quiz',
    })
    @Expose()
    testType: string;

    @ApiProperty({
        description: 'Duration in minutes',
        example: 60,
    })
    @Expose()
    durationMinutes: number;
}

/*
 * Class #233: CourseInfo
 * Source: results/dto/result-response.dto.ts:58
 * Type: Internal Class
 * Methods: 0
 * Properties: 3
 * Decorators: 6
 * Complexity: 13
 * Size: 461 characters (22 lines)
 */
class CourseInfo {
    @ApiProperty({
        description: 'Course ID',
        example: 1,
    })
    @Expose()
    courseId: number;

    @ApiProperty({
        description: 'Course title',
        example: 'Advanced Mathematics',
    })
    @Expose()
    title: string;

    @ApiProperty({
        description: 'Course description',
        example: 'Advanced mathematics course covering calculus and algebra',
    })
    @Expose()
    description: string;
}

/*
 * Class #234: AttemptInfo
 * Source: results/dto/result-response.dto.ts:81
 * Type: Internal Class
 * Methods: 0
 * Properties: 4
 * Decorators: 8
 * Complexity: 17
 * Size: 546 characters (29 lines)
 */
class AttemptInfo {
    @ApiProperty({
        description: 'Attempt ID',
        example: 1,
    })
    @Expose()
    attemptId: number;

    @ApiProperty({
        description: 'Attempt number',
        example: 2,
    })
    @Expose()
    attemptNumber: number;

    @ApiProperty({
        description: 'Start time',
        example: '2024-01-01T10:00:00.000Z',
    })
    @Expose()
    startTime: Date;

    @ApiProperty({
        description: 'End time',
        example: '2024-01-01T11:00:00.000Z',
    })
    @Expose()
    endTime: Date;
}

/*
 * Class #235: ResultResponseDto
 * Source: results/dto/result-response.dto.ts:111
 * Type: Exported Class
 * Methods: 0
 * Properties: 20
 * Decorators: 32
 * Complexity: 69
 * Size: 2385 characters (117 lines)
 */
export class ResultResponseDto {
    @ApiProperty({
        description: 'Result unique identifier',
        example: 1,
    })
    @Expose()
    resultId: number;

    @ApiProperty({
        description: 'Test attempt ID this result belongs to',
        example: 1,
    })
    @Expose()
    attemptId: number;

    @ApiProperty({
        description: 'User ID who took the test',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @Expose()
    userId: string;

    @ApiProperty({
        description: 'Test ID for this result',
        example: 1,
    })
    @Expose()
    testId: number;

    @ApiProperty({
        description: 'Course ID for this result',
        example: 1,
    })
    @Expose()
    courseId: number;

    @ApiProperty({
        description: 'Total score achieved',
        example: 85.5,
        minimum: 0,
    })
    @Expose()
    score: number;

    @ApiProperty({
        description: 'Maximum possible score for the test',
        example: 100,
        minimum: 0,
    })
    @Expose()
    maxScore: number;

    @ApiProperty({
        description: 'Percentage score (0-100)',
        example: 85.5,
        minimum: 0,
        maximum: 100,
    })
    @Expose()
    percentage: number;

    @ApiProperty({
        description: 'Whether the student passed the test',
        example: true,
    })
    @Expose()
    passed: boolean;

    @ApiProperty({
        description: 'When the result was calculated',
        example: '2024-01-01T11:00:00.000Z',
    })
    @Expose()
    calculatedAt: Date;

    @ApiProperty({
        description: 'Result creation timestamp',
        example: '2024-01-01T11:00:00.000Z',
    })
    @Expose()
    createdAt: Date;

    @ApiProperty({
        description: 'Result last update timestamp',
        example: '2024-01-01T11:00:00.000Z',
    })
    @Expose()
    updatedAt: Date;

    @ApiProperty({
        description: 'User information',
        type: UserInfo,
    })
    @Expose()
    user: UserInfo;

    @ApiProperty({
        description: 'Test information',
        type: TestInfo,
    })
    @Expose()
    test: TestInfo;

    @ApiProperty({
        description: 'Course information',
        type: CourseInfo,
    })
    @Expose()
    course: CourseInfo;

    @ApiProperty({
        description: 'Attempt information',
        type: AttemptInfo,
    })
    @Expose()
    attempt: AttemptInfo;
}

/*
 * Class #236: ScoreDistributionDto
 * Source: results/dto/result-stats.dto.ts:5
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 5
 * Complexity: 12
 * Size: 443 characters (21 lines)
 */
export class ScoreDistributionDto {
    @ApiProperty({
        description: 'Score range (e.g., "90-100")',
        example: '90-100',
    })
    range: string;

    @ApiProperty({
        description: 'Number of results in this range',
        example: 12,
    })
    @IsNumber()
    count: number;

    @ApiProperty({
        description: 'Percentage of total results',
        example: 28.5,
    })
    @IsNumber()
    percentage: number;
}

/*
 * Class #237: PerformanceTrendDto
 * Source: results/dto/result-stats.dto.ts:27
 * Type: Exported Class
 * Methods: 0
 * Properties: 4
 * Decorators: 7
 * Complexity: 17
 * Size: 592 characters (28 lines)
 */
export class PerformanceTrendDto {
    @ApiProperty({
        description: 'Date/period identifier',
        example: '2024-01-15',
    })
    period: string;

    @ApiProperty({
        description: 'Average score for this period',
        example: 78.5,
    })
    @IsNumber()
    averageScore: number;

    @ApiProperty({
        description: 'Number of attempts in this period',
        example: 15,
    })
    @IsNumber()
    attemptCount: number;

    @ApiProperty({
        description: 'Pass rate for this period',
        example: 73.3,
    })
    @IsNumber()
    passRate: number;
}

/*
 * Class #238: QuestionPerformanceDto
 * Source: results/dto/result-stats.dto.ts:56
 * Type: Exported Class
 * Methods: 0
 * Properties: 10
 * Decorators: 11
 * Complexity: 27
 * Size: 946 characters (42 lines)
 */
export class QuestionPerformanceDto {
    @ApiProperty({
        description: 'Question ID',
        example: 1,
    })
    @IsNumber()
    questionId: number;

    @ApiProperty({
        description: 'Question text (truncated)',
        example: 'What is the difference between let and var in JavaScript?',
    })
    questionText: string;

    @ApiProperty({
        description: 'Average score for this question',
        example: 85.2,
    })
    @IsNumber()
    averageScore: number;

    @ApiProperty({
        description: 'Percentage of correct answers',
        example: 78.5,
    })
    @IsNumber()
    correctPercentage: number;

    @ApiProperty({
        description: 'Number of times attempted',
        example: 42,
    })
    @IsNumber()
    attemptCount: number;

    @ApiProperty({
        description: 'Difficulty rating (1-5, based on performance)',
        example: 3.2,
    })
    @IsNumber()
    difficultyRating: number;
}

/*
 * Class #239: ResultStatsDto
 * Source: results/dto/result-stats.dto.ts:99
 * Type: Exported Class
 * Methods: 0
 * Properties: 24
 * Decorators: 28
 * Complexity: 60
 * Size: 2034 characters (84 lines)
 */
export class ResultStatsDto {
    @ApiProperty({
        description: 'Test ID these stats are for',
        example: 1,
    })
    @IsNumber()
    testId: number;

    @ApiProperty({
        description: 'Score distribution breakdown',
        type: [ScoreDistributionDto],
    })
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => ScoreDistributionDto)
    scoreDistribution: ScoreDistributionDto[];

    @ApiProperty({
        description: 'Performance trends over time',
        type: [PerformanceTrendDto],
    })
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => PerformanceTrendDto)
    performanceTrends: PerformanceTrendDto[];

    @ApiProperty({
        description: 'Question-by-question performance analysis',
        type: [QuestionPerformanceDto],
    })
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => QuestionPerformanceDto)
    questionPerformance: QuestionPerformanceDto[];

    @ApiProperty({
        description: 'Overall difficulty score (1-5)',
        example: 3.2,
    })
    @IsNumber()
    overallDifficulty: number;

    @ApiProperty({
        description: "Reliability coefficient (Cronbach's alpha)",
        example: 0.85,
    })
    @IsNumber()
    reliability: number;

    @ApiProperty({
        description: 'Discrimination index',
        example: 0.72,
    })
    @IsNumber()
    discriminationIndex: number;

    @ApiProperty({
        description: 'Average completion time in minutes',
        example: 42.5,
    })
    @IsNumber()
    averageCompletionTime: number;

    @ApiProperty({
        description: 'Fastest completion time in minutes',
        example: 18.5,
    })
    @IsNumber()
    fastestCompletion: number;

    @ApiProperty({
        description: 'Slowest completion time in minutes',
        example: 75.0,
    })
    @IsNumber()
    slowestCompletion: number;

    @ApiProperty({
        description: 'Standard deviation of completion times',
        example: 12.8,
    })
    @IsNumber()
    timeStandardDeviation: number;
}

/*
 * Class #240: ResultSummaryDto
 * Source: results/dto/result-summary.dto.ts:5
 * Type: Exported Class
 * Methods: 0
 * Properties: 28
 * Decorators: 43
 * Complexity: 88
 * Size: 2929 characters (144 lines)
 */
export class ResultSummaryDto {
    @ApiProperty({
        description: 'Test ID',
        example: 1,
    })
    @IsNumber()
    testId: number;

    @ApiProperty({
        description: 'Test title',
        example: 'JavaScript Fundamentals Quiz',
    })
    @IsString()
    testTitle: string;

    @ApiProperty({
        description: 'Course ID',
        example: 1,
    })
    @IsNumber()
    courseId: number;

    @ApiProperty({
        description: 'Course title',
        example: 'Web Development Bootcamp',
    })
    @IsString()
    courseTitle: string;

    @ApiProperty({
        description: 'Total number of attempts',
        example: 45,
    })
    @IsNumber()
    totalAttempts: number;

    @ApiProperty({
        description: 'Number of completed attempts',
        example: 42,
    })
    @IsNumber()
    completedAttempts: number;

    @ApiProperty({
        description: 'Average score',
        example: 78.5,
    })
    @IsNumber()
    averageScore: number;

    @ApiProperty({
        description: 'Average percentage',
        example: 73.2,
    })
    @IsNumber()
    averagePercentage: number;

    @ApiProperty({
        description: 'Highest score achieved',
        example: 100,
    })
    @IsNumber()
    highestScore: number;

    @ApiProperty({
        description: 'Lowest score achieved',
        example: 42,
    })
    @IsNumber()
    lowestScore: number;

    @ApiProperty({
        description: 'Number of passed attempts',
        example: 35,
    })
    @IsNumber()
    passedAttempts: number;

    @ApiProperty({
        description: 'Number of failed attempts',
        example: 7,
    })
    @IsNumber()
    failedAttempts: number;

    @ApiProperty({
        description: 'Pass rate percentage',
        example: 83.3,
    })
    @IsNumber()
    passRate: number;

    @ApiProperty({
        description: 'Median score',
        example: 76.0,
    })
    @IsNumber()
    medianScore: number;

    @ApiProperty({
        description: 'Standard deviation of scores',
        example: 12.5,
    })
    @IsNumber()
    standardDeviation: number;

    @ApiProperty({
        description: 'Number of unique students who attempted',
        example: 38,
    })
    @IsNumber()
    uniqueStudents: number;

    @ApiProperty({
        description: 'Average time spent (in minutes)',
        example: 45.5,
    })
    @IsNumber()
    averageTimeSpent: number;

    @ApiProperty({
        description: 'Date range start',
        example: '2024-01-01T00:00:00.000Z',
    })
    @IsDate()
    @Type(() => Date)
    dateRangeStart: Date;

    @ApiProperty({
        description: 'Date range end',
        example: '2024-01-31T23:59:59.999Z',
    })
    @IsDate()
    @Type(() => Date)
    dateRangeEnd: Date;

    @ApiProperty({
        description: 'Most recent attempt date',
        example: '2024-01-30T14:30:00.000Z',
    })
    @IsDate()
    @Type(() => Date)
    lastAttemptDate: Date;
}

/*
 * Class #241: UpdateResultDto
 * Source: results/dto/update-result.dto.ts:4
 * Type: Exported Class
 * Methods: 1
 * Properties: 0
 * Decorators: 0
 * Complexity: 3
 * Size: 68 characters (1 lines)
 * Extends: PartialType(CreateResultDto)
 */
export class UpdateResultDto extends PartialType(CreateResultDto) {}

/*
 * Class #242: Result
 * Source: results/entities/result.entity.ts:28
 * Type: Exported Class
 * Methods: 0
 * Properties: 35
 * Decorators: 46
 * Complexity: 100
 * Size: 3070 characters (135 lines)
 */
export class Result {
    @PrimaryGeneratedColumn()
    @ApiProperty({
        description: 'Result unique identifier',
        example: 1,
    })
    resultId: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Test attempt ID this result belongs to',
        example: 1,
    })
    @IsNumber()
    attemptId: number;

    @Column('uuid')
    @Index()
    @ApiProperty({
        description: 'User ID who took the test',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @IsUUID()
    userId: string;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Test ID for this result',
        example: 1,
    })
    @IsNumber()
    testId: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Course ID for this result',
        example: 1,
    })
    @IsNumber()
    courseId: number;

    @Column({ type: 'decimal', precision: 8, scale: 2 })
    @ApiProperty({
        description: 'Total score achieved',
        example: 85.5,
        minimum: 0,
    })
    @IsNumber()
    score: number;

    @Column({ type: 'decimal', precision: 5, scale: 2 })
    @ApiProperty({
        description: 'Percentage score (0-100)',
        example: 85.5,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    percentage: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Whether the student passed the test',
        example: true,
    })
    @IsBoolean()
    passed: boolean;

    @Column({ type: 'decimal', precision: 8, scale: 2 })
    @ApiProperty({
        description: 'Maximum possible score for the test',
        example: 100,
        minimum: 0,
    })
    @IsNumber()
    maxScore: number;

    @Column({ type: 'timestamp' })
    @ApiProperty({
        description: 'When the result was calculated',
        example: '2024-01-01T11:00:00.000Z',
    })
    @IsDateString()
    calculatedAt: Date;

    @CreateDateColumn()
    @ApiProperty({
        description: 'Result creation timestamp',
        example: '2024-01-01T11:00:00.000Z',
    })
    createdAt: Date;

    @UpdateDateColumn()
    @ApiProperty({
        description: 'Result last update timestamp',
        example: '2024-01-01T11:00:00.000Z',
    })
    updatedAt: Date;

    @ManyToOne(() => Organization, { nullable: false })
    @ApiProperty({
        description: 'Organization this result belongs to',
        type: () => Organization,
    })
    orgId: Organization;

    @ManyToOne(() => Branch, { nullable: true })
    @ApiProperty({
        description: 'Branch this result belongs to',
        type: () => Branch,
        required: false,
    })
    branchId?: Branch;

    // Relations
    @ManyToOne(() => TestAttempt, { onDelete: 'CASCADE' })
    attempt: TestAttempt;

    @ManyToOne(() => User, { onDelete: 'RESTRICT' })
    user: User;

    @ManyToOne(() => Test, { onDelete: 'RESTRICT' })
    test: Test;

    @ManyToOne(() => Course, { onDelete: 'RESTRICT' })
    course: Course;

    constructor(partial: Partial<Result>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #243: ResultsController
 * Source: results/results.controller.ts:47
 * Type: Exported Class
 * Methods: 11
 * Properties: 299
 * Decorators: 64
 * Complexity: 186
 * Size: 25867 characters (704 lines)
 */
export class ResultsController {
    private readonly logger = new Logger(ResultsController.name);

    constructor(private readonly resultsService: ResultsService) {}

    @Post('create-from-attempt/:attemptId')
    @ApiOperation({
        summary: '🎯 Create Result from Test Attempt',
        description: `
        **Automatically generates comprehensive test results from a completed attempt**
        
        This endpoint handles intelligent result calculation including:
        - Automatic score computation from answers
        - Performance analytics generation
        - Grade determination and pass/fail status
        - Statistical analysis and benchmarking
        - Achievement tracking and milestones
        
        **Smart Calculation Features:**
        - Multi-format question scoring (MCQ, text, essays)
        - Weighted scoring based on question difficulty
        - Partial credit allocation where applicable
        - Performance percentile calculations
        - Time-based performance metrics
        
        **Business Logic:**
        - Only completed attempts can generate results
        - Duplicate result prevention mechanisms
        - Automatic grade book integration
        - Learning analytics data collection
        - Achievement milestone tracking
        
        **Use Cases:**
        - Automatic grading workflows
        - Real-time performance tracking
        - Academic record maintenance
        - Learning analytics processing
        - Achievement recognition systems
        `,
        operationId: 'createResultFromAttempt',
    })
    @ApiParam({
        name: 'attemptId',
        type: Number,
        description: 'Test attempt identifier to generate results from',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description:
            '✅ Result created successfully with comprehensive analytics',
        type: ResultResponseDto,
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: {
                    type: 'string',
                    example: 'Result created successfully',
                },
                data: {
                    type: 'object',
                    properties: {
                        resultId: { type: 'number', example: 1 },
                        attemptId: { type: 'number', example: 1 },
                        userId: { type: 'string', example: 'user-123' },
                        testId: { type: 'number', example: 1 },
                        courseId: { type: 'number', example: 1 },
                        score: { type: 'number', example: 85.5 },
                        maxScore: { type: 'number', example: 100 },
                        percentage: { type: 'number', example: 85.5 },
                        passed: { type: 'boolean', example: true },
                        calculatedAt: {
                            type: 'string',
                            example: '2024-01-15T14:30:00.000Z',
                        },
                        user: {
                            type: 'object',
                            properties: {
                                id: { type: 'string', example: 'user-123' },
                                username: {
                                    type: 'string',
                                    example: 'johndoe',
                                },
                                fullName: {
                                    type: 'string',
                                    example: 'John Doe',
                                },
                            },
                        },
                    },
                },
            },
        },
    })
    @ApiUnauthorizedResponse({
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiNotFoundResponse({
        description: '❌ Test attempt not found or inaccessible',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: false },
                message: { type: 'string', example: 'Test attempt not found' },
            },
        },
    })
    @ApiBadRequestResponse({
        description:
            '❌ Attempt not completed, result already exists, or invalid data',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: {
                    type: 'array',
                    items: { type: 'string' },
                    example: [
                        'Attempt not completed',
                        'Result already exists for this attempt',
                    ],
                },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    async createFromAttempt(
        @Param('attemptId', ParseIntPipe) attemptId: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<ResultResponseDto> {
        this.logger.log(
            `Creating result from attempt: ${attemptId} by user: ${scope.userId}`,
        );

        if (!attemptId || attemptId <= 0) {
            throw new BadRequestException('Invalid attempt ID');
        }

        return this.resultsService.createFromAttempt(attemptId);
    }

    @Get('my-results')
    @ApiOperation({
        summary: '📈 Get My Test Results',
        description: `
        **Retrieves comprehensive test results for the authenticated user**
        
        This endpoint provides personalized academic performance data including:
        - Complete test results with detailed breakdowns
        - Performance trends and progress tracking
        - Achievement history and milestones
        - Comparative analytics and benchmarking
        - Learning path recommendations
        
        **Advanced Features:**
        - Multi-level filtering and sorting capabilities
        - Performance trend analysis over time
        - Subject and course-specific breakdowns
        - Achievement and badge tracking
        - Personalized learning insights
        
        **Analytics Included:**
        - Score progression and improvement rates
        - Time-to-completion analysis
        - Difficulty level performance
        - Comparative peer analysis
        - Learning velocity metrics
        
        **Use Cases:**
        - Student dashboard and progress tracking
        - Academic portfolio development
        - Performance self-assessment
        - Learning goal setting and monitoring
        - Achievement showcase and recognition
        `,
        operationId: 'getMyResults',
    })
    @ApiQuery({
        name: 'page',
        type: Number,
        required: false,
        description: 'Page number for pagination',
        example: 1,
    })
    @ApiQuery({
        name: 'limit',
        type: Number,
        required: false,
        description: 'Number of results per page (max 100)',
        example: 20,
    })
    @ApiQuery({
        name: 'testId',
        type: Number,
        required: false,
        description: 'Filter by specific test ID',
        example: 1,
    })
    @ApiQuery({
        name: 'courseId',
        type: Number,
        required: false,
        description: 'Filter by specific course ID',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ User results retrieved successfully',
        type: ResultListResponseDto,
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: {
                    type: 'string',
                    example: 'Results retrieved successfully',
                },
                data: {
                    type: 'object',
                    properties: {
                        results: {
                            type: 'array',
                            description:
                                'Array of test results with comprehensive details',
                            items: {
                                type: 'object',
                                properties: {
                                    resultId: { type: 'number', example: 1 },
                                    score: { type: 'number', example: 85.5 },
                                    percentage: {
                                        type: 'number',
                                        example: 85.5,
                                    },
                                    passed: { type: 'boolean', example: true },
                                    calculatedAt: {
                                        type: 'string',
                                        example: '2024-01-15T14:30:00.000Z',
                                    },
                                    test: {
                                        type: 'object',
                                        properties: {
                                            testId: {
                                                type: 'number',
                                                example: 1,
                                            },
                                            title: {
                                                type: 'string',
                                                example:
                                                    'JavaScript Fundamentals Quiz',
                                            },
                                            testType: {
                                                type: 'string',
                                                example: 'quiz',
                                            },
                                        },
                                    },
                                },
                            },
                        },
                        summary: {
                            type: 'object',
                            properties: {
                                totalResults: { type: 'number', example: 25 },
                                averageScore: { type: 'number', example: 82.3 },
                                passedCount: { type: 'number', example: 20 },
                                passRate: { type: 'number', example: 80.0 },
                            },
                        },
                        total: { type: 'number', example: 25 },
                        page: { type: 'number', example: 1 },
                        limit: { type: 'number', example: 20 },
                    },
                },
            },
        },
    })
    @ApiUnauthorizedResponse({
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    async getMyResults(
        @OrgBranchScope() scope: OrgBranchScope,
        @Query() filterDto: ResultFilterDto,
    ) {
        this.logger.log(`Getting results for user: ${scope.userId}`);
        return this.resultsService.findUserResults(scope.userId, filterDto);
    }

    @Get('test/:testId')
    @ApiOperation({
        summary: '📝 Get Test Results (Instructor)',
        description: `
        **Retrieves comprehensive results analytics for a specific test**
        
        This endpoint provides instructor-level analytics including:
        - Complete student performance breakdowns
        - Statistical analysis and distribution curves
        - Question-level performance insights
        - Learning objective achievement rates
        - Class performance comparisons
        
        **Instructor Analytics:**
        - Score distribution and statistical analysis
        - Question difficulty and discrimination indices
        - Time-to-completion patterns
        - Learning objective mastery rates
        - Individual and class performance trends
        
        **Access Control:**
        - Restricted to test creators and course instructors
        - Administrative override capabilities
        - Privacy-compliant data aggregation
        - Secure performance reporting
        
        **Use Cases:**
        - Test effectiveness evaluation
        - Curriculum improvement insights
        - Student performance monitoring
        - Educational research and analysis
        - Quality assurance reporting
        `,
        operationId: 'getTestResults',
    })
    @ApiParam({
        name: 'testId',
        type: Number,
        description: 'Test identifier to retrieve results analytics',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Test results retrieved successfully',
        type: ResultListResponseDto,
    })
    @ApiUnauthorizedResponse({
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiForbiddenResponse({
        description:
            '🚷 Forbidden - Not authorized to view test results (instructor access required)',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 403 },
                message: {
                    type: 'string',
                    example: 'Access denied - not test instructor',
                },
                error: { type: 'string', example: 'Forbidden' },
            },
        },
    })
    @ApiBadRequestResponse({
        description: '❌ Invalid test ID provided',
    })
    async getTestResults(
        @Param('testId', ParseIntPipe) testId: number,
        @OrgBranchScope() scope: OrgBranchScope,
        @Query() filterDto: ResultFilterDto,
    ) {
        this.logger.log(
            `Getting test results for test: ${testId} by user: ${scope.userId}`,
        );

        if (!testId || testId <= 0) {
            throw new BadRequestException('Invalid test ID');
        }

        return this.resultsService.findTestResults(
            testId,
            scope.userId,
            filterDto,
        );
    }

    @Get('course/:courseId')
    @ApiOperation({
        summary: '🎓 Get Course Results (Instructor)',
        description: `
        **Retrieves comprehensive performance analytics for an entire course**
        
        This endpoint provides course-wide analytics including:
        - Aggregated student performance across all tests
        - Learning progression and trend analysis
        - Course effectiveness metrics
        - Student engagement and participation rates
        - Curriculum success indicators
        
        **Course-Level Analytics:**
        - Multi-test performance correlation
        - Learning path effectiveness analysis
        - Student retention and success rates
        - Curriculum gap identification
        - Comparative cohort analysis
        
        **Educational Insights:**
        - Learning objective achievement tracking
        - Content difficulty optimization
        - Student support need identification
        - Instructional design effectiveness
        - Long-term learning outcome prediction
        
        **Use Cases:**
        - Course effectiveness evaluation
        - Curriculum optimization planning
        - Student intervention identification
        - Educational outcome reporting
        - Institutional analytics and accreditation
        `,
        operationId: 'getCourseResults',
    })
    @ApiParam({
        name: 'courseId',
        type: Number,
        description: 'Course identifier to retrieve comprehensive results',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course results retrieved successfully',
        type: ResultListResponseDto,
    })
    @ApiUnauthorizedResponse({
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiForbiddenResponse({
        description:
            '🚷 Forbidden - Not authorized to view course results (instructor access required)',
    })
    @ApiBadRequestResponse({
        description: '❌ Invalid course ID provided',
    })
    async getCourseResults(
        @Param('courseId', ParseIntPipe) courseId: number,
        @OrgBranchScope() scope: OrgBranchScope,
        @Query() filterDto: ResultFilterDto,
    ) {
        this.logger.log(
            `Getting course results for course: ${courseId} by user: ${scope.userId}`,
        );

        if (!courseId || courseId <= 0) {
            throw new BadRequestException('Invalid course ID');
        }

        return this.resultsService.findCourseResults(
            courseId,
            scope.userId,
            filterDto,
        );
    }

    @Get('analytics/:testId')
    @ApiOperation({
        summary: '📈 Get Test Analytics',
        description: `
        **Provides comprehensive test analytics and educational insights**
        
        This endpoint delivers advanced educational analytics including:
        - Score distribution analysis and statistical measures
        - Question performance and difficulty assessment
        - Learning objective achievement analytics
        - Time-based performance insights
        - Predictive learning analytics
        
        **Advanced Analytics Features:**
        - Statistical distribution analysis (mean, median, standard deviation)
        - Question discrimination and difficulty indices
        - Item response theory (IRT) metrics
        - Learning curve analysis and predictions
        - Comparative performance benchmarking
        
        **Educational Intelligence:**
        - Learning objective mastery assessment
        - Knowledge gap identification
        - Optimal learning path recommendations
        - Performance prediction algorithms
        - Adaptive assessment insights
        
        **Research Applications:**
        - Educational effectiveness research
        - Curriculum optimization studies
        - Learning analytics research
        - Assessment validity analysis
        - Pedagogical improvement insights
        `,
        operationId: 'getTestAnalytics',
    })
    @ApiParam({
        name: 'testId',
        type: Number,
        description: 'Test identifier for comprehensive analytics',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Test analytics retrieved successfully',
        type: ResultAnalyticsDto,
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: {
                    type: 'string',
                    example: 'Analytics retrieved successfully',
                },
                data: {
                    type: 'object',
                    properties: {
                        testId: { type: 'number', example: 1 },
                        totalResults: { type: 'number', example: 45 },
                        averagePercentage: { type: 'number', example: 78.5 },
                        highestPercentage: { type: 'number', example: 98.5 },
                        lowestPercentage: { type: 'number', example: 45.2 },
                        passedCount: { type: 'number', example: 35 },
                        passRate: { type: 'number', example: 77.8 },
                        scoreDistribution: {
                            type: 'object',
                            example: {
                                '90-100': 12,
                                '80-89': 15,
                                '70-79': 8,
                                '60-69': 6,
                                '0-59': 4,
                            },
                        },
                    },
                },
            },
        },
    })
    @ApiUnauthorizedResponse({
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiForbiddenResponse({
        description: '🚷 Forbidden - Not authorized to view test analytics',
    })
    async getTestAnalytics(
        @Param('testId', ParseIntPipe) testId: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<ResultAnalyticsDto> {
        this.logger.log(
            `Getting analytics for test: ${testId} by user: ${scope.userId}`,
        );
        return this.resultsService.getTestAnalytics(testId, scope.userId);
    }

    @Get(':id')
    @ApiOperation({
        summary: '🔍 Get Detailed Result',
        description: `
        **Retrieves comprehensive details for a specific test result**
        
        This endpoint provides complete result information including:
        - Detailed performance metrics and analytics
        - Question-by-question breakdown
        - Comparative performance context
        - Learning insights and recommendations
        - Achievement recognition data
        
        **Comprehensive Details:**
        - Complete test attempt reconstruction
        - Answer-by-answer analysis
        - Time allocation and efficiency metrics
        - Performance compared to peers and benchmarks
        - Personalized improvement recommendations
        
        **Educational Value:**
        - Learning gap identification
        - Strength and weakness analysis
        - Study recommendation generation
        - Progress tracking context
        - Achievement milestone recognition
        
        **Use Cases:**
        - Detailed performance review
        - Learning analytics deep-dive
        - Academic counseling support
        - Performance improvement planning
        - Achievement portfolio building
        `,
        operationId: 'getDetailedResult',
    })
    @ApiParam({
        name: 'id',
        type: Number,
        description: 'Result identifier for detailed information',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Detailed result retrieved successfully',
        type: ResultDetailDto,
    })
    @ApiUnauthorizedResponse({
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiNotFoundResponse({
        description: '❌ Result not found or access denied',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: false },
                message: { type: 'string', example: 'Result not found' },
            },
        },
    })
    async getResult(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<ResultResponseDto> {
        this.logger.log(`Getting result: ${id} for user: ${scope.userId}`);
        return this.resultsService.findOne(id, scope.userId);
    }

    @Post(':id/recalculate')
    @ApiOperation({
        summary: '🔄 Recalculate Result',
        description: `
        **Recalculates and updates result scores and analytics**
        
        This endpoint handles comprehensive result recalculation including:
        - Score recomputation with updated algorithms
        - Grade boundary adjustments
        - Performance metric refresh
        - Analytics data regeneration
        - Achievement status updates
        
        **Administrative Features:**
        - Manual grade corrections and adjustments
        - Algorithm updates and improvements
        - Data consistency maintenance
        - Historical correction processing
        - Audit trail maintenance
        
        **Quality Assurance:**
        - Score validation and verification
        - Grade boundary compliance
        - Performance metric accuracy
        - Analytics consistency checks
        - Student record integrity
        
        **Use Cases:**
        - Grade corrections and appeals
        - System updates and improvements
        - Data migration and cleanup
        - Quality assurance processes
        - Educational research adjustments
        `,
        operationId: 'recalculateResult',
    })
    @ApiParam({
        name: 'id',
        type: Number,
        description: 'Result identifier to recalculate',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Result recalculated successfully',
        type: ResultResponseDto,
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: {
                    type: 'string',
                    example: 'Result recalculated successfully',
                },
                data: {
                    type: 'object',
                    properties: {
                        resultId: { type: 'number', example: 1 },
                        oldScore: { type: 'number', example: 85.5 },
                        newScore: { type: 'number', example: 87.0 },
                        oldPercentage: { type: 'number', example: 85.5 },
                        newPercentage: { type: 'number', example: 87.0 },
                        recalculatedAt: {
                            type: 'string',
                            example: '2024-01-15T14:30:00.000Z',
                        },
                    },
                },
            },
        },
    })
    @ApiUnauthorizedResponse({
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiForbiddenResponse({
        description:
            '🚷 Forbidden - Not authorized to recalculate results (instructor access required)',
    })
    @ApiNotFoundResponse({
        description: '❌ Result not found',
    })
    async recalculateResult(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<ResultResponseDto> {
        this.logger.log(`Recalculating result: ${id} by user: ${scope.userId}`);
        return this.resultsService.recalculateResult(id, scope.userId);
    }
}

/*
 * Class #244: ResultsModule
 * Source: results/results.module.ts:20
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 29 characters (1 lines)
 */
export class ResultsModule {}

/*
 * Class #245: ResultsService
 * Source: results/results.service.ts:23
 * Type: Exported Class
 * Methods: 37
 * Properties: 83
 * Decorators: 4
 * Complexity: 237
 * Size: 17265 characters (521 lines)
 */
export class ResultsService {
    constructor(
        @InjectRepository(Result)
        private readonly resultRepository: Repository<Result>,
        @InjectRepository(TestAttempt)
        private readonly testAttemptRepository: Repository<TestAttempt>,
        @InjectRepository(Answer)
        private readonly answerRepository: Repository<Answer>,
        @InjectRepository(Question)
        private readonly questionRepository: Repository<Question>,
        private readonly leaderboardService: LeaderboardService,
    ) {}

    async createFromAttempt(attemptId: number): Promise<ResultResponseDto> {
        try {
            // Get the test attempt with all related data
            const attempt = await this.testAttemptRepository.findOne({
                where: { attemptId },
                relations: ['test', 'test.course', 'user'],
            });

            if (!attempt) {
                throw new NotFoundException(
                    `Test attempt with ID ${attemptId} not found`,
                );
            }

            if (attempt.status !== AttemptStatus.SUBMITTED) {
                throw new BadRequestException(
                    'Cannot create result for incomplete attempt',
                );
            }

            // Check if result already exists
            const existingResult = await this.resultRepository.findOne({
                where: { attemptId },
            });

            if (existingResult) {
                throw new BadRequestException(
                    'Result already exists for this attempt',
                );
            }

            // Calculate the score
            const { score, maxScore, percentage } =
                await this.calculateScore(attemptId);

            // Determine if passed (assuming 60% pass rate)
            const passed = percentage >= 60;

            // Create the result
            const resultData: CreateResultDto = {
                attemptId,
                userId: attempt.userId,
                testId: attempt.testId,
                courseId: attempt.test.courseId,
                score,
                maxScore,
                percentage,
                passed,
                calculatedAt: new Date(),
            };

            const result = this.resultRepository.create(resultData);
            const savedResult = await this.resultRepository.save(result);

            // Trigger leaderboard update for the course and user
            try {
                await this.leaderboardService.updateUserScore(
                    attempt.test.courseId,
                    attempt.userId,
                );
            } catch (leaderboardError) {
                // Log error but don't fail the result creation
                console.error(
                    `Failed to update leaderboard for user ${attempt.userId} in course ${attempt.test.courseId}`,
                    leaderboardError instanceof Error
                        ? leaderboardError.message
                        : leaderboardError,
                );
            }

            return this.findOne(savedResult.resultId);
        } catch (error) {
            if (
                error instanceof NotFoundException ||
                error instanceof BadRequestException
            ) {
                throw error;
            }
            throw new InternalServerErrorException(
                'Failed to create result from attempt',
            );
        }
    }

    async findUserResults(
        userId: string,
        filterDto: ResultFilterDto,
    ): Promise<{
        results: ResultResponseDto[];
        total: number;
        page: number;
        limit: number;
    }> {
        try {
            const { page = 1, limit = 10, ...filters } = filterDto;
            const skip = (page - 1) * limit;

            const queryBuilder = this.buildFilterQuery({ ...filters, userId });

            const [results, total] = await queryBuilder
                .skip(skip)
                .take(limit)
                .getManyAndCount();

            const responseResults = results.map(result =>
                plainToClass(ResultResponseDto, result, {
                    excludeExtraneousValues: true,
                }),
            );

            return {
                results: responseResults,
                total,
                page,
                limit,
            };
        } catch {
            throw new InternalServerErrorException(
                'Failed to fetch user results',
            );
        }
    }

    async findTestResults(
        testId: number,
        userId?: string,
        filterDto?: ResultFilterDto,
    ): Promise<{
        results: ResultResponseDto[];
        total: number;
        page: number;
        limit: number;
    }> {
        try {
            const { page = 1, limit = 10, ...filters } = filterDto || {};
            const skip = (page - 1) * limit;

            const queryBuilder = this.buildFilterQuery({ ...filters, testId });

            const [results, total] = await queryBuilder
                .skip(skip)
                .take(limit)
                .getManyAndCount();

            const responseResults = results.map(result =>
                plainToClass(ResultResponseDto, result, {
                    excludeExtraneousValues: true,
                }),
            );

            return {
                results: responseResults,
                total,
                page,
                limit,
            };
        } catch {
            throw new InternalServerErrorException(
                'Failed to fetch test results',
            );
        }
    }

    async findCourseResults(
        courseId: number,
        userId?: string,
        filterDto?: ResultFilterDto,
    ): Promise<{
        results: ResultResponseDto[];
        total: number;
        page: number;
        limit: number;
    }> {
        try {
            const { page = 1, limit = 10, ...filters } = filterDto || {};
            const skip = (page - 1) * limit;

            const queryBuilder = this.buildFilterQuery({
                ...filters,
                courseId,
            });

            const [results, total] = await queryBuilder
                .skip(skip)
                .take(limit)
                .getManyAndCount();

            const responseResults = results.map(result =>
                plainToClass(ResultResponseDto, result, {
                    excludeExtraneousValues: true,
                }),
            );

            return {
                results: responseResults,
                total,
                page,
                limit,
            };
        } catch {
            throw new InternalServerErrorException(
                'Failed to fetch course results',
            );
        }
    }

    async findOne(id: number, userId?: string): Promise<ResultResponseDto> {
        try {
            const queryBuilder = this.resultRepository
                .createQueryBuilder('result')
                .leftJoinAndSelect('result.user', 'user')
                .leftJoinAndSelect('result.test', 'test')
                .leftJoinAndSelect('result.course', 'course')
                .leftJoinAndSelect('result.attempt', 'attempt')
                .where('result.resultId = :id', { id });

            const result = await queryBuilder.getOne();

            if (!result) {
                throw new NotFoundException(`Result with ID ${id} not found`);
            }

            // If userId is provided, check if user can access this result
            if (userId && result.userId !== userId) {
                // Check if user is instructor of the course
                // This would require additional validation logic
                throw new ForbiddenException('Access denied to this result');
            }

            return plainToClass(ResultResponseDto, result, {
                excludeExtraneousValues: true,
            });
        } catch (error) {
            if (
                error instanceof NotFoundException ||
                error instanceof ForbiddenException
            ) {
                throw error;
            }
            throw new InternalServerErrorException('Failed to fetch result');
        }
    }

    async getTestAnalytics(
        testId: number,
        userId?: string,
    ): Promise<ResultAnalyticsDto> {
        try {
            const results = await this.resultRepository.find({
                where: { testId },
            });

            if (results.length === 0) {
                return {
                    totalResults: 0,
                    averagePercentage: 0,
                    averageScore: 0,
                    highestPercentage: 0,
                    lowestPercentage: 0,
                    passedCount: 0,
                    failedCount: 0,
                    passRate: 0,
                    scoreDistribution: {},
                    gradeDistribution: {},
                };
            }

            const totalResults = results.length;
            const averagePercentage =
                results.reduce((sum, r) => sum + Number(r.percentage), 0) /
                totalResults;
            const averageScore =
                results.reduce((sum, r) => sum + Number(r.score), 0) /
                totalResults;
            const percentages = results
                .map(r => Number(r.percentage))
                .sort((a, b) => a - b);
            const highestPercentage = percentages[percentages.length - 1];
            const lowestPercentage = percentages[0];
            const passedCount = results.filter(r => r.passed).length;
            const failedCount = totalResults - passedCount;
            const passRate = (passedCount / totalResults) * 100;

            // Score distribution
            const scoreDistribution = {
                '0-20': 0,
                '21-40': 0,
                '41-60': 0,
                '61-80': 0,
                '81-100': 0,
            };

            results.forEach(result => {
                const percentage = Number(result.percentage);
                if (percentage <= 20) scoreDistribution['0-20']++;
                else if (percentage <= 40) scoreDistribution['21-40']++;
                else if (percentage <= 60) scoreDistribution['41-60']++;
                else if (percentage <= 80) scoreDistribution['61-80']++;
                else scoreDistribution['81-100']++;
            });

            // Grade distribution
            const gradeDistribution = { A: 0, B: 0, C: 0, D: 0, F: 0 };
            results.forEach(result => {
                const percentage = Number(result.percentage);
                if (percentage >= 90) gradeDistribution.A++;
                else if (percentage >= 80) gradeDistribution.B++;
                else if (percentage >= 70) gradeDistribution.C++;
                else if (percentage >= 60) gradeDistribution.D++;
                else gradeDistribution.F++;
            });

            return {
                totalResults,
                averagePercentage: Math.round(averagePercentage * 100) / 100,
                averageScore: Math.round(averageScore * 100) / 100,
                highestPercentage,
                lowestPercentage,
                passedCount,
                failedCount,
                passRate: Math.round(passRate * 100) / 100,
                scoreDistribution,
                gradeDistribution,
            };
        } catch (error) {
            throw new InternalServerErrorException(
                'Failed to generate test analytics',
            );
        }
    }

    async recalculateResult(
        resultId: number,
        userId?: string,
    ): Promise<ResultResponseDto> {
        try {
            const result = await this.resultRepository.findOne({
                where: { resultId },
                relations: ['attempt'],
            });

            if (!result) {
                throw new NotFoundException(
                    `Result with ID ${resultId} not found`,
                );
            }

            // Recalculate score
            const { score, maxScore, percentage } = await this.calculateScore(
                result.attemptId,
            );

            // Update result
            result.score = score;
            result.maxScore = maxScore;
            result.percentage = percentage;
            result.passed = percentage >= 60;
            result.calculatedAt = new Date();

            await this.resultRepository.save(result);

            // Trigger leaderboard update for the course and user
            try {
                await this.leaderboardService.updateUserScore(
                    result.courseId,
                    result.userId,
                );
            } catch (leaderboardError) {
                // Log error but don't fail the result recalculation
                console.error(
                    `Failed to update leaderboard for user ${result.userId} in course ${result.courseId}`,
                    leaderboardError instanceof Error
                        ? leaderboardError.message
                        : leaderboardError,
                );
            }

            return this.findOne(resultId, userId);
        } catch (error) {
            if (error instanceof NotFoundException) {
                throw error;
            }
            throw new InternalServerErrorException(
                'Failed to recalculate result',
            );
        }
    }

    private async calculateScore(attemptId: number): Promise<{
        score: number;
        maxScore: number;
        percentage: number;
    }> {
        // Get all answers for the attempt
        const answers = await this.answerRepository.find({
            where: { attemptId },
            relations: ['question', 'selectedOption'],
        });

        // Get all questions for the test
        const attempt = await this.testAttemptRepository.findOne({
            where: { attemptId },
            relations: ['test'],
        });

        const questions = await this.questionRepository.find({
            where: { testId: attempt?.testId },
        });

        let totalScore = 0;
        let maxScore = 0;

        for (const question of questions) {
            maxScore += question.points;

            const answer = answers.find(
                a => a.questionId === question.questionId,
            );
            if (
                answer &&
                answer.pointsAwarded !== null &&
                answer.pointsAwarded !== undefined
            ) {
                totalScore += answer.pointsAwarded;
            } else if (answer && answer.selectedOption) {
                // Auto-calculate for objective questions
                const isCorrect = answer.selectedOption.isCorrect;
                if (isCorrect) {
                    totalScore += question.points;
                }
            }
        }

        const percentage = maxScore > 0 ? (totalScore / maxScore) * 100 : 0;

        return {
            score: totalScore,
            maxScore,
            percentage: Math.round(percentage * 100) / 100,
        };
    }

    private buildFilterQuery(
        filters: Partial<ResultFilterDto>,
    ): SelectQueryBuilder<Result> {
        const queryBuilder = this.resultRepository
            .createQueryBuilder('result')
            .leftJoinAndSelect('result.user', 'user')
            .leftJoinAndSelect('result.test', 'test')
            .leftJoinAndSelect('result.course', 'course')
            .leftJoinAndSelect('result.attempt', 'attempt');

        if (filters.userId) {
            queryBuilder.andWhere('result.userId = :userId', {
                userId: filters.userId,
            });
        }

        if (filters.testId) {
            queryBuilder.andWhere('result.testId = :testId', {
                testId: filters.testId,
            });
        }

        if (filters.courseId) {
            queryBuilder.andWhere('result.courseId = :courseId', {
                courseId: filters.courseId,
            });
        }

        if (filters.passed !== undefined) {
            queryBuilder.andWhere('result.passed = :passed', {
                passed: filters.passed,
            });
        }

        if (filters.minPercentage !== undefined) {
            queryBuilder.andWhere('result.percentage >= :minPercentage', {
                minPercentage: filters.minPercentage,
            });
        }

        if (filters.maxPercentage !== undefined) {
            queryBuilder.andWhere('result.percentage <= :maxPercentage', {
                maxPercentage: filters.maxPercentage,
            });
        }

        if (filters.startDate) {
            queryBuilder.andWhere('result.calculatedAt >= :startDate', {
                startDate: filters.startDate,
            });
        }

        if (filters.endDate) {
            queryBuilder.andWhere('result.calculatedAt <= :endDate', {
                endDate: filters.endDate,
            });
        }

        // Sorting
        const sortBy = filters.sortBy || 'createdAt';
        const sortOrder = filters.sortOrder || 'DESC';
        queryBuilder.orderBy(`result.${sortBy}`, sortOrder);

        return queryBuilder;
    }
}

/*
 * Class #246: CreateTestDto
 * Source: test/dto/create-test.dto.ts:13
 * Type: Exported Class
 * Methods: 0
 * Properties: 12
 * Decorators: 22
 * Complexity: 55
 * Size: 2593 characters (81 lines)
 */
/**
 * Data Transfer Object for creating a new test
 * Used for test creation with comprehensive validation
 */
export class CreateTestDto {
    @ApiProperty({
        description: 'Course ID that this test belongs to',
        example: 1,
        type: Number,
        title: 'Course ID',
        minimum: 1,
    })
    @IsNumber({}, { message: 'Course ID must be a valid number' })
    @IsNotEmpty({ message: 'Course ID is required' })
    @Min(1, { message: 'Course ID must be at least 1' })
    courseId: number;

    @ApiProperty({
        description: 'Test title for identification and display',
        example: 'Midterm Exam - Computer Science Fundamentals',
        type: String,
        title: 'Test Title',
        maxLength: 255,
        minLength: 3,
    })
    @IsString({ message: 'Test title must be a string' })
    @IsNotEmpty({ message: 'Test title is required' })
    @MinLength(3, { message: 'Test title must be at least 3 characters long' })
    title: string;

    @ApiProperty({
        description:
            'Test description and instructions for students taking the test',
        example:
            'This exam covers chapters 1-5 of the course material. You have 2 hours to complete all questions.',
        required: false,
        type: String,
        title: 'Test Description',
    })
    @IsOptional()
    @IsString({ message: 'Test description must be a string' })
    description?: string;

    @ApiProperty({
        description: 'Type of test determining behavior and purpose',
        example: TestType.EXAM,
        enum: TestType,
        title: 'Test Type',
    })
    @IsEnum(TestType, {
        message: 'Test type must be one of: exam, quiz, training',
    })
    @IsNotEmpty({ message: 'Test type is required' })
    testType: TestType;

    @ApiProperty({
        description: 'Test duration in minutes (leave empty for untimed tests)',
        example: 120,
        required: false,
        type: Number,
        title: 'Duration (Minutes)',
        minimum: 1,
    })
    @IsOptional()
    @IsNumber({}, { message: 'Duration must be a valid number' })
    @Min(1, { message: 'Duration must be at least 1 minute' })
    durationMinutes?: number;

    @ApiProperty({
        description: 'Maximum number of attempts allowed per user',
        example: 3,
        default: 1,
        type: Number,
        title: 'Maximum Attempts',
        minimum: 1,
    })
    @IsOptional()
    @IsNumber({}, { message: 'Maximum attempts must be a valid number' })
    @Min(1, { message: 'Maximum attempts must be at least 1' })
    maxAttempts?: number;
}

/*
 * Class #247: TestFilterDto
 * Source: test/dto/test-filter.dto.ts:15
 * Type: Exported Class
 * Methods: 0
 * Properties: 71
 * Decorators: 60
 * Complexity: 143
 * Size: 5776 characters (208 lines)
 */
/**
 * Data Transfer Object for filtering and searching tests
 * Used for advanced test queries with pagination and sorting
 */
export class TestFilterDto {
    @ApiProperty({
        description: 'Filter tests by course ID',
        example: 1,
        required: false,
        type: Number,
        minimum: 1,
    })
    @IsOptional()
    @Type(() => Number)
    @IsNumber({}, { message: 'Course ID must be a valid number' })
    @Min(1, { message: 'Course ID must be at least 1' })
    courseId?: number;

    @ApiProperty({
        description: 'Search tests by title (partial match)',
        example: 'midterm',
        required: false,
        type: String,
        maxLength: 255,
    })
    @IsOptional()
    @IsString({ message: 'Title filter must be a string' })
    title?: string;

    @ApiProperty({
        description: 'Filter tests by type',
        example: TestType.EXAM,
        required: false,
        enum: TestType,
    })
    @IsOptional()
    @IsEnum(TestType, {
        message: 'Test type must be one of: exam, quiz, training',
    })
    testType?: TestType;

    @ApiProperty({
        description: 'Filter tests by active status',
        example: true,
        required: false,
        type: Boolean,
    })
    @IsOptional()
    @Type(() => Boolean)
    @IsBoolean({ message: 'Active status must be a boolean' })
    isActive?: boolean;

    @ApiProperty({
        description: 'Filter tests created after this date (ISO string)',
        example: '2024-01-01T00:00:00.000Z',
        required: false,
        type: String,
        format: 'date-time',
    })
    @IsOptional()
    @IsDateString({}, { message: 'Created after must be a valid ISO date' })
    createdAfter?: string;

    @ApiProperty({
        description: 'Filter tests created before this date (ISO string)',
        example: '2024-12-31T23:59:59.999Z',
        required: false,
        type: String,
        format: 'date-time',
    })
    @IsOptional()
    @IsDateString({}, { message: 'Created before must be a valid ISO date' })
    createdBefore?: string;

    @ApiProperty({
        description: 'Filter tests with minimum duration (minutes)',
        example: 60,
        required: false,
        type: Number,
        minimum: 1,
    })
    @IsOptional()
    @Type(() => Number)
    @IsNumber({}, { message: 'Minimum duration must be a valid number' })
    @Min(1, { message: 'Minimum duration must be at least 1 minute' })
    minDuration?: number;

    @ApiProperty({
        description: 'Filter tests with maximum duration (minutes)',
        example: 180,
        required: false,
        type: Number,
        minimum: 1,
    })
    @IsOptional()
    @Type(() => Number)
    @IsNumber({}, { message: 'Maximum duration must be a valid number' })
    @Min(1, { message: 'Maximum duration must be at least 1 minute' })
    maxDuration?: number;

    @ApiProperty({
        description: 'Filter tests with minimum allowed attempts',
        example: 1,
        required: false,
        type: Number,
        minimum: 1,
    })
    @IsOptional()
    @Type(() => Number)
    @IsNumber({}, { message: 'Minimum attempts must be a valid number' })
    @Min(1, { message: 'Minimum attempts must be at least 1' })
    minAttempts?: number;

    @ApiProperty({
        description: 'Filter tests with maximum allowed attempts',
        example: 5,
        required: false,
        type: Number,
        minimum: 1,
    })
    @IsOptional()
    @Type(() => Number)
    @IsNumber({}, { message: 'Maximum attempts must be a valid number' })
    @Min(1, { message: 'Maximum attempts must be at least 1' })
    maxAttempts?: number;

    // Pagination parameters
    @ApiProperty({
        description: 'Page number for pagination',
        example: 1,
        default: 1,
        required: false,
        type: Number,
        minimum: 1,
    })
    @IsOptional()
    @Type(() => Number)
    @IsNumber({}, { message: 'Page must be a valid number' })
    @Min(1, { message: 'Page must be at least 1' })
    page?: number = 1;

    @ApiProperty({
        description: 'Number of tests per page',
        example: 10,
        default: 10,
        required: false,
        type: Number,
        minimum: 1,
        maximum: 100,
    })
    @IsOptional()
    @Type(() => Number)
    @IsNumber({}, { message: 'Limit must be a valid number' })
    @Min(1, { message: 'Limit must be at least 1' })
    @Max(100, { message: 'Limit cannot exceed 100' })
    limit?: number = 10;

    // Sorting parameters
    @ApiProperty({
        description: 'Sort tests by field',
        example: 'createdAt',
        default: 'createdAt',
        required: false,
        enum: [
            'testId',
            'title',
            'testType',
            'durationMinutes',
            'maxAttempts',
            'isActive',
            'createdAt',
            'updatedAt',
        ],
    })
    @IsOptional()
    @IsString({ message: 'Sort by must be a string' })
    @IsEnum(
        [
            'testId',
            'title',
            'testType',
            'durationMinutes',
            'maxAttempts',
            'isActive',
            'createdAt',
            'updatedAt',
        ],
        {
            message:
                'Sort by must be one of: testId, title, testType, durationMinutes, maxAttempts, isActive, createdAt, updatedAt',
        },
    )
    sortBy?: string = 'createdAt';

    @ApiProperty({
        description: 'Sort order',
        example: 'DESC',
        default: 'DESC',
        required: false,
        enum: ['ASC', 'DESC'],
    })
    @IsOptional()
    @IsString({ message: 'Sort order must be a string' })
    @IsEnum(['ASC', 'DESC'], {
        message: 'Sort order must be either ASC or DESC',
    })
    sortOrder?: 'ASC' | 'DESC' = 'DESC';
}

/*
 * Class #248: TestResponseDto
 * Source: test/dto/test-response.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 19
 * Decorators: 13
 * Complexity: 33
 * Size: 2134 characters (93 lines)
 */
/**
 * Basic test response DTO with core information
 */
export class TestResponseDto {
    @ApiProperty({
        description: 'Test unique identifier',
        example: 1,
    })
    testId: number;

    @ApiProperty({
        description: 'Course ID that this test belongs to',
        example: 1,
    })
    courseId: number;

    @ApiProperty({
        description: 'Test title',
        example: 'Midterm Exam - Computer Science Fundamentals',
    })
    title: string;

    @ApiProperty({
        description: 'Test description and instructions',
        example:
            'This exam covers chapters 1-5 of the course material. You have 2 hours to complete.',
        required: false,
    })
    description?: string;

    @ApiProperty({
        description: 'Type of test',
        example: TestType.EXAM,
        enum: TestType,
    })
    testType: TestType;

    @ApiProperty({
        description: 'Test duration in minutes (null for untimed tests)',
        example: 120,
        required: false,
    })
    durationMinutes?: number;

    @ApiProperty({
        description: 'Maximum number of attempts allowed per user',
        example: 3,
        default: 1,
    })
    maxAttempts: number;

    @ApiProperty({
        description: 'Whether the test is currently active',
        example: true,
    })
    isActive: boolean;

    @ApiProperty({
        description: 'Test creation timestamp',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @ApiProperty({
        description: 'Test last update timestamp',
        example: '2024-01-15T10:30:45.123Z',
    })
    updatedAt: Date;

    @ApiProperty({
        description: 'Course information',
        required: false,
    })
    course?: {
        courseId: number;
        title: string;
        description?: string;
    };

    @ApiProperty({
        description: 'Number of questions in this test',
        example: 25,
        default: 0,
    })
    questionCount: number;

    @ApiProperty({
        description: 'Number of attempts made by all users',
        example: 156,
        default: 0,
    })
    attemptCount: number;
}

/*
 * Class #249: TestDetailDto
 * Source: test/dto/test-response.dto.ts:98
 * Type: Exported Class
 * Methods: 0
 * Properties: 15
 * Decorators: 2
 * Complexity: 8
 * Size: 692 characters (28 lines)
 * Extends: TestResponseDto
 */
/**
 * Detailed test response DTO with comprehensive information
 */
export class TestDetailDto extends TestResponseDto {
    @ApiProperty({
        description: 'Test statistics and analytics',
    })
    statistics: {
        totalQuestions: number;
        totalAttempts: number;
        uniqueStudents: number;
        averageScore: number;
        passRate: number;
        completionRate: number;
    };

    @ApiProperty({
        description: 'Questions in this test (summary)',
        required: false,
    })
    questions?: Array<{
        questionId: number;
        questionText: string;
        questionType: string;
        points: number;
        orderIndex: number;
    }>;
}

/*
 * Class #250: TestListResponseDto
 * Source: test/dto/test-response.dto.ts:127
 * Type: Exported Class
 * Methods: 0
 * Properties: 5
 * Decorators: 5
 * Complexity: 11
 * Size: 711 characters (34 lines)
 */
/**
 * Paginated list of tests response DTO
 */
export class TestListResponseDto {
    @ApiProperty({
        description: 'Array of tests with basic information',
        type: [TestResponseDto],
    })
    tests: TestResponseDto[];

    @ApiProperty({
        description: 'Total number of tests matching the query',
        example: 156,
    })
    total: number;

    @ApiProperty({
        description: 'Current page number',
        example: 1,
    })
    page: number;

    @ApiProperty({
        description: 'Number of tests per page',
        example: 10,
    })
    limit: number;

    @ApiProperty({
        description: 'Total number of pages',
        example: 16,
    })
    totalPages: number;
}

/*
 * Class #251: TestStatsDto
 * Source: test/dto/test-response.dto.ts:162
 * Type: Exported Class
 * Methods: 0
 * Properties: 19
 * Decorators: 4
 * Complexity: 9
 * Size: 1092 characters (49 lines)
 */
/**
 * Test statistics and analytics DTO
 */
export class TestStatsDto {
    @ApiProperty({
        description: 'Test basic information',
    })
    test: {
        testId: number;
        title: string;
        testType: TestType;
        isActive: boolean;
    };

    @ApiProperty({
        description: 'Overall test statistics',
    })
    overview: {
        totalQuestions: number;
        totalAttempts: number;
        uniqueStudents: number;
        completedAttempts: number;
        inProgressAttempts: number;
    };

    @ApiProperty({
        description: 'Score distribution and performance metrics',
    })
    performance: {
        averageScore: number;
        medianScore: number;
        highestScore: number;
        lowestScore: number;
        passRate: number;
        averageCompletionTime: number;
    };

    @ApiProperty({
        description: 'Score distribution by ranges',
    })
    distribution: {
        '90-100': number;
        '80-89': number;
        '70-79': number;
        '60-69': number;
        '50-59': number;
        '0-49': number;
    };
}

/*
 * Class #252: TestConfigDto
 * Source: test/dto/test-response.dto.ts:212
 * Type: Exported Class
 * Methods: 0
 * Properties: 19
 * Decorators: 4
 * Complexity: 10
 * Size: 945 characters (43 lines)
 */
/**
 * Test configuration and settings DTO
 */
export class TestConfigDto {
    @ApiProperty({
        description: 'Test identification',
    })
    test: {
        testId: number;
        title: string;
        courseId: number;
    };

    @ApiProperty({
        description: 'Test timing configuration',
    })
    timing: {
        durationMinutes?: number;
        isTimeLimited: boolean;
        bufferTimeMinutes: number;
    };

    @ApiProperty({
        description: 'Test access and attempt configuration',
    })
    access: {
        maxAttempts: number;
        isActive: boolean;
        requiresApproval: boolean;
        allowLateSubmission: boolean;
    };

    @ApiProperty({
        description: 'Test content configuration',
    })
    content: {
        totalQuestions: number;
        totalPoints: number;
        passingPercentage: number;
        showCorrectAnswers: boolean;
        shuffleQuestions: boolean;
    };
}

/*
 * Class #253: UpdateTestDto
 * Source: test/dto/update-test.dto.ts:6
 * Type: Exported Class
 * Methods: 1
 * Properties: 23
 * Decorators: 5
 * Complexity: 28
 * Size: 1733 characters (60 lines)
 * Extends: PartialType(
    OmitType(CreateTestDto, ['courseId'] as const),
)
 */
/**
 * Data Transfer Object for updating an existing test
 * Extends CreateTestDto but excludes courseId (tests cannot be moved between courses)
 */
export class UpdateTestDto extends PartialType(
    OmitType(CreateTestDto, ['courseId'] as const),
) {
    @ApiProperty({
        description: 'Updated test title for identification and display',
        example: 'Final Exam - Computer Science Fundamentals (Updated)',
        required: false,
        type: String,
        title: 'Test Title',
        maxLength: 255,
        minLength: 3,
    })
    title?: string;

    @ApiProperty({
        description:
            'Updated test description and instructions for students taking the test',
        example:
            'This final exam covers all course material. You have 3 hours to complete all questions.',
        required: false,
        type: String,
        title: 'Test Description',
    })
    description?: string;

    @ApiProperty({
        description:
            'Updated test type determining behavior and purpose (use with caution)',
        example: TestType.EXAM,
        required: false,
        enum: TestType,
        title: 'Test Type',
    })
    testType?: TestType;

    @ApiProperty({
        description:
            'Updated test duration in minutes (set to null for untimed tests)',
        example: 180,
        required: false,
        type: Number,
        title: 'Duration (Minutes)',
        minimum: 1,
    })
    durationMinutes?: number;

    @ApiProperty({
        description: 'Updated maximum number of attempts allowed per user',
        example: 2,
        required: false,
        type: Number,
        title: 'Maximum Attempts',
        minimum: 1,
    })
    maxAttempts?: number;
}

/*
 * Class #254: Test
 * Source: test/entities/test.entity.ts:37
 * Type: Exported Class
 * Methods: 1
 * Properties: 31
 * Decorators: 47
 * Complexity: 103
 * Size: 3235 characters (136 lines)
 */
export class Test {
    @PrimaryGeneratedColumn()
    @ApiProperty({
        description: 'Test unique identifier',
        example: 1,
    })
    testId: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Course ID that this test belongs to',
        example: 1,
    })
    @IsNumber()
    @IsNotEmpty()
    courseId: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Test title',
        example: 'Midterm Exam - Computer Science Fundamentals',
    })
    @IsString()
    @IsNotEmpty()
    title: string;

    @Column('text', { nullable: true })
    @ApiProperty({
        description: 'Test description and instructions',
        example:
            'This exam covers chapters 1-5 of the course material. You have 2 hours to complete.',
        required: false,
    })
    @IsString()
    @IsOptional()
    description?: string;

    @Column({
        type: 'enum',
        enum: TestType,
    })
    @ApiProperty({
        description: 'Type of test',
        example: TestType.EXAM,
        enum: TestType,
    })
    @IsEnum(TestType)
    @IsNotEmpty()
    testType: TestType;

    @Column({ nullable: true })
    @ApiProperty({
        description: 'Test duration in minutes (null for untimed tests)',
        example: 120,
        required: false,
    })
    @IsNumber()
    @IsOptional()
    @Min(1)
    durationMinutes?: number;

    @Column({ default: 1 })
    @ApiProperty({
        description: 'Maximum number of attempts allowed per user',
        example: 3,
        default: 1,
        minimum: 1,
    })
    @IsNumber()
    @IsNotEmpty()
    @Min(1)
    maxAttempts: number;

    @Column({ default: true })
    @Index()
    @ApiProperty({
        description:
            'Whether the test is currently active and available for attempts',
        example: true,
        default: true,
    })
    @IsBoolean()
    isActive: boolean;

    @CreateDateColumn()
    @ApiProperty({
        description: 'Test creation timestamp',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @UpdateDateColumn()
    @ApiProperty({
        description: 'Test last update timestamp',
        example: '2024-01-15T10:30:45.123Z',
    })
    updatedAt: Date;

    @ManyToOne(() => Organization, { nullable: false })
    @ApiProperty({
        description: 'Organization this test belongs to',
        type: () => Organization,
    })
    orgId: Organization;

    @ManyToOne(() => Branch, { nullable: true })
    @ApiProperty({
        description: 'Branch this test belongs to',
        type: () => Branch,
        required: false,
    })
    branchId?: Branch;

    // Relations
    @ManyToOne(() => Course, { onDelete: 'CASCADE' })
    course: Course;

    @OneToMany(() => Question, 'test')
    questions: any[];

    // Note: These relations will be added as we implement other entities
    @OneToMany(() => TestAttempt, attempt => attempt.test)
    testAttempts: TestAttempt[];

    @OneToMany(() => Result, result => result.test)
    results: Result[];

    @OneToMany(() => TrainingProgress, progress => progress.test)
    trainingProgress: TrainingProgress[];

    constructor(partial: Partial<Test>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #255: TestController
 * Source: test/test.controller.ts:54
 * Type: Exported Class
 * Methods: 22
 * Properties: 342
 * Decorators: 97
 * Complexity: 334
 * Size: 28475 characters (926 lines)
 */
export class TestController {
    private readonly logger = new Logger(TestController.name);

    constructor(private readonly testService: TestService) {}

    @Post()
    @ApiOperation({
        summary: '📝 Create New Test',
        description: `
      **Creates a new test within a course with comprehensive configuration options**
      
      This endpoint allows course instructors to create tests including:
      - Test metadata (title, description, type)
      - Timing configuration (duration, attempts)
      - Test behavior settings
      
      **Authorization Requirements:**
      - Must be the owner of the course
      - Valid JWT authentication required
      
      **Business Rules:**
      - Course must exist and be accessible to the user
      - Test type determines available features and behavior
      - Duration is optional (null for untimed tests)
      - Maximum attempts defaults to 1 if not specified
      
      **Use Cases:**
      - Creating course examinations
      - Setting up practice quizzes
      - Preparing training assessments
    `,
        operationId: 'createTest',
    })
    @ApiBody({
        type: CreateTestDto,
        description: 'Test creation data with course assignment',
        examples: {
            'final-exam': {
                summary: '🎓 Final Exam Creation',
                description: 'Create a comprehensive final examination',
                value: {
                    courseId: 1,
                    title: 'Final Exam - Computer Science Fundamentals',
                    description:
                        'Comprehensive final examination covering all course material. Time limit: 3 hours.',
                    testType: 'exam',
                    durationMinutes: 180,
                    maxAttempts: 1,
                },
            },
            'practice-quiz': {
                summary: '📋 Practice Quiz Creation',
                description: 'Create a practice quiz for students',
                value: {
                    courseId: 1,
                    title: 'Chapter 3 Practice Quiz',
                    description:
                        'Practice quiz covering data structures and algorithms.',
                    testType: 'quiz',
                    durationMinutes: 45,
                    maxAttempts: 3,
                },
            },
            'untimed-training': {
                summary: '🏃 Training Module Creation',
                description: 'Create an untimed training assessment',
                value: {
                    courseId: 1,
                    title: 'Python Basics Training',
                    description:
                        'Self-paced training module for Python fundamentals.',
                    testType: 'training',
                    maxAttempts: 5,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description: '✅ Test created successfully',
        type: TestResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data or validation errors',
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '⛔ Forbidden - No access to the specified course',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course not found',
    })
    async create(
        @Body() createTestDto: CreateTestDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardApiResponse<TestResponseDto>> {
        try {
            this.logger.log(
                `Creating test for course ${createTestDto.courseId} by user: ${scope.userId}`,
            );

            const test = await this.testService.create(createTestDto, scope);

            this.logger.log(
                `Test created successfully with ID: ${test.testId}`,
            );

            return {
                success: true,
                message: 'Test created successfully',
                data: test,
            };
        } catch (error) {
            this.logger.error(
                `Error creating test for user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Get()
    @ApiOperation({
        summary: '📋 List Tests with Advanced Filtering',
        description: `
      **Retrieves a paginated list of tests with comprehensive filtering options**
      
      This endpoint provides powerful search and filtering capabilities:
      - Course-based filtering
      - Test type and status filtering
      - Date range filtering
      - Duration and attempt constraints
      - Flexible sorting and pagination
      
      **Access Control:**
      - Returns tests from courses the user has access to
      - Instructors see all tests in their courses
      - Students see only active tests (when implemented)
      
      **Performance Features:**
      - Efficient pagination
      - Database query optimization
      - Retry logic for connection resilience
      
      **Use Cases:**
      - Course management dashboards
      - Test discovery for students
      - Administrative oversight
      - Academic analytics
    `,
        operationId: 'listTests',
    })
    @ApiQuery({
        name: 'courseId',
        required: false,
        type: Number,
        description: 'Filter tests by course ID',
        example: 1,
    })
    @ApiQuery({
        name: 'title',
        required: false,
        type: String,
        description: 'Search tests by title (partial match)',
        example: 'midterm',
    })
    @ApiQuery({
        name: 'testType',
        required: false,
        enum: ['exam', 'quiz', 'training'],
        description: 'Filter by test type',
        example: 'exam',
    })
    @ApiQuery({
        name: 'isActive',
        required: false,
        type: Boolean,
        description: 'Filter by active status',
        example: true,
    })
    @ApiQuery({
        name: 'page',
        required: false,
        type: Number,
        description: 'Page number for pagination',
        example: 1,
    })
    @ApiQuery({
        name: 'limit',
        required: false,
        type: Number,
        description: 'Number of tests per page (max 100)',
        example: 10,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Tests retrieved successfully',
        type: TestListResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid query parameters',
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    async findAll(
        @Query() filters: TestFilterDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardApiResponse<TestListResponseDto>> {
        try {
            this.logger.log(`Listing tests for user: ${scope.userId}`);

            const result = await this.testService.findAll(filters, scope);

            this.logger.log(
                `Retrieved ${result.tests.length} tests (${result.total} total)`,
            );

            return {
                success: true,
                message: 'Tests retrieved successfully',
                data: result,
            };
        } catch (error) {
            this.logger.error(
                `Error listing tests for user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Get('course/:courseId')
    @ApiOperation({
        summary: '🎓 Get Tests for Specific Course',
        description: `
      **Retrieves all tests belonging to a specific course**
      
      This endpoint provides course-specific test listings:
      - All tests within the specified course
      - Includes test metadata and statistics
      - Ordered by creation date (newest first)
      
      **Authorization:**
      - Course access validation
      - Ownership verification for full details
      
      **Response Includes:**
      - Basic test information
      - Question counts and attempt statistics
      - Course context information
      
      **Use Cases:**
      - Course dashboard displays
      - Test management interfaces
      - Student test selection
      - Academic progress tracking
    `,
        operationId: 'getTestsByCourse',
    })
    @ApiParam({
        name: 'courseId',
        type: Number,
        description: 'Course identifier',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course tests retrieved successfully',
        type: TestListResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Course not found',
    })
    async findByCourse(
        @Param('courseId', ParseIntPipe) courseId: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardApiResponse<TestListResponseDto>> {
        try {
            this.logger.log(
                `Getting tests for course ${courseId} by user: ${scope.userId}`,
            );

            const result = await this.testService.findByCourse(courseId, scope);

            this.logger.log(
                `Retrieved ${result.tests.length} tests for course ${courseId}`,
            );

            return {
                success: true,
                message: 'Course tests retrieved successfully',
                data: result,
            };
        } catch (error) {
            this.logger.error(
                `Error getting tests for course ${courseId} by user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Get(':id')
    @ApiOperation({
        summary: '🔍 Get Detailed Test Information',
        description: `
      **Retrieves comprehensive information about a specific test**
      
      This endpoint provides complete test details including:
      - Test configuration and metadata
      - Course context and relationship
      - Question summary (when available)
      - Performance statistics and analytics
      
      **Access Control:**
      - Course ownership validation
      - Read access for authorized users
      - Detailed statistics for instructors
      
      **Response Includes:**
      - Complete test configuration
      - Related course information
      - Question count and structure
      - Attempt and performance statistics
      
      **Use Cases:**
      - Test detail views
      - Test editing interfaces
      - Performance analysis
      - Academic reporting
    `,
        operationId: 'getTestById',
    })
    @ApiParam({
        name: 'id',
        type: Number,
        description: 'Test identifier',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Test details retrieved successfully',
        type: TestDetailDto,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Test not found',
    })
    async findOne(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardApiResponse<TestDetailDto>> {
        try {
            this.logger.log(`Getting test ${id} for user: ${scope.userId}`);

            const test = await this.testService.findOne(id, scope.userId);

            if (!test) {
                throw new NotFoundException(`Test with ID ${id} not found`);
            }

            this.logger.log(`Test ${id} retrieved successfully`);

            return {
                success: true,
                message: 'Test details retrieved successfully',
                data: test,
            };
        } catch (error) {
            this.logger.error(
                `Error getting test ${id} for user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Put(':id')
    @ApiOperation({
        summary: '✏️ Update Test Configuration',
        description: `
      **Updates test configuration and settings with validation**
      
      This endpoint allows comprehensive test updates including:
      - Test metadata (title, description)
      - Timing configuration (duration, attempts)
      - Test type and behavior settings
      
      **Authorization Requirements:**
      - Must be the owner of the parent course
      - Valid JWT authentication required
      
      **Business Rules:**
      - Cannot change course assignment (tests cannot be moved)
      - Updates affect future attempts only
      - Active tests can be updated with caution
      
      **Validation:**
      - Input data validation
      - Course ownership verification
      - Business rule enforcement
      
      **Use Cases:**
      - Test configuration adjustments
      - Timing modifications
      - Description updates
      - Access control changes
    `,
        operationId: 'updateTest',
    })
    @ApiParam({
        name: 'id',
        type: Number,
        description: 'Test identifier to update',
        example: 1,
    })
    @ApiBody({
        type: UpdateTestDto,
        description: 'Test update data (excludes course assignment)',
        examples: {
            'extend-duration': {
                summary: '⏰ Extend Test Duration',
                description: 'Increase test duration for accessibility',
                value: {
                    durationMinutes: 240,
                    description:
                        'Extended duration final exam - 4 hours allowed for accessibility accommodations.',
                },
            },
            'allow-retakes': {
                summary: '🔄 Allow Additional Attempts',
                description: 'Increase maximum attempts for practice',
                value: {
                    maxAttempts: 3,
                    description:
                        'Practice quiz with multiple attempts allowed for learning.',
                },
            },
            'update-title': {
                summary: '📝 Update Test Information',
                description: 'Update test title and description',
                value: {
                    title: 'Midterm Exam - Advanced Topics (Updated)',
                    description:
                        'Updated midterm exam covering advanced course topics including new material from weeks 8-10.',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Test updated successfully',
        type: TestResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data or validation errors',
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '⛔ Forbidden - No permission to update this test',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Test not found',
    })
    async update(
        @Param('id', ParseIntPipe) id: number,
        @Body() updateTestDto: UpdateTestDto,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardApiResponse<TestResponseDto>> {
        try {
            this.logger.log(`Updating test ${id} by user: ${scope.userId}`);

            const test = await this.testService.update(
                id,
                updateTestDto,
                scope.userId,
            );

            this.logger.log(`Test ${id} updated successfully`);

            return {
                success: true,
                message: 'Test updated successfully',
                data: test,
            };
        } catch (error) {
            this.logger.error(
                `Error updating test ${id} by user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Patch(':id/activate')
    @ApiOperation({
        summary: '✅ Activate Test',
        description: `
      **Activates a test making it available for student attempts**
      
      This endpoint enables test access for students:
      - Sets test status to active
      - Makes test visible to students
      - Enables attempt submissions
      
      **Authorization:**
      - Requires course ownership
      - Instructor privileges required
      
      **Business Impact:**
      - Students can start new attempts
      - Test appears in available tests
      - Scheduling and access rules apply
      
      **Use Cases:**
      - Test publication
      - Scheduled test activation
      - Emergency test enabling
    `,
        operationId: 'activateTest',
    })
    @ApiParam({
        name: 'id',
        type: Number,
        description: 'Test identifier to activate',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Test activated successfully',
        type: TestResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '⛔ Forbidden - No permission to activate this test',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Test not found',
    })
    async activate(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardApiResponse<TestResponseDto>> {
        try {
            this.logger.log(`Activating test ${id} by user: ${scope.userId}`);

            const test = await this.testService.activate(id, scope.userId);

            this.logger.log(`Test ${id} activated successfully`);

            return {
                success: true,
                message: 'Test activated successfully',
                data: test,
            };
        } catch (error) {
            this.logger.error(
                `Error activating test ${id} by user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Patch(':id/deactivate')
    @ApiOperation({
        summary: '⏸️ Deactivate Test',
        description: `
      **Deactivates a test preventing new student attempts**
      
      This endpoint disables test access for students:
      - Sets test status to inactive
      - Prevents new attempt starts
      - Hides test from student view
      
      **Authorization:**
      - Requires course ownership
      - Instructor privileges required
      
      **Business Impact:**
      - No new attempts can be started
      - Existing attempts continue normally
      - Test becomes invisible to students
      
      **Use Cases:**
      - Test closure after deadline
      - Emergency test suspension
      - Scheduled test deactivation
    `,
        operationId: 'deactivateTest',
    })
    @ApiParam({
        name: 'id',
        type: Number,
        description: 'Test identifier to deactivate',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Test deactivated successfully',
        type: TestResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '⛔ Forbidden - No permission to deactivate this test',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Test not found',
    })
    async deactivate(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardApiResponse<TestResponseDto>> {
        try {
            this.logger.log(`Deactivating test ${id} by user: ${scope.userId}`);

            const test = await this.testService.deactivate(id, scope.userId);

            this.logger.log(`Test ${id} deactivated successfully`);

            return {
                success: true,
                message: 'Test deactivated successfully',
                data: test,
            };
        } catch (error) {
            this.logger.error(
                `Error deactivating test ${id} by user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Get(':id/stats')
    @ApiOperation({
        summary: '📊 Get Test Statistics and Analytics',
        description: `
      **Retrieves comprehensive test performance statistics and analytics**
      
      This endpoint provides detailed analytics including:
      - Overall test performance metrics
      - Score distribution and trends
      - Attempt and completion statistics
      - Student participation analytics
      
      **Authorization:**
      - Requires course ownership
      - Instructor analytics access
      
      **Analytics Include:**
      - Performance summaries
      - Score distributions
      - Completion rates
      - Time-based trends
      
      **Use Cases:**
      - Academic performance analysis
      - Test quality assessment
      - Student progress tracking
      - Course improvement insights
    `,
        operationId: 'getTestStats',
    })
    @ApiParam({
        name: 'id',
        type: Number,
        description: 'Test identifier for statistics',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Test statistics retrieved successfully',
        type: TestStatsDto,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '⛔ Forbidden - No permission to view test statistics',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Test not found',
    })
    async getStats(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardApiResponse<TestStatsDto>> {
        try {
            this.logger.log(
                `Getting stats for test ${id} by user: ${scope.userId}`,
            );

            const stats = await this.testService.getStats(id, scope.userId);

            this.logger.log(`Stats retrieved for test ${id}`);

            return {
                success: true,
                message: 'Test statistics retrieved successfully',
                data: stats,
            };
        } catch (error) {
            this.logger.error(
                `Error getting stats for test ${id} by user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Get(':id/config')
    @ApiOperation({
        summary: '⚙️ Get Test Configuration',
        description: `
      **Retrieves detailed test configuration and settings**
      
      This endpoint provides complete test configuration:
      - Timing and access settings
      - Content configuration
      - Behavioral parameters
      - Administrative settings
      
      **Authorization:**
      - Requires course ownership
      - Configuration access for instructors
      
      **Configuration Includes:**
      - Test identification
      - Timing parameters
      - Access controls
      - Content settings
      
      **Use Cases:**
      - Test administration interfaces
      - Configuration verification
      - Settings comparison
      - Audit and compliance
    `,
        operationId: 'getTestConfig',
    })
    @ApiParam({
        name: 'id',
        type: Number,
        description: 'Test identifier for configuration',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Test configuration retrieved successfully',
        type: TestConfigDto,
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '⛔ Forbidden - No permission to view test configuration',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Test not found',
    })
    async getConfig(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardApiResponse<TestConfigDto>> {
        try {
            this.logger.log(
                `Getting config for test ${id} by user: ${scope.userId}`,
            );

            const config = await this.testService.getConfig(id, scope.userId);

            this.logger.log(`Config retrieved for test ${id}`);

            return {
                success: true,
                message: 'Test configuration retrieved successfully',
                data: config,
            };
        } catch (error) {
            this.logger.error(
                `Error getting config for test ${id} by user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }

    @Delete(':id')
    @ApiOperation({
        summary: '🗑️ Delete Test',
        description: `
      **Permanently deletes a test and all associated data**
      
      ⚠️ **WARNING: This action is irreversible!**
      
      This endpoint removes:
      - Test configuration and metadata
      - Associated questions and options (cascade)
      - Student attempts and responses (cascade)
      - Results and analytics data (cascade)
      
      **Authorization Requirements:**
      - Must be the owner of the parent course
      - Administrative privileges required
      
      **Business Rules:**
      - Validates no active attempts exist
      - Checks for dependent data
      - Performs cascade deletion
      
      **Safety Measures:**
      - Course ownership verification
      - Dependency validation
      - Audit logging
      
      **Use Cases:**
      - Test cleanup and maintenance
      - Course restructuring
      - Administrative corrections
      - Data privacy compliance
    `,
        operationId: 'deleteTest',
    })
    @ApiParam({
        name: 'id',
        type: Number,
        description: 'Test identifier to delete',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Test deleted successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: {
                    type: 'string',
                    example: 'Test deleted successfully',
                },
                data: { type: 'null' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
    })
    @ApiResponse({
        status: HttpStatus.FORBIDDEN,
        description: '⛔ Forbidden - No permission to delete this test',
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Test not found',
    })
    @ApiResponse({
        status: HttpStatus.CONFLICT,
        description: '⚠️ Conflict - Test has active attempts or dependencies',
    })
    async remove(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
    ): Promise<StandardApiResponse<null>> {
        try {
            this.logger.log(`Deleting test ${id} by user: ${scope.userId}`);

            await this.testService.remove(id, scope.userId);

            this.logger.log(`Test ${id} deleted successfully`);

            return {
                success: true,
                message: 'Test deleted successfully',
                data: null,
            };
        } catch (error) {
            this.logger.error(
                `Error deleting test ${id} by user ${scope.userId}:`,
                error,
            );
            throw error;
        }
    }
}

/*
 * Class #256: TestModule
 * Source: test/test.module.ts:21
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 26 characters (1 lines)
 */
export class TestModule {}

/*
 * Class #257: TestService
 * Source: test/test.service.ts:30
 * Type: Exported Class
 * Methods: 44
 * Properties: 140
 * Decorators: 5
 * Complexity: 223
 * Size: 20996 characters (585 lines)
 */
export class TestService {
    constructor(
        @InjectRepository(Test)
        private readonly testRepository: Repository<Test>,
        @InjectRepository(Course)
        private readonly courseRepository: Repository<Course>,
        @InjectRepository(Question)
        private readonly questionRepository: Repository<Question>,
        @InjectRepository(TestAttempt)
        private readonly testAttemptRepository: Repository<TestAttempt>,
        @InjectRepository(Result)
        private readonly resultRepository: Repository<Result>,
        private readonly courseService: CourseService,
    ) {}

    private async retryOperation<T>(
        operation: () => Promise<T>,
        maxRetries = 3,
        delay = 1000,
    ): Promise<T> {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                const isConnectionError =
                    error instanceof Error &&
                    (error.message.includes('ECONNRESET') ||
                        error.message.includes('Connection lost') ||
                        error.message.includes('connect ETIMEDOUT'));

                if (isConnectionError && attempt < maxRetries) {
                    console.log(
                        `Database connection error on attempt ${attempt}, retrying in ${delay}ms...`,
                    );
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                    continue;
                }
                throw error;
            }
        }
        throw new Error('Max retries exceeded');
    }

    async create(
        createTestDto: CreateTestDto,
        scope: OrgBranchScope,
    ): Promise<TestResponseDto> {
        return this.retryOperation(async () => {
            // Validate course exists and user has ownership
            await this.validateCourseAccess(
                createTestDto.courseId,
                scope.userId,
            );

            // Get course information to inherit org and branch
            const course = await this.courseRepository.findOne({
                where: { courseId: createTestDto.courseId },
                relations: ['orgId', 'branchId'],
            });

            if (!course) {
                throw new NotFoundException(
                    `Course with ID ${createTestDto.courseId} not found`,
                );
            }

            const test = this.testRepository.create({
                ...createTestDto,
                maxAttempts: createTestDto.maxAttempts || 1,
                orgId: course.orgId,
                branchId: course.branchId,
            });

            const savedTest = await this.testRepository.save(test);

            return {
                ...savedTest,
                course: course
                    ? {
                          courseId: course.courseId,
                          title: course.title,
                          description: course.description,
                      }
                    : undefined,
                questionCount: 0,
                attemptCount: 0,
            };
        });
    }

    async findAll(
        filters: TestFilterDto,
        scope: OrgBranchScope,
    ): Promise<TestListResponseDto> {
        return this.retryOperation(async () => {
            const {
                courseId,
                title,
                testType,
                isActive,
                createdAfter,
                createdBefore,
                minDuration,
                maxDuration,
                minAttempts,
                maxAttempts,
                page = 1,
                limit = 10,
                sortBy = 'createdAt',
                sortOrder = 'DESC',
            } = filters;

            const query = this.testRepository.createQueryBuilder('test');
            query.leftJoinAndSelect('test.course', 'course');
            query.leftJoinAndSelect('test.orgId', 'org');
            query.leftJoinAndSelect('test.branchId', 'branch');

            // Apply org/branch scoping
            if (scope.orgId) {
                query.andWhere('test.orgId = :orgId', { orgId: scope.orgId });
            }
            if (scope.branchId) {
                query.andWhere('test.branchId = :branchId', {
                    branchId: scope.branchId,
                });
            }

            // Apply filters
            if (courseId) {
                query.andWhere('test.courseId = :courseId', { courseId });
            }

            if (title) {
                query.andWhere('test.title LIKE :title', {
                    title: `%${title}%`,
                });
            }

            if (testType) {
                query.andWhere('test.testType = :testType', { testType });
            }

            if (isActive !== undefined) {
                query.andWhere('test.isActive = :isActive', { isActive });
            }

            if (createdAfter) {
                query.andWhere('test.createdAt >= :createdAfter', {
                    createdAfter,
                });
            }

            if (createdBefore) {
                query.andWhere('test.createdAt <= :createdBefore', {
                    createdBefore,
                });
            }

            if (minDuration) {
                query.andWhere('test.durationMinutes >= :minDuration', {
                    minDuration,
                });
            }

            if (maxDuration) {
                query.andWhere('test.durationMinutes <= :maxDuration', {
                    maxDuration,
                });
            }

            if (minAttempts) {
                query.andWhere('test.maxAttempts >= :minAttempts', {
                    minAttempts,
                });
            }

            if (maxAttempts) {
                query.andWhere('test.maxAttempts <= :maxAttempts', {
                    maxAttempts,
                });
            }

            // Add sorting
            query.orderBy(`test.${sortBy}`, sortOrder);

            // Add pagination
            const skip = (page - 1) * limit;
            query.skip(skip).take(limit);

            const [tests, total] = await query.getManyAndCount();

            // Calculate actual question counts and prepare test data
            const testsWithCounts = await Promise.all(
                tests.map(async test => {
                    const questionCount = await this.questionRepository.count({
                        where: { testId: test.testId },
                    });

                    const attemptCount = await this.testAttemptRepository.count(
                        {
                            where: { testId: test.testId },
                        },
                    );

                    return {
                        ...test,
                        course: test.course
                            ? {
                                  courseId: test.course.courseId,
                                  title: test.course.title,
                                  description: test.course.description,
                              }
                            : undefined,
                        questionCount,
                        attemptCount,
                    };
                }),
            );

            return {
                tests: testsWithCounts,
                total,
                page,
                limit,
                totalPages: Math.ceil(total / limit),
            };
        });
    }

    async findOne(id: number, userId?: string): Promise<TestDetailDto | null> {
        return this.retryOperation(async () => {
            const test = await this.testRepository.findOne({
                where: { testId: id },
                relations: [
                    'course',
                    'course.orgId',
                    'course.branchId',
                    'orgId',
                    'branchId',
                ],
            });

            if (!test) {
                return null;
            }

            // If userId provided, validate access (course ownership or admin)
            if (userId) {
                try {
                    await this.validateCourseAccess(test.courseId, userId);
                } catch {
                    // If not owner, still allow read access for now
                    // This will be refined based on business requirements
                }
            }

            // Calculate available statistics with current entities
            const totalQuestions = await this.questionRepository.count({
                where: { testId: id },
            });

            const totalAttempts = await this.testAttemptRepository.count({
                where: { testId: id },
            });

            const uniqueStudents = await this.testAttemptRepository
                .createQueryBuilder('attempt')
                .where('attempt.testId = :testId', { testId: id })
                .select('COUNT(DISTINCT attempt.userId)', 'count')
                .getRawOne()
                .then(
                    (result: { count: string }) => parseInt(result.count) || 0,
                );

            const averageScoreResult: { avgScore: string } | undefined =
                await this.resultRepository
                    .createQueryBuilder('result')
                    .innerJoin('result.attempt', 'attempt')
                    .where('attempt.testId = :testId', { testId: id })
                    .select('AVG(result.score)', 'avgScore')
                    .getRawOne();

            const averageScore = averageScoreResult?.avgScore
                ? parseFloat(averageScoreResult.avgScore)
                : 0;

            const passRateResult: { passRate: string } | undefined =
                await this.resultRepository
                    .createQueryBuilder('result')
                    .innerJoin('result.attempt', 'attempt')
                    .where('attempt.testId = :testId', { testId: id })
                    .select(
                        'AVG(CASE WHEN result.passed = 1 THEN 1 ELSE 0 END) * 100',
                        'passRate',
                    )
                    .getRawOne();

            const passRate = passRateResult?.passRate
                ? parseFloat(passRateResult.passRate)
                : 0;

            const completedAttempts = await this.testAttemptRepository.count({
                where: { testId: id, status: AttemptStatus.SUBMITTED },
            });

            const completionRate =
                totalAttempts > 0
                    ? (completedAttempts / totalAttempts) * 100
                    : 0;

            const statistics = {
                totalQuestions,
                totalAttempts,
                uniqueStudents,
                averageScore,
                passRate,
                completionRate,
            };

            return {
                ...test,
                course: test.course
                    ? {
                          courseId: test.course.courseId,
                          title: test.course.title,
                          description: test.course.description,
                          organization: test.course.orgId,
                          branch: test.course.branchId,
                      }
                    : undefined,
                questionCount: statistics.totalQuestions,
                attemptCount: statistics.totalAttempts,
                statistics,
                questions: [], // TODO: Will be populated when Question entity is available
            };
        });
    }

    async findByCourse(
        courseId: number,
        scope: OrgBranchScope,
    ): Promise<TestListResponseDto> {
        return this.findAll({ courseId, page: 1, limit: 100 }, scope);
    }

    async update(
        id: number,
        updateTestDto: UpdateTestDto,
        userId: string,
    ): Promise<TestResponseDto> {
        return this.retryOperation(async () => {
            const test = await this.testRepository.findOne({
                where: { testId: id },
                relations: ['course'],
            });

            if (!test) {
                throw new NotFoundException(`Test with ID ${id} not found`);
            }

            // Validate course ownership
            await this.validateCourseAccess(test.courseId, userId);

            const result = await this.testRepository.update(id, updateTestDto);

            if (result.affected === 0) {
                throw new NotFoundException(`Test with ID ${id} not found`);
            }

            const updatedTest = await this.testRepository.findOne({
                where: { testId: id },
                relations: ['course'],
            });

            if (!updatedTest) {
                throw new NotFoundException(`Test with ID ${id} not found`);
            }

            return {
                ...updatedTest,
                course: updatedTest.course
                    ? {
                          courseId: updatedTest.course.courseId,
                          title: updatedTest.course.title,
                          description: updatedTest.course.description,
                      }
                    : undefined,
                questionCount: 0,
                attemptCount: 0,
            };
        });
    }

    async remove(id: number, userId: string): Promise<void> {
        return this.retryOperation(async () => {
            const test = await this.testRepository.findOne({
                where: { testId: id },
            });

            if (!test) {
                throw new NotFoundException(`Test with ID ${id} not found`);
            }

            // Validate course ownership
            await this.validateCourseAccess(test.courseId, userId);

            // For now, allow deletion since we don't have TestAttempt entity yet
            // TODO: Check for existing attempts when TestAttempt entity is available
            // Example: const attemptCount = await this.testAttemptRepository.count({ where: { testId: id } });
            // if (attemptCount > 0) {
            //     throw new ForbiddenException(`Cannot delete test with ${attemptCount} existing attempts`);
            // }

            const result = await this.testRepository.delete(id);
            if (result.affected === 0) {
                throw new NotFoundException(`Test with ID ${id} not found`);
            }
        });
    }

    async activate(id: number, userId: string): Promise<TestResponseDto> {
        return this.updateStatus(id, userId, true);
    }

    async deactivate(id: number, userId: string): Promise<TestResponseDto> {
        return this.updateStatus(id, userId, false);
    }

    private async updateStatus(
        id: number,
        userId: string,
        isActive: boolean,
    ): Promise<TestResponseDto> {
        return this.retryOperation(async () => {
            const test = await this.testRepository.findOne({
                where: { testId: id },
                relations: ['course'],
            });

            if (!test) {
                throw new NotFoundException(`Test with ID ${id} not found`);
            }

            // Validate course ownership
            await this.validateCourseAccess(test.courseId, userId);

            await this.testRepository.update(id, { isActive });

            const updatedTest = await this.testRepository.findOne({
                where: { testId: id },
                relations: ['course'],
            });

            if (!updatedTest) {
                throw new NotFoundException(`Test with ID ${id} not found`);
            }

            return {
                ...updatedTest,
                course: updatedTest.course
                    ? {
                          courseId: updatedTest.course.courseId,
                          title: updatedTest.course.title,
                          description: updatedTest.course.description,
                      }
                    : undefined,
                questionCount: 0,
                attemptCount: 0,
            };
        });
    }

    async getStats(id: number, userId: string): Promise<TestStatsDto> {
        return this.retryOperation(async () => {
            const test = await this.testRepository.findOne({
                where: { testId: id },
            });

            if (!test) {
                throw new NotFoundException(`Test with ID ${id} not found`);
            }

            // Validate course ownership
            await this.validateCourseAccess(test.courseId, userId);

            // Prepare statistics structure with TODOs for future implementation
            return {
                test: {
                    testId: test.testId,
                    title: test.title,
                    testType: test.testType,
                    isActive: test.isActive,
                },
                overview: {
                    totalQuestions: 0, // TODO: Calculate when Question entity is available
                    totalAttempts: 0, // TODO: Calculate when TestAttempt entity is available
                    uniqueStudents: 0, // TODO: Calculate when TestAttempt entity is available
                    completedAttempts: 0, // TODO: Calculate when TestAttempt entity is available
                    inProgressAttempts: 0, // TODO: Calculate when TestAttempt entity is available
                },
                performance: {
                    averageScore: 0, // TODO: Calculate when Result entity is available
                    medianScore: 0, // TODO: Calculate when Result entity is available
                    highestScore: 0, // TODO: Calculate when Result entity is available
                    lowestScore: 0, // TODO: Calculate when Result entity is available
                    passRate: 0, // TODO: Calculate when Result entity is available
                    averageCompletionTime: 0, // TODO: Calculate when TestAttempt entity is available
                },
                distribution: {
                    '90-100': 0, // TODO: Calculate when Result entity is available
                    '80-89': 0, // TODO: Calculate when Result entity is available
                    '70-79': 0, // TODO: Calculate when Result entity is available
                    '60-69': 0, // TODO: Calculate when Result entity is available
                    '50-59': 0, // TODO: Calculate when Result entity is available
                    '0-49': 0, // TODO: Calculate when Result entity is available
                },
            };
        });
    }

    async getConfig(id: number, userId: string): Promise<TestConfigDto> {
        return this.retryOperation(async () => {
            const test = await this.testRepository.findOne({
                where: { testId: id },
            });

            if (!test) {
                throw new NotFoundException(`Test with ID ${id} not found`);
            }

            // Validate course ownership
            await this.validateCourseAccess(test.courseId, userId);

            return {
                test: {
                    testId: test.testId,
                    title: test.title,
                    courseId: test.courseId,
                },
                timing: {
                    durationMinutes: test.durationMinutes,
                    isTimeLimited: !!test.durationMinutes,
                    bufferTimeMinutes: 5, // Default buffer time
                },
                access: {
                    maxAttempts: test.maxAttempts,
                    isActive: test.isActive,
                    requiresApproval: false, // Default value
                    allowLateSubmission: false, // Default value
                },
                content: {
                    totalQuestions: 0, // Will be calculated when Question entity is available
                    totalPoints: 0, // Will be calculated when Question entity is available
                    passingPercentage: 70, // Default passing percentage
                    showCorrectAnswers: false, // Default value
                    shuffleQuestions: true, // Default value
                },
            };
        });
    }

    async validateCourseAccess(
        courseId: number,
        userId: string,
    ): Promise<void> {
        return this.retryOperation(async () => {
            const course = await this.courseRepository.findOne({
                where: { courseId },
            });

            if (!course) {
                throw new NotFoundException(
                    `Course with ID ${courseId} not found`,
                );
            }

            if (course.createdBy !== userId) {
                throw new ForbiddenException(
                    'You do not have permission to access this course',
                );
            }
        });
    }
}

/*
 * Class #258: CreateTestAttemptDto
 * Source: test_attempts/dto/create-test_attempt.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 3
 * Complexity: 8
 * Size: 193 characters (9 lines)
 */
export class CreateTestAttemptDto {
    @ApiProperty({
        description: 'Test ID to start an attempt for',
        example: 1,
    })
    @IsNumber()
    @IsNotEmpty()
    testId: number;
}

/*
 * Class #259: StartTestAttemptDto
 * Source: test_attempts/dto/start-test-attempt.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 3
 * Complexity: 8
 * Size: 192 characters (9 lines)
 */
export class StartTestAttemptDto {
    @ApiProperty({
        description: 'Test ID to start an attempt for',
        example: 1,
    })
    @IsNumber()
    @IsNotEmpty()
    testId: number;
}

/*
 * Class #260: TestAttemptFilterDto
 * Source: test_attempts/dto/test-attempt-filter.dto.ts:12
 * Type: Exported Class
 * Methods: 0
 * Properties: 35
 * Decorators: 30
 * Complexity: 75
 * Size: 2007 characters (90 lines)
 */
export class TestAttemptFilterDto {
    @ApiProperty({
        description: 'Filter by test ID',
        example: 1,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    @Type(() => Number)
    testId?: number;

    @ApiProperty({
        description: 'Filter by user ID',
        example: '123e4567-e89b-12d3-a456-426614174000',
        required: false,
    })
    @IsOptional()
    @IsUUID()
    userId?: string;

    @ApiProperty({
        description: 'Filter by attempt status',
        enum: AttemptStatus,
        required: false,
    })
    @IsOptional()
    @IsEnum(AttemptStatus)
    status?: AttemptStatus;

    @ApiProperty({
        description: 'Filter by start date (from)',
        example: '2024-01-01T00:00:00.000Z',
        required: false,
    })
    @IsOptional()
    @IsDateString()
    startDateFrom?: string;

    @ApiProperty({
        description: 'Filter by start date (to)',
        example: '2024-01-31T23:59:59.999Z',
        required: false,
    })
    @IsOptional()
    @IsDateString()
    startDateTo?: string;

    @ApiProperty({
        description: 'Filter by submit date (from)',
        example: '2024-01-01T00:00:00.000Z',
        required: false,
    })
    @IsOptional()
    @IsDateString()
    submitDateFrom?: string;

    @ApiProperty({
        description: 'Filter by submit date (to)',
        example: '2024-01-31T23:59:59.999Z',
        required: false,
    })
    @IsOptional()
    @IsDateString()
    submitDateTo?: string;

    @ApiProperty({
        description: 'Page number for pagination',
        example: 1,
        default: 1,
        minimum: 1,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    @Type(() => Number)
    page?: number = 1;

    @ApiProperty({
        description: 'Number of items per page',
        example: 10,
        default: 10,
        minimum: 1,
        maximum: 100,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    @Type(() => Number)
    pageSize?: number = 10;
}

/*
 * Class #261: TestAttemptListResponseDto
 * Source: test_attempts/dto/test-attempt-list-response.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 7
 * Decorators: 7
 * Complexity: 15
 * Size: 916 characters (43 lines)
 */
export class TestAttemptListResponseDto {
    @ApiProperty({
        description: 'Array of test attempts',
        type: [TestAttemptResponseDto],
    })
    attempts: TestAttemptResponseDto[];

    @ApiProperty({
        description: 'Total number of attempts',
        example: 25,
    })
    total: number;

    @ApiProperty({
        description: 'Current page number',
        example: 1,
    })
    page: number;

    @ApiProperty({
        description: 'Number of items per page',
        example: 10,
    })
    pageSize: number;

    @ApiProperty({
        description: 'Total number of pages',
        example: 3,
    })
    totalPages: number;

    @ApiProperty({
        description: 'Whether there is a next page',
        example: true,
    })
    hasNext: boolean;

    @ApiProperty({
        description: 'Whether there is a previous page',
        example: false,
    })
    hasPrevious: boolean;
}

/*
 * Class #262: TestAttemptResponseDto
 * Source: test_attempts/dto/test-attempt-response.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 25
 * Decorators: 15
 * Complexity: 43
 * Size: 2720 characters (114 lines)
 */
export class TestAttemptResponseDto {
    @ApiProperty({
        description: 'Test attempt unique identifier',
        example: 1,
    })
    attemptId: number;

    @ApiProperty({
        description: 'Test ID for this attempt',
        example: 1,
    })
    testId: number;

    @ApiProperty({
        description: 'User ID who is taking the test',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    userId: string;

    @ApiProperty({
        description: 'Attempt number for this user and test',
        example: 1,
    })
    attemptNumber: number;

    @ApiProperty({
        description: 'Current status of the test attempt',
        example: AttemptStatus.IN_PROGRESS,
        enum: AttemptStatus,
    })
    status: AttemptStatus;

    @ApiProperty({
        description: 'When the test attempt started',
        example: '2024-01-01T09:00:00.000Z',
    })
    startTime: Date;

    @ApiProperty({
        description: 'When the test attempt was submitted',
        example: '2024-01-01T10:30:00.000Z',
        required: false,
    })
    submitTime?: Date;

    @ApiProperty({
        description: 'When the test attempt expires',
        example: '2024-01-01T11:00:00.000Z',
        required: false,
    })
    expiresAt?: Date;

    @ApiProperty({
        description: 'Current progress percentage (0-100)',
        example: 75.5,
    })
    progressPercentage: number;

    @ApiProperty({
        description: 'Test attempt creation timestamp',
        example: '2024-01-01T09:00:00.000Z',
    })
    createdAt: Date;

    @ApiProperty({
        description: 'Test attempt last update timestamp',
        example: '2024-01-01T10:15:30.123Z',
    })
    updatedAt: Date;

    @ApiProperty({
        description: 'Test information',
        example: {
            testId: 1,
            title: 'JavaScript Fundamentals Quiz',
            testType: 'quiz',
            durationMinutes: 120,
        },
    })
    test?: {
        testId: number;
        title: string;
        testType: string;
        durationMinutes?: number;
    };

    @ApiProperty({
        description: 'User information',
        example: {
            id: '123e4567-e89b-12d3-a456-426614174000',
            email: 'student@example.com',
            firstName: 'John',
            lastName: 'Doe',
        },
    })
    user?: {
        id: string;
        email: string;
        firstName: string;
        lastName: string;
    };

    @ApiProperty({
        description: 'Number of answers submitted for this attempt',
        example: 5,
    })
    answersCount?: number;

    @ApiProperty({
        description: 'Total number of questions in the test',
        example: 10,
    })
    totalQuestions?: number;
}

/*
 * Class #263: TestAttemptStatsDto
 * Source: test_attempts/dto/test-attempt-stats.dto.ts:3
 * Type: Exported Class
 * Methods: 0
 * Properties: 9
 * Decorators: 9
 * Complexity: 19
 * Size: 1361 characters (60 lines)
 */
export class TestAttemptStatsDto {
    @ApiProperty({
        description: 'Total number of attempts',
        example: 150,
    })
    totalAttempts: number;

    @ApiProperty({
        description: 'Number of completed attempts',
        example: 120,
    })
    completedAttempts: number;

    @ApiProperty({
        description: 'Number of in-progress attempts',
        example: 25,
    })
    inProgressAttempts: number;

    @ApiProperty({
        description: 'Number of expired attempts',
        example: 5,
    })
    expiredAttempts: number;

    @ApiProperty({
        description: 'Average completion time in minutes',
        example: 45.5,
    })
    averageCompletionTime: number;

    @ApiProperty({
        description: 'Average progress percentage',
        example: 85.2,
    })
    averageProgress: number;

    @ApiProperty({
        description: 'Completion rate percentage',
        example: 80.0,
    })
    completionRate: number;

    @ApiProperty({
        description: 'Most recent attempt date',
        example: '2024-01-15T10:30:00.000Z',
    })
    lastAttemptDate: Date;

    @ApiProperty({
        description: 'Statistics by status',
        example: {
            in_progress: 25,
            submitted: 120,
            expired: 5,
            cancelled: 0,
        },
    })
    statusBreakdown: Record<string, number>;
}

/*
 * Class #264: UpdateTestAttemptDto
 * Source: test_attempts/dto/update-test_attempt.dto.ts:5
 * Type: Exported Class
 * Methods: 0
 * Properties: 7
 * Decorators: 8
 * Complexity: 20
 * Size: 563 characters (24 lines)
 */
export class UpdateTestAttemptDto {
    @ApiProperty({
        description: 'Update the status of the test attempt',
        example: AttemptStatus.SUBMITTED,
        enum: AttemptStatus,
        required: false,
    })
    @IsOptional()
    @IsEnum(AttemptStatus)
    status?: AttemptStatus;

    @ApiProperty({
        description: 'Update progress percentage (0-100)',
        example: 85.5,
        minimum: 0,
        maximum: 100,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    @Min(0)
    @Max(100)
    progressPercentage?: number;
}

/*
 * Class #265: TestAttempt
 * Source: test_attempts/entities/test_attempt.entity.ts:38
 * Type: Exported Class
 * Methods: 1
 * Properties: 36
 * Decorators: 42
 * Complexity: 94
 * Size: 3218 characters (132 lines)
 */
export class TestAttempt {
    @PrimaryGeneratedColumn()
    @ApiProperty({
        description: 'Test attempt unique identifier',
        example: 1,
    })
    attemptId: number;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Test ID for this attempt',
        example: 1,
    })
    @IsNumber()
    testId: number;

    @Column('uuid')
    @Index()
    @ApiProperty({
        description: 'User ID who is taking the test',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @IsUUID()
    userId: string;

    @Column()
    @ApiProperty({
        description: 'Attempt number for this user and test',
        example: 1,
        minimum: 1,
    })
    @IsNumber()
    attemptNumber: number;

    @Column({
        type: 'enum',
        enum: AttemptStatus,
        default: AttemptStatus.IN_PROGRESS,
    })
    @ApiProperty({
        description: 'Current status of the test attempt',
        example: AttemptStatus.IN_PROGRESS,
        enum: AttemptStatus,
    })
    @IsEnum(AttemptStatus)
    status: AttemptStatus;

    @Column({ type: 'timestamp' })
    @ApiProperty({
        description: 'When the test attempt started',
        example: '2024-01-01T09:00:00.000Z',
    })
    @IsDateString()
    startTime: Date;

    @Column({ type: 'timestamp', nullable: true })
    @ApiProperty({
        description: 'When the test attempt was submitted',
        example: '2024-01-01T10:30:00.000Z',
        required: false,
    })
    @IsOptional()
    @IsDateString()
    submitTime?: Date;

    @Column({ type: 'timestamp', nullable: true })
    @ApiProperty({
        description: 'When the test attempt expires (based on duration)',
        example: '2024-01-01T11:00:00.000Z',
        required: false,
    })
    @IsOptional()
    @IsDateString()
    expiresAt?: Date;

    @Column({ type: 'decimal', precision: 5, scale: 2, default: 0 })
    @ApiProperty({
        description: 'Current progress percentage (0-100)',
        example: 75.5,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    progressPercentage: number;

    @CreateDateColumn()
    @ApiProperty({
        description: 'Test attempt creation timestamp',
        example: '2024-01-01T09:00:00.000Z',
    })
    createdAt: Date;

    @UpdateDateColumn()
    @ApiProperty({
        description: 'Test attempt last update timestamp',
        example: '2024-01-01T10:15:30.123Z',
    })
    updatedAt: Date;

    @ManyToOne(() => Organization, { nullable: false })
    @ApiProperty({
        description: 'Organization this test attempt belongs to',
        type: () => Organization,
    })
    orgId: Organization;

    @ManyToOne(() => Branch, { nullable: true })
    @ApiProperty({
        description: 'Branch this test attempt belongs to',
        type: () => Branch,
        required: false,
    })
    branchId?: Branch;

    // Relations
    @ManyToOne(() => Test, { onDelete: 'RESTRICT' })
    test: Test;

    @ManyToOne(() => User, { onDelete: 'RESTRICT' })
    user: User;

    @OneToMany('Answer', 'attempt')
    answers: any[];

    @OneToMany('Result', 'attempt')
    results: any[];

    constructor(partial: Partial<TestAttempt>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #266: TestAttemptsController
 * Source: test_attempts/test_attempts.controller.ts:36
 * Type: Exported Class
 * Methods: 6
 * Properties: 218
 * Decorators: 58
 * Complexity: 154
 * Size: 14912 characters (455 lines)
 */
export class TestAttemptsController {
    constructor(private readonly testAttemptsService: TestAttemptsService) {}

    @Post('start')
    @ApiOperation({
        summary: '🚀 Start Test Attempt',
        description: `
        **Start a new test attempt for a student**
        
        This endpoint allows students to begin taking a test. The system will:
        - Validate test availability and user access
        - Check maximum attempt limits
        - Ensure no active attempts exist for this test
        - Calculate expiration time based on test duration
        - Create a new attempt record with IN_PROGRESS status
        
        **Business Rules:**
        - Users cannot exceed the maximum attempts set for the test
        - Only one active attempt per test per user is allowed
        - Test must be active to start new attempts
        - Expiration time is calculated automatically if test has duration limit
        
        **Security:**
        - JWT authentication required
        - Users can only start attempts for themselves
        - Access control validation performed
        `,
    })
    @ApiBody({
        type: CreateTestAttemptDto,
        description: 'Test attempt details',
        examples: {
            basicAttempt: {
                summary: 'Basic test attempt',
                description: 'Start an attempt for a quiz',
                value: {
                    testId: 1,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description: '✅ Test attempt started successfully',
        type: TestAttemptResponseDto,
        example: {
            attemptId: 1,
            testId: 1,
            userId: '123e4567-e89b-12d3-a456-426614174000',
            attemptNumber: 1,
            status: 'in_progress',
            startTime: '2024-01-01T09:00:00.000Z',
            submitTime: null,
            expiresAt: '2024-01-01T11:00:00.000Z',
            progressPercentage: 0,
            createdAt: '2024-01-01T09:00:00.000Z',
            updatedAt: '2024-01-01T09:00:00.000Z',
            test: {
                testId: 1,
                title: 'JavaScript Fundamentals Quiz',
                testType: 'quiz',
                durationMinutes: 120,
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid request or business rule violation',
        example: {
            statusCode: 400,
            message: 'Maximum attempts (3) exceeded for this test',
            error: 'Bad Request',
        },
    })
    @ApiResponse({
        status: HttpStatus.CONFLICT,
        description: '❌ Active attempt already exists',
        example: {
            statusCode: 409,
            message: 'You already have an active attempt for this test',
            error: 'Conflict',
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Test not found',
        example: {
            statusCode: 404,
            message: 'Test not found',
            error: 'Not Found',
        },
    })
    async startAttempt(
        @Body() createTestAttemptDto: CreateTestAttemptDto,
        @OrgBranchScope() scope: OrgBranchScope,
        @Req() req: AuthenticatedRequest,
    ): Promise<TestAttemptResponseDto> {
        return this.testAttemptsService.startAttempt(
            createTestAttemptDto,
            scope,
            req.user.id,
        );
    }

    @Post(':id/submit')
    @ApiOperation({
        summary: '📋 Submit Test Attempt',
        description: `
        **Submit a completed test attempt**
        
        This endpoint allows students to submit their test when finished. The system will:
        - Validate attempt ownership and status
        - Update attempt status to SUBMITTED
        - Record submission timestamp
        - Set progress to 100%
        - Trigger result calculation (if auto-grading enabled)
        
        **Business Rules:**
        - Only IN_PROGRESS attempts can be submitted
        - Once submitted, attempts cannot be modified
        - Submission is final and irreversible
        - Auto-grading will be triggered for objective questions
        
        **Security:**
        - JWT authentication required
        - Users can only submit their own attempts
        - Ownership validation performed
        `,
    })
    @ApiParam({
        name: 'id',
        description: 'Test attempt ID to submit',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Test attempt submitted successfully',
        type: TestAttemptResponseDto,
        example: {
            attemptId: 1,
            testId: 1,
            userId: '123e4567-e89b-12d3-a456-426614174000',
            attemptNumber: 1,
            status: 'submitted',
            startTime: '2024-01-01T09:00:00.000Z',
            submitTime: '2024-01-01T10:30:00.000Z',
            expiresAt: '2024-01-01T11:00:00.000Z',
            progressPercentage: 100,
            createdAt: '2024-01-01T09:00:00.000Z',
            updatedAt: '2024-01-01T10:30:00.000Z',
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Cannot submit non-active attempt',
        example: {
            statusCode: 400,
            message: 'Cannot submit attempt that is not in progress',
            error: 'Bad Request',
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Test attempt not found',
        example: {
            statusCode: 404,
            message: 'Test attempt not found',
            error: 'Not Found',
        },
    })
    async submitAttempt(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
        @Req() req: AuthenticatedRequest,
    ): Promise<TestAttemptResponseDto> {
        return this.testAttemptsService.submitAttempt(id, scope, req.user.id);
    }

    @Patch(':id/progress')
    @ApiOperation({
        summary: '📈 Update Test Progress',
        description: `
        **Update progress for an in-progress test attempt**
        
        This endpoint allows updating the progress percentage and other
        modifiable fields while a test is in progress. Useful for:
        - Tracking completion percentage as questions are answered
        - Updating time spent on the test
        - Recording intermediate saves
        
        **Business Rules:**
        - Only IN_PROGRESS attempts can be updated
        - Progress percentage must be between 0-100
        - Cannot update submitted or expired attempts
        - Automatic progress calculation based on answered questions
        
        **Security:**
        - JWT authentication required
        - Users can only update their own attempts
        - Progress validation performed
        `,
    })
    @ApiParam({
        name: 'id',
        description: 'Test attempt ID to update',
        example: 1,
    })
    @ApiBody({
        type: UpdateTestAttemptDto,
        description: 'Progress update data',
        examples: {
            progressUpdate: {
                summary: 'Update progress percentage',
                description: 'Update how much of the test is completed',
                value: {
                    progressPercentage: 45,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Progress updated successfully',
        type: TestAttemptResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid progress data or attempt not in progress',
        example: {
            statusCode: 400,
            message: 'Cannot update progress for submitted attempt',
            error: 'Bad Request',
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Test attempt not found',
    })
    async updateProgress(
        @Param('id', ParseIntPipe) id: number,
        @Body() updateTestAttemptDto: UpdateTestAttemptDto,
        @OrgBranchScope() scope: OrgBranchScope,
        @Req() req: AuthenticatedRequest,
    ): Promise<TestAttemptResponseDto> {
        return this.testAttemptsService.updateProgress(
            id,
            updateTestAttemptDto,
            scope,
            req.user.id,
        );
    }

    @Get('my-attempts')
    @ApiOperation({
        summary: '📚 Get My Test Attempts',
        description: `
        **Retrieve all test attempts for the authenticated user**
        
        This endpoint returns a paginated list of test attempts created by
        the current user. Supports filtering by test ID and pagination.
        
        **Features:**
        - Pagination support with configurable page size
        - Optional filtering by specific test
        - Sorted by creation date (newest first)
        - Includes attempt status and progress information
        
        **Use Cases:**
        - Student dashboard showing recent attempts
        - Test history and progress tracking
        - Resuming incomplete attempts
        - Performance analytics
        `,
    })
    @ApiQuery({
        name: 'testId',
        description: 'Filter attempts by specific test ID',
        required: false,
        example: 1,
    })
    @ApiQuery({
        name: 'page',
        description: 'Page number for pagination (1-based)',
        required: false,
        example: 1,
    })
    @ApiQuery({
        name: 'pageSize',
        description: 'Number of attempts per page',
        required: false,
        example: 10,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ User attempts retrieved successfully',
        example: {
            attempts: [
                {
                    attemptId: 1,
                    testId: 1,
                    attemptNumber: 1,
                    status: 'submitted',
                    startTime: '2024-01-01T09:00:00.000Z',
                    submitTime: '2024-01-01T10:30:00.000Z',
                    progressPercentage: 100,
                },
                {
                    attemptId: 2,
                    testId: 2,
                    attemptNumber: 1,
                    status: 'in_progress',
                    startTime: '2024-01-02T14:00:00.000Z',
                    submitTime: null,
                    progressPercentage: 75,
                },
            ],
            total: 2,
            page: 1,
            pageSize: 10,
        },
    })
    async getMyAttempts(
        @OrgBranchScope() scope: OrgBranchScope,
        @Req() req: AuthenticatedRequest,
        @Query('testId') testId?: number,
        @Query('page') page: number = 1,
        @Query('pageSize') pageSize: number = 10,
    ) {
        return this.testAttemptsService.getUserAttempts(
            req.user.id,
            scope,
            testId,
            page,
            pageSize,
        );
    }

    @Get(':id')
    @ApiOperation({
        summary: '🔍 Get Test Attempt Details',
        description: `
        **Retrieve detailed information about a specific test attempt**
        
        This endpoint returns comprehensive details about a test attempt
        including progress, timing, and associated test information.
        
        **Included Information:**
        - Attempt status and progress
        - Start/submit timestamps
        - Test details and configuration
        - Expiration information
        - Answer summary (if applicable)
        
        **Security:**
        - Users can only view their own attempts
        - Ownership validation performed
        - Sensitive data filtered based on attempt status
        `,
    })
    @ApiParam({
        name: 'id',
        description: 'Test attempt ID to retrieve',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Test attempt details retrieved successfully',
        type: TestAttemptResponseDto,
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Test attempt not found or access denied',
        example: {
            statusCode: 404,
            message: 'Test attempt not found',
            error: 'Not Found',
        },
    })
    async findOne(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
        @Req() req: AuthenticatedRequest,
    ): Promise<TestAttemptResponseDto> {
        return this.testAttemptsService.findOne(id, scope, req.user.id);
    }

    @Delete(':id/cancel')
    @ApiOperation({
        summary: '❌ Cancel Test Attempt',
        description: `
        **Cancel an in-progress test attempt**
        
        This endpoint allows students to cancel an active test attempt.
        The attempt status will be changed to CANCELLED and cannot be resumed.
        
        **Business Rules:**
        - Only IN_PROGRESS attempts can be cancelled
        - Cancelled attempts count towards the maximum attempt limit
        - Cancellation is permanent and irreversible
        - No results are generated for cancelled attempts
        
        **Use Cases:**
        - Student decides not to complete the test
        - Technical issues preventing test completion
        - Accidental test start
        
        **Security:**
        - JWT authentication required
        - Users can only cancel their own attempts
        - Ownership validation performed
        `,
    })
    @ApiParam({
        name: 'id',
        description: 'Test attempt ID to cancel',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Test attempt cancelled successfully',
        type: TestAttemptResponseDto,
        example: {
            attemptId: 1,
            testId: 1,
            userId: '123e4567-e89b-12d3-a456-426614174000',
            attemptNumber: 1,
            status: 'cancelled',
            startTime: '2024-01-01T09:00:00.000Z',
            submitTime: null,
            progressPercentage: 45,
            createdAt: '2024-01-01T09:00:00.000Z',
            updatedAt: '2024-01-01T09:15:00.000Z',
        },
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Cannot cancel non-active attempt',
        example: {
            statusCode: 400,
            message: 'Cannot cancel attempt that is not in progress',
            error: 'Bad Request',
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ Test attempt not found',
    })
    async cancelAttempt(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() scope: OrgBranchScope,
        @Req() req: AuthenticatedRequest,
    ): Promise<TestAttemptResponseDto> {
        return this.testAttemptsService.cancelAttempt(id, scope, req.user.id);
    }
}

/*
 * Class #267: TestAttemptsModule
 * Source: test_attempts/test_attempts.module.ts:21
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 34 characters (1 lines)
 */
export class TestAttemptsModule {}

/*
 * Class #268: TestAttemptsService
 * Source: test_attempts/test_attempts.service.ts:25
 * Type: Exported Class
 * Methods: 50
 * Properties: 123
 * Decorators: 3
 * Complexity: 288
 * Size: 23261 characters (701 lines)
 */
export class TestAttemptsService {
    private readonly logger = new Logger(TestAttemptsService.name);

    constructor(
        @InjectRepository(TestAttempt)
        private readonly testAttemptRepository: Repository<TestAttempt>,
        @InjectRepository(Test)
        private readonly testRepository: Repository<Test>,
        @InjectRepository(User)
        private readonly userRepository: Repository<User>,
        private readonly dataSource: DataSource,
        private readonly resultsService: ResultsService,
        private readonly answersService: AnswersService,
    ) {}

    /**
     * Retry database operations with exponential backoff
     */
    private async retryOperation<T>(
        operation: () => Promise<T>,
        maxRetries: number = 3,
        delay: number = 1000,
    ): Promise<T> {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error: any) {
                if (attempt === maxRetries) {
                    this.logger.error(
                        `Operation failed after ${maxRetries} attempts`,
                        error instanceof Error ? error.stack : String(error),
                    );
                    throw error;
                }
                this.logger.warn(
                    `Operation failed, attempt ${attempt}/${maxRetries}. Retrying in ${delay}ms...`,
                );
                await new Promise(resolve =>
                    setTimeout(resolve, delay * attempt),
                );
            }
        }
        throw new Error('Retry operation failed unexpectedly');
    }

    /**
     * Start a new test attempt
     */
    async startAttempt(
        createAttemptDto: CreateTestAttemptDto,
        scope: OrgBranchScope,
        userId: string,
    ): Promise<TestAttemptResponseDto> {
        return this.retryOperation(async () => {
            // Get test details with org/branch validation
            const test = await this.testRepository.findOne({
                where: { testId: createAttemptDto.testId },
                relations: ['course', 'orgId', 'branchId'],
            });

            if (!test) {
                throw new NotFoundException('Test not found');
            }

            // Validate org/branch access
            if (scope.orgId && test.orgId?.id !== scope.orgId) {
                throw new ForbiddenException('Access denied to this test');
            }
            if (scope.branchId && test.branchId?.id !== scope.branchId) {
                throw new ForbiddenException('Access denied to this test');
            }

            if (!test.isActive) {
                throw new BadRequestException('Test is not active');
            }

            // Check if user has exceeded max attempts
            const userAttempts = await this.testAttemptRepository.count({
                where: {
                    testId: createAttemptDto.testId,
                    userId,
                },
            });

            if (userAttempts >= test.maxAttempts) {
                throw new BadRequestException(
                    `Maximum attempts (${test.maxAttempts}) exceeded for this test`,
                );
            }

            // Check if user has an active attempt
            const activeAttempt = await this.testAttemptRepository.findOne({
                where: {
                    testId: createAttemptDto.testId,
                    userId,
                    status: AttemptStatus.IN_PROGRESS,
                },
            });

            if (activeAttempt) {
                throw new ConflictException(
                    'You already have an active attempt for this test',
                );
            }

            // Calculate expiration time
            const startTime = new Date();
            const expiresAt = test.durationMinutes
                ? new Date(startTime.getTime() + test.durationMinutes * 60000)
                : undefined;

            // Create new attempt
            const attempt = this.testAttemptRepository.create({
                testId: createAttemptDto.testId,
                userId,
                attemptNumber: userAttempts + 1,
                status: AttemptStatus.IN_PROGRESS,
                startTime,
                expiresAt,
                progressPercentage: 0,
                // Inherit org/branch from test
                orgId: test.orgId,
                branchId: test.branchId,
            });

            const savedAttempt = await this.testAttemptRepository.save(attempt);

            return this.mapToResponseDto(savedAttempt);
        });
    }

    /**
     * Submit a test attempt
     */
    async submitAttempt(
        attemptId: number,
        scope: OrgBranchScope,
        userId: string,
    ): Promise<TestAttemptResponseDto> {
        return this.retryOperation(async () => {
            const attempt = await this.findAttemptByIdAndUserWithScope(
                attemptId,
                userId,
                scope,
            );

            if (attempt.status !== AttemptStatus.IN_PROGRESS) {
                throw new BadRequestException(
                    'Cannot submit attempt that is not in progress',
                );
            }

            // Update attempt status
            attempt.status = AttemptStatus.SUBMITTED;
            attempt.submitTime = new Date();
            attempt.progressPercentage = 100;

            const savedAttempt = await this.testAttemptRepository.save(attempt);

            // Trigger auto-marking and result creation flow
            try {
                this.logger.log(
                    `Starting auto-processing for attempt ${attemptId}`,
                );

                // Step 1: Auto-mark objective questions
                await this.answersService.autoMark(attemptId);
                this.logger.log(
                    `Auto-marking completed for attempt ${attemptId}`,
                );

                // Step 2: Create result based on marked answers
                const result =
                    await this.resultsService.createFromAttempt(attemptId);
                this.logger.log(
                    `Result created for attempt ${attemptId}: ${result.resultId}`,
                );

                this.logger.log(
                    `Auto-processing completed successfully for attempt ${attemptId}`,
                );
            } catch (error) {
                this.logger.error(
                    `Error during auto-processing for attempt ${attemptId}`,
                    error instanceof Error ? error.stack : String(error),
                );
                // Don't throw here - the attempt submission itself was successful
                // The processing can be retried later if needed
            }

            return this.mapToResponseDto(savedAttempt);
        });
    }

    /**
     * Update test attempt progress
     */
    async updateProgress(
        attemptId: number,
        updateDto: UpdateTestAttemptDto,
        scope: OrgBranchScope,
        userId: string,
    ): Promise<TestAttemptResponseDto> {
        return this.retryOperation(async () => {
            const attempt = await this.findAttemptByIdAndUserWithScope(
                attemptId,
                userId,
                scope,
            );

            if (attempt.status !== AttemptStatus.IN_PROGRESS) {
                throw new BadRequestException(
                    'Cannot update progress for completed attempt',
                );
            }

            // Check if attempt has expired
            if (attempt.expiresAt && new Date() > attempt.expiresAt) {
                attempt.status = AttemptStatus.EXPIRED;
                await this.testAttemptRepository.save(attempt);
                throw new BadRequestException('Test attempt has expired');
            }

            // Update fields
            if (updateDto.progressPercentage !== undefined) {
                attempt.progressPercentage = updateDto.progressPercentage;
            }
            if (updateDto.status !== undefined) {
                attempt.status = updateDto.status;
                if (updateDto.status === AttemptStatus.SUBMITTED) {
                    attempt.submitTime = new Date();
                    attempt.progressPercentage = 100;
                }
            }

            const savedAttempt = await this.testAttemptRepository.save(attempt);

            return this.mapToResponseDto(savedAttempt);
        });
    }

    /**
     * Get user's test attempts
     */
    async getUserAttempts(
        userId: string,
        scope: OrgBranchScope,
        testId?: number,
        page: number = 1,
        pageSize: number = 10,
    ): Promise<{
        attempts: TestAttemptResponseDto[];
        total: number;
        page: number;
        pageSize: number;
    }> {
        return this.retryOperation(async () => {
            const query = this.testAttemptRepository
                .createQueryBuilder('attempt')
                .leftJoinAndSelect('attempt.test', 'test')
                .leftJoinAndSelect('attempt.orgId', 'org')
                .leftJoinAndSelect('attempt.branchId', 'branch')
                .where('attempt.userId = :userId', { userId });

            // Apply org/branch scoping
            if (scope.orgId) {
                query.andWhere(
                    '(attempt.orgId IS NULL OR attempt.orgId = :orgId)',
                    { orgId: scope.orgId },
                );
            }
            if (scope.branchId) {
                query.andWhere(
                    '(attempt.branchId IS NULL OR attempt.branchId = :branchId)',
                    { branchId: scope.branchId },
                );
            }

            if (testId) {
                query.andWhere('attempt.testId = :testId', { testId });
            }

            query
                .orderBy('attempt.createdAt', 'DESC')
                .skip((page - 1) * pageSize)
                .take(pageSize);

            const [attempts, total] = await query.getManyAndCount();

            return {
                attempts: attempts.map(attempt =>
                    this.mapToResponseDto(attempt),
                ),
                total,
                page,
                pageSize,
            };
        });
    }

    /**
     * Get attempt by ID with access control
     */
    async findOne(
        attemptId: number,
        scope: OrgBranchScope,
        userId: string,
    ): Promise<TestAttemptResponseDto> {
        return this.retryOperation(async () => {
            const attempt = await this.findAttemptByIdAndUserWithScope(
                attemptId,
                userId,
                scope,
            );
            return this.mapToResponseDto(attempt);
        });
    }

    /**
     * Cancel an active attempt
     */
    async cancelAttempt(
        attemptId: number,
        scope: OrgBranchScope,
        userId: string,
    ): Promise<TestAttemptResponseDto> {
        return this.retryOperation(async () => {
            const attempt = await this.findAttemptByIdAndUserWithScope(
                attemptId,
                userId,
                scope,
            );

            if (attempt.status !== AttemptStatus.IN_PROGRESS) {
                throw new BadRequestException(
                    'Cannot cancel attempt that is not in progress',
                );
            }

            attempt.status = AttemptStatus.CANCELLED;
            const savedAttempt = await this.testAttemptRepository.save(attempt);

            return this.mapToResponseDto(savedAttempt);
        });
    }

    /**
     * Private helper to find attempt by ID and validate user access
     */
    private async findAttemptByIdAndUser(
        attemptId: number,
        userId: string,
    ): Promise<TestAttempt> {
        const attempt = await this.testAttemptRepository.findOne({
            where: {
                attemptId,
                userId,
            },
            relations: ['test', 'test.course'],
        });

        if (!attempt) {
            throw new NotFoundException('Test attempt not found');
        }

        return attempt;
    }

    private async findAttemptByIdAndUserWithScope(
        attemptId: number,
        userId: string,
        scope: OrgBranchScope,
    ): Promise<TestAttempt> {
        const attempt = await this.testAttemptRepository.findOne({
            where: {
                attemptId,
                userId,
            },
            relations: ['test', 'test.course', 'orgId', 'branchId'],
        });

        if (!attempt) {
            throw new NotFoundException('Test attempt not found');
        }

        // Validate org/branch access
        if (scope.orgId && attempt.orgId?.id !== scope.orgId) {
            throw new ForbiddenException('Access denied to this test attempt');
        }
        if (scope.branchId && attempt.branchId?.id !== scope.branchId) {
            throw new ForbiddenException('Access denied to this test attempt');
        }

        return attempt;
    }

    /**
     * Map entity to response DTO
     */
    private mapToResponseDto(attempt: TestAttempt): TestAttemptResponseDto {
        return {
            attemptId: attempt.attemptId,
            testId: attempt.testId,
            userId: attempt.userId,
            attemptNumber: attempt.attemptNumber,
            status: attempt.status,
            startTime: attempt.startTime,
            submitTime: attempt.submitTime,
            expiresAt: attempt.expiresAt,
            progressPercentage: attempt.progressPercentage,
            createdAt: attempt.createdAt,
            updatedAt: attempt.updatedAt,
            test: attempt.test
                ? {
                      testId: attempt.test.testId,
                      title: attempt.test.title,
                      testType: attempt.test.testType,
                      durationMinutes: attempt.test.durationMinutes,
                  }
                : undefined,
            user: attempt.user
                ? {
                      id: attempt.user.id,
                      email: attempt.user.email,
                      firstName: attempt.user.firstName,
                      lastName: attempt.user.lastName,
                  }
                : undefined,
        };
    }

    /**
     * Get attempts for a specific test (instructor view)
     */
    async findAttemptsByTest(
        testId: number,
        userId: string,
        filters?: TestAttemptFilterDto,
    ): Promise<TestAttemptListResponseDto> {
        return this.retryOperation(async () => {
            // Verify user has access to this test (is instructor/creator)
            const test = await this.testRepository.findOne({
                where: { testId },
                relations: ['course'],
            });

            if (!test) {
                throw new NotFoundException('Test not found');
            }

            // For now, allow any authenticated user to view attempts
            // In a real system, you'd check if user is instructor/admin

            const query = this.testAttemptRepository
                .createQueryBuilder('attempt')
                .leftJoinAndSelect('attempt.test', 'test')
                .leftJoinAndSelect('attempt.user', 'user')
                .where('attempt.testId = :testId', { testId });

            // Apply filters
            if (filters?.status) {
                query.andWhere('attempt.status = :status', {
                    status: filters.status,
                });
            }
            if (filters?.userId) {
                query.andWhere('attempt.userId = :userId', {
                    userId: filters.userId,
                });
            }
            if (filters?.startDateFrom) {
                query.andWhere('attempt.startTime >= :startDateFrom', {
                    startDateFrom: filters.startDateFrom,
                });
            }
            if (filters?.startDateTo) {
                query.andWhere('attempt.startTime <= :startDateTo', {
                    startDateTo: filters.startDateTo,
                });
            }

            query.orderBy('attempt.createdAt', 'DESC');

            const page = filters?.page || 1;
            const pageSize = filters?.pageSize || 10;
            const offset = (page - 1) * pageSize;

            const [attempts, total] = await query
                .skip(offset)
                .take(pageSize)
                .getManyAndCount();

            const totalPages = Math.ceil(total / pageSize);

            return {
                attempts: attempts.map(attempt =>
                    this.mapToResponseDto(attempt),
                ),
                total,
                page,
                pageSize,
                totalPages,
                hasNext: page < totalPages,
                hasPrevious: page > 1,
            };
        });
    }

    /**
     * Validate if user can attempt a test
     */
    async validateAttemptLimits(
        testId: number,
        userId: string,
    ): Promise<{
        canAttempt: boolean;
        reason?: string;
        attemptsUsed: number;
        maxAttempts: number;
    }> {
        return this.retryOperation(async () => {
            const test = await this.testRepository.findOne({
                where: { testId },
            });

            if (!test) {
                throw new NotFoundException('Test not found');
            }

            if (!test.isActive) {
                return {
                    canAttempt: false,
                    reason: 'Test is not active',
                    attemptsUsed: 0,
                    maxAttempts: test.maxAttempts,
                };
            }

            const attemptsUsed = await this.testAttemptRepository.count({
                where: { testId, userId },
            });

            const activeAttempt = await this.testAttemptRepository.findOne({
                where: {
                    testId,
                    userId,
                    status: AttemptStatus.IN_PROGRESS,
                },
            });

            if (activeAttempt) {
                return {
                    canAttempt: false,
                    reason: 'Active attempt already exists',
                    attemptsUsed,
                    maxAttempts: test.maxAttempts,
                };
            }

            if (attemptsUsed >= test.maxAttempts) {
                return {
                    canAttempt: false,
                    reason: `Maximum attempts (${test.maxAttempts}) exceeded`,
                    attemptsUsed,
                    maxAttempts: test.maxAttempts,
                };
            }

            return {
                canAttempt: true,
                attemptsUsed,
                maxAttempts: test.maxAttempts,
            };
        });
    }

    /**
     * Calculate and update score for an attempt
     */
    async calculateScore(attemptId: number): Promise<TestAttemptResponseDto> {
        return this.retryOperation(async () => {
            const attempt = await this.testAttemptRepository.findOne({
                where: { attemptId },
                relations: [
                    'test',
                    'answers',
                    'answers.question',
                    'answers.selectedOption',
                ],
            });

            if (!attempt) {
                throw new NotFoundException('Test attempt not found');
            }

            if (attempt.status !== AttemptStatus.SUBMITTED) {
                throw new BadRequestException(
                    'Can only calculate score for submitted attempts',
                );
            }

            // This is a placeholder for score calculation
            // In a real implementation, you'd calculate based on answers
            // For now, we'll just update the progress to 100%
            attempt.progressPercentage = 100;

            const savedAttempt = await this.testAttemptRepository.save(attempt);
            return this.mapToResponseDto(savedAttempt);
        });
    }

    /**
     * Get statistics for test attempts
     */
    async getStats(
        testId?: number,
        userId?: string,
    ): Promise<TestAttemptStatsDto> {
        return this.retryOperation(async () => {
            const query =
                this.testAttemptRepository.createQueryBuilder('attempt');

            if (testId) {
                query.where('attempt.testId = :testId', { testId });
            }
            if (userId) {
                query.andWhere('attempt.userId = :userId', { userId });
            }

            const attempts = await query.getMany();

            const totalAttempts = attempts.length;
            const completedAttempts = attempts.filter(
                a => a.status === AttemptStatus.SUBMITTED,
            ).length;
            const inProgressAttempts = attempts.filter(
                a => a.status === AttemptStatus.IN_PROGRESS,
            ).length;
            const expiredAttempts = attempts.filter(
                a => a.status === AttemptStatus.EXPIRED,
            ).length;

            const statusBreakdown = attempts.reduce(
                (acc, attempt) => {
                    acc[attempt.status] = (acc[attempt.status] || 0) + 1;
                    return acc;
                },
                {} as Record<string, number>,
            );

            const completedWithTime = attempts.filter(
                a =>
                    a.status === AttemptStatus.SUBMITTED &&
                    a.submitTime &&
                    a.startTime,
            );

            const averageCompletionTime =
                completedWithTime.length > 0
                    ? completedWithTime.reduce((sum, attempt) => {
                          const duration =
                              attempt.submitTime!.getTime() -
                              attempt.startTime.getTime();
                          return sum + duration / (1000 * 60); // Convert to minutes
                      }, 0) / completedWithTime.length
                    : 0;

            const averageProgress =
                totalAttempts > 0
                    ? attempts.reduce(
                          (sum, attempt) => sum + attempt.progressPercentage,
                          0,
                      ) / totalAttempts
                    : 0;

            const completionRate =
                totalAttempts > 0
                    ? (completedAttempts / totalAttempts) * 100
                    : 0;

            const lastAttemptDate =
                attempts.length > 0
                    ? new Date(
                          Math.max(...attempts.map(a => a.createdAt.getTime())),
                      )
                    : new Date();

            return {
                totalAttempts,
                completedAttempts,
                inProgressAttempts,
                expiredAttempts,
                averageCompletionTime,
                averageProgress,
                completionRate,
                lastAttemptDate,
                statusBreakdown,
            };
        });
    }
}

/*
 * Class #269: CreateTrainingProgressDto
 * Source: training_progress/dto/create-training_progress.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 14
 * Decorators: 18
 * Complexity: 45
 * Size: 1403 characters (63 lines)
 */
export class CreateTrainingProgressDto {
    @ApiProperty({
        description: 'User ID tracking progress',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @IsUUID()
    userId: string;

    @ApiProperty({
        description: 'Course ID for progress tracking',
        example: 1,
    })
    @IsNumber()
    courseId: number;

    @ApiProperty({
        description: 'Specific test ID (optional for overall course progress)',
        example: 1,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    testId?: number;

    @ApiProperty({
        description: 'Completion percentage (0-100)',
        example: 75.5,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    completionPercentage: number;

    @ApiProperty({
        description: 'Total time spent in minutes',
        example: 120,
        minimum: 0,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    timeSpentMinutes?: number;

    @ApiProperty({
        description: 'Number of questions completed',
        example: 25,
        minimum: 0,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    questionsCompleted?: number;

    @ApiProperty({
        description: 'Total number of questions in the test/course',
        example: 30,
        minimum: 0,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    totalQuestions?: number;
}

/*
 * Class #270: LearningTrendDto
 * Source: training_progress/dto/progress-analytics.dto.ts:5
 * Type: Exported Class
 * Methods: 0
 * Properties: 9
 * Decorators: 10
 * Complexity: 24
 * Size: 793 characters (36 lines)
 */
export class LearningTrendDto {
    @ApiProperty({
        description: 'Time period (week/month)',
        example: '2024-W03',
    })
    @IsString()
    period: string;

    @ApiProperty({
        description: 'Average completion percentage for this period',
        example: 65.5,
    })
    @IsNumber()
    averageCompletion: number;

    @ApiProperty({
        description: 'Total time spent in this period (minutes)',
        example: 1200,
    })
    @IsNumber()
    totalTimeSpent: number;

    @ApiProperty({
        description: 'Number of active learners',
        example: 45,
    })
    @IsNumber()
    activeLearners: number;

    @ApiProperty({
        description: 'Number of questions completed',
        example: 350,
    })
    @IsNumber()
    questionsCompleted: number;
}

/*
 * Class #271: CourseProgressBreakdownDto
 * Source: training_progress/dto/progress-analytics.dto.ts:42
 * Type: Exported Class
 * Methods: 0
 * Properties: 10
 * Decorators: 16
 * Complexity: 34
 * Size: 1166 characters (57 lines)
 */
export class CourseProgressBreakdownDto {
    @ApiProperty({
        description: 'Course ID',
        example: 1,
    })
    @IsNumber()
    courseId: number;

    @ApiProperty({
        description: 'Course title',
        example: 'Web Development Bootcamp',
    })
    @IsString()
    courseTitle: string;

    @ApiProperty({
        description: 'Total enrolled users',
        example: 120,
    })
    @IsNumber()
    totalEnrolled: number;

    @ApiProperty({
        description: 'Users who started',
        example: 100,
    })
    @IsNumber()
    usersStarted: number;

    @ApiProperty({
        description: 'Users who completed',
        example: 65,
    })
    @IsNumber()
    usersCompleted: number;

    @ApiProperty({
        description: 'Average completion percentage',
        example: 72.5,
    })
    @IsNumber()
    averageCompletion: number;

    @ApiProperty({
        description: 'Average time per user (minutes)',
        example: 180,
    })
    @IsNumber()
    averageTimePerUser: number;

    @ApiProperty({
        description: 'Completion rate percentage',
        example: 65.0,
    })
    @IsNumber()
    completionRate: number;
}

/*
 * Class #272: LearningPathAnalysisDto
 * Source: training_progress/dto/progress-analytics.dto.ts:100
 * Type: Exported Class
 * Methods: 0
 * Properties: 10
 * Decorators: 12
 * Complexity: 27
 * Size: 918 characters (43 lines)
 */
export class LearningPathAnalysisDto {
    @ApiProperty({
        description: 'Test ID',
        example: 1,
    })
    @IsNumber()
    testId: number;

    @ApiProperty({
        description: 'Test title',
        example: 'JavaScript Fundamentals',
    })
    @IsString()
    testTitle: string;

    @ApiProperty({
        description: 'Average time to complete (minutes)',
        example: 45.5,
    })
    @IsNumber()
    averageCompletionTime: number;

    @ApiProperty({
        description: 'Difficulty rating (1-5)',
        example: 3.2,
    })
    @IsNumber()
    difficultyRating: number;

    @ApiProperty({
        description: 'Success rate percentage',
        example: 78.5,
    })
    @IsNumber()
    successRate: number;

    @ApiProperty({
        description: 'Common struggle areas',
        example: ['Async/Await', 'Closures', 'Prototypes'],
    })
    @IsArray()
    struggleAreas: string[];
}

/*
 * Class #273: PersonalizedInsightsDto
 * Source: training_progress/dto/progress-analytics.dto.ts:144
 * Type: Exported Class
 * Methods: 0
 * Properties: 9
 * Decorators: 14
 * Complexity: 30
 * Size: 1263 characters (52 lines)
 */
export class PersonalizedInsightsDto {
    @ApiProperty({
        description: 'User ID',
        example: 'user-123',
    })
    @IsString()
    userId: string;

    @ApiProperty({
        description: 'Learning style identified',
        example: 'visual',
        enum: ['visual', 'auditory', 'kinesthetic', 'reading'],
    })
    @IsString()
    learningStyle: string;

    @ApiProperty({
        description: 'Optimal learning pace (questions per hour)',
        example: 12.5,
    })
    @IsNumber()
    optimalPace: number;

    @ApiProperty({
        description: 'Best performance time of day',
        example: 'morning',
        enum: ['morning', 'afternoon', 'evening'],
    })
    @IsString()
    bestPerformanceTime: string;

    @ApiProperty({
        description: 'Recommended next topics',
        example: ['Advanced JavaScript', 'React Fundamentals'],
    })
    @IsArray()
    recommendedTopics: string[];

    @ApiProperty({
        description: 'Weak areas needing attention',
        example: ['Array Methods', 'DOM Manipulation'],
    })
    @IsArray()
    weakAreas: string[];

    @ApiProperty({
        description: 'Strong areas',
        example: ['Variables', 'Functions', 'Loops'],
    })
    @IsArray()
    strongAreas: string[];
}

/*
 * Class #274: ProgressAnalyticsDto
 * Source: training_progress/dto/progress-analytics.dto.ts:197
 * Type: Exported Class
 * Methods: 0
 * Properties: 27
 * Decorators: 19
 * Complexity: 42
 * Size: 1589 characters (59 lines)
 */
export class ProgressAnalyticsDto {
    @ApiProperty({
        description: 'Overall analytics summary',
    })
    @ValidateNested()
    @Type(() => Object)
    overview: {
        totalUsers: number;
        activeUsers: number;
        averageProgress: number;
        totalTimeSpent: number;
        completionRate: number;
    };

    @ApiProperty({
        description: 'Learning trends over time',
        type: [LearningTrendDto],
    })
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => LearningTrendDto)
    learningTrends: LearningTrendDto[];

    @ApiProperty({
        description: 'Progress breakdown by course',
        type: [CourseProgressBreakdownDto],
    })
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => CourseProgressBreakdownDto)
    courseBreakdown: CourseProgressBreakdownDto[];

    @ApiProperty({
        description: 'Learning path analysis',
        type: [LearningPathAnalysisDto],
    })
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => LearningPathAnalysisDto)
    learningPathAnalysis: LearningPathAnalysisDto[];

    @ApiProperty({
        description: 'Personalized insights (if user-specific)',
        type: PersonalizedInsightsDto,
        nullable: true,
    })
    @ValidateNested()
    @Type(() => PersonalizedInsightsDto)
    personalizedInsights?: PersonalizedInsightsDto;

    @ApiProperty({
        description: 'Performance predictions',
    })
    predictions: {
        estimatedCompletionDate: string;
        successProbability: number;
        recommendedStudyHours: number;
    };
}

/*
 * Class #275: ProgressEntryDto
 * Source: training_progress/dto/progress-list.dto.ts:5
 * Type: Exported Class
 * Methods: 0
 * Properties: 29
 * Decorators: 33
 * Complexity: 73
 * Size: 2487 characters (118 lines)
 */
export class ProgressEntryDto {
    @ApiProperty({
        description: 'Progress ID',
        example: 1,
    })
    @IsNumber()
    progressId: number;

    @ApiProperty({
        description: 'User ID',
        example: 'user-123',
    })
    @IsString()
    userId: string;

    @ApiProperty({
        description: 'User first name',
        example: 'John',
    })
    @IsString()
    firstName: string;

    @ApiProperty({
        description: 'User last name',
        example: 'Doe',
    })
    @IsString()
    lastName: string;

    @ApiProperty({
        description: 'Course ID',
        example: 1,
    })
    @IsNumber()
    courseId: number;

    @ApiProperty({
        description: 'Course title',
        example: 'Web Development Bootcamp',
    })
    @IsString()
    courseTitle: string;

    @ApiProperty({
        description: 'Test ID (if specific to a test)',
        example: 1,
        nullable: true,
    })
    @IsNumber()
    testId: number | null;

    @ApiProperty({
        description: 'Test title (if specific to a test)',
        example: 'JavaScript Fundamentals Quiz',
        nullable: true,
    })
    @IsString()
    testTitle: string | null;

    @ApiProperty({
        description: 'Completion percentage',
        example: 75.5,
    })
    @IsNumber()
    completionPercentage: number;

    @ApiProperty({
        description: 'Time spent in minutes',
        example: 120,
    })
    @IsNumber()
    timeSpentMinutes: number;

    @ApiProperty({
        description: 'Questions completed',
        example: 15,
    })
    @IsNumber()
    questionsCompleted: number;

    @ApiProperty({
        description: 'Total questions available',
        example: 20,
    })
    @IsNumber()
    totalQuestions: number;

    @ApiProperty({
        description: 'Progress status',
        example: 'in_progress',
        enum: ['not_started', 'in_progress', 'completed', 'paused'],
    })
    @IsString()
    status: string;

    @ApiProperty({
        description: 'Last updated date',
        example: '2024-01-15T14:30:00.000Z',
    })
    @IsDate()
    @Type(() => Date)
    lastUpdated: Date;

    @ApiProperty({
        description: 'Estimated completion time (in minutes)',
        example: 40,
    })
    @IsNumber()
    estimatedTimeToComplete: number;

    @ApiProperty({
        description: 'Learning pace (slow/normal/fast)',
        example: 'normal',
        enum: ['slow', 'normal', 'fast'],
    })
    @IsString()
    learningPace: string;
}

/*
 * Class #276: ProgressSummaryDto
 * Source: training_progress/dto/progress-list.dto.ts:124
 * Type: Exported Class
 * Methods: 0
 * Properties: 12
 * Decorators: 13
 * Complexity: 28
 * Size: 1159 characters (53 lines)
 */
export class ProgressSummaryDto {
    @ApiProperty({
        description: 'Total number of users',
        example: 150,
    })
    @IsNumber()
    totalUsers: number;

    @ApiProperty({
        description: 'Number of users who started',
        example: 135,
    })
    @IsNumber()
    usersStarted: number;

    @ApiProperty({
        description: 'Number of users who completed',
        example: 85,
    })
    @IsNumber()
    usersCompleted: number;

    @ApiProperty({
        description: 'Average completion percentage',
        example: 68.5,
    })
    @IsNumber()
    averageCompletion: number;

    @ApiProperty({
        description: 'Average time spent across all users (minutes)',
        example: 145.2,
    })
    @IsNumber()
    averageTimeSpent: number;

    @ApiProperty({
        description: 'Completion rate percentage',
        example: 62.9,
    })
    @IsNumber()
    completionRate: number;

    @ApiProperty({
        description: 'Average learning pace distribution',
        example: { slow: 25, normal: 65, fast: 10 },
    })
    paceDistribution: {
        slow: number;
        normal: number;
        fast: number;
    };
}

/*
 * Class #277: ProgressListDto
 * Source: training_progress/dto/progress-list.dto.ts:178
 * Type: Exported Class
 * Methods: 0
 * Properties: 13
 * Decorators: 16
 * Complexity: 33
 * Size: 1242 characters (57 lines)
 */
export class ProgressListDto {
    @ApiProperty({
        description: 'Array of progress entries',
        type: [ProgressEntryDto],
    })
    @ValidateNested({ each: true })
    @Type(() => ProgressEntryDto)
    progress: ProgressEntryDto[];

    @ApiProperty({
        description: 'Progress summary statistics',
        type: ProgressSummaryDto,
    })
    @ValidateNested()
    @Type(() => ProgressSummaryDto)
    summary: ProgressSummaryDto;

    @ApiProperty({
        description: 'Total number of progress entries',
        example: 150,
    })
    @IsNumber()
    total: number;

    @ApiProperty({
        description: 'Current page number',
        example: 1,
    })
    @IsNumber()
    page: number;

    @ApiProperty({
        description: 'Number of entries per page',
        example: 20,
    })
    @IsNumber()
    limit: number;

    @ApiProperty({
        description: 'Total number of pages',
        example: 8,
    })
    @IsNumber()
    totalPages: number;

    @ApiProperty({
        description: 'Whether there is a next page',
        example: true,
    })
    hasNext: boolean;

    @ApiProperty({
        description: 'Whether there is a previous page',
        example: false,
    })
    hasPrevious: boolean;
}

/*
 * Class #278: UserInfo
 * Source: training_progress/dto/training-progress-response.dto.ts:4
 * Type: Internal Class
 * Methods: 0
 * Properties: 3
 * Decorators: 6
 * Complexity: 13
 * Size: 418 characters (22 lines)
 */
class UserInfo {
    @ApiProperty({
        description: 'User ID',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @Expose()
    id: string;

    @ApiProperty({
        description: 'Username',
        example: 'johndoe',
    })
    @Expose()
    username: string;

    @ApiProperty({
        description: 'User full name',
        example: 'John Doe',
    })
    @Expose()
    fullName: string;
}

/*
 * Class #279: CourseInfo
 * Source: training_progress/dto/training-progress-response.dto.ts:27
 * Type: Internal Class
 * Methods: 0
 * Properties: 3
 * Decorators: 6
 * Complexity: 13
 * Size: 461 characters (22 lines)
 */
class CourseInfo {
    @ApiProperty({
        description: 'Course ID',
        example: 1,
    })
    @Expose()
    courseId: number;

    @ApiProperty({
        description: 'Course title',
        example: 'Advanced Mathematics',
    })
    @Expose()
    title: string;

    @ApiProperty({
        description: 'Course description',
        example: 'Advanced mathematics course covering calculus and algebra',
    })
    @Expose()
    description: string;
}

/*
 * Class #280: TestInfo
 * Source: training_progress/dto/training-progress-response.dto.ts:50
 * Type: Internal Class
 * Methods: 0
 * Properties: 3
 * Decorators: 6
 * Complexity: 13
 * Size: 430 characters (23 lines)
 */
class TestInfo {
    @ApiProperty({
        description: 'Test ID',
        example: 1,
    })
    @Expose()
    testId: number;

    @ApiProperty({
        description: 'Test title',
        example: 'Chapter 1 Quiz',
    })
    @Expose()
    title: string;

    @ApiProperty({
        description: 'Test type',
        enum: ['exam', 'quiz', 'training'],
        example: 'training',
    })
    @Expose()
    testType: string;
}

/*
 * Class #281: TrainingProgressResponseDto
 * Source: training_progress/dto/training-progress-response.dto.ts:74
 * Type: Exported Class
 * Methods: 0
 * Properties: 24
 * Decorators: 28
 * Complexity: 65
 * Size: 2319 characters (106 lines)
 */
export class TrainingProgressResponseDto {
    @ApiProperty({
        description: 'Training progress unique identifier',
        example: 1,
    })
    @Expose()
    progressId: number;

    @ApiProperty({
        description: 'User ID tracking progress',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @Expose()
    userId: string;

    @ApiProperty({
        description: 'Course ID for progress tracking',
        example: 1,
    })
    @Expose()
    courseId: number;

    @ApiProperty({
        description: 'Specific test ID (optional for overall course progress)',
        example: 1,
        required: false,
    })
    @Expose()
    testId?: number;

    @ApiProperty({
        description: 'Completion percentage (0-100)',
        example: 75.5,
        minimum: 0,
        maximum: 100,
    })
    @Expose()
    completionPercentage: number;

    @ApiProperty({
        description: 'Total time spent in minutes',
        example: 120,
        minimum: 0,
    })
    @Expose()
    timeSpentMinutes: number;

    @ApiProperty({
        description: 'Number of questions completed',
        example: 25,
        minimum: 0,
    })
    @Expose()
    questionsCompleted: number;

    @ApiProperty({
        description: 'Total number of questions in the test/course',
        example: 30,
        minimum: 0,
    })
    @Expose()
    totalQuestions: number;

    @ApiProperty({
        description: 'When progress was last updated',
        example: '2024-01-01T10:30:00.000Z',
    })
    @Expose()
    lastUpdated: Date;

    @ApiProperty({
        description: 'Progress tracking start timestamp',
        example: '2024-01-01T09:00:00.000Z',
    })
    @Expose()
    createdAt: Date;

    @ApiProperty({
        description: 'Progress last update timestamp',
        example: '2024-01-01T10:30:00.000Z',
    })
    @Expose()
    updatedAt: Date;

    @ApiProperty({
        description: 'User information',
        type: UserInfo,
    })
    @Expose()
    user: UserInfo;

    @ApiProperty({
        description: 'Course information',
        type: CourseInfo,
    })
    @Expose()
    course: CourseInfo;

    @ApiProperty({
        description: 'Test information (if specific test progress)',
        type: TestInfo,
        required: false,
    })
    @Expose()
    test?: TestInfo;
}

/*
 * Class #282: UpdateTrainingProgressDto
 * Source: training_progress/dto/update-training_progress.dto.ts:4
 * Type: Exported Class
 * Methods: 1
 * Properties: 0
 * Decorators: 0
 * Complexity: 3
 * Size: 95 characters (3 lines)
 * Extends: PartialType(
    CreateTrainingProgressDto,
)
 */
export class UpdateTrainingProgressDto extends PartialType(
    CreateTrainingProgressDto,
) {}

/*
 * Class #283: TrainingProgress
 * Source: training_progress/entities/training_progress.entity.ts:29
 * Type: Exported Class
 * Methods: 0
 * Properties: 37
 * Decorators: 40
 * Complexity: 90
 * Size: 3012 characters (124 lines)
 */
export class TrainingProgress {
    @PrimaryGeneratedColumn()
    @ApiProperty({
        description: 'Training progress unique identifier',
        example: 1,
    })
    progressId: number;

    @Column('uuid')
    @Index()
    @ApiProperty({
        description: 'User ID tracking progress',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @IsUUID()
    userId: string;

    @Column()
    @Index()
    @ApiProperty({
        description: 'Course ID for progress tracking',
        example: 1,
    })
    @IsNumber()
    courseId: number;

    @Column({ nullable: true })
    @Index()
    @ApiProperty({
        description: 'Specific test ID (optional for overall course progress)',
        example: 1,
        required: false,
    })
    @IsOptional()
    @IsNumber()
    testId?: number;

    @Column({ type: 'decimal', precision: 5, scale: 2, default: 0 })
    @ApiProperty({
        description: 'Completion percentage (0-100)',
        example: 75.5,
        minimum: 0,
        maximum: 100,
    })
    @IsNumber()
    completionPercentage: number;

    @Column({ default: 0 })
    @ApiProperty({
        description: 'Total time spent in minutes',
        example: 120,
        minimum: 0,
    })
    @IsNumber()
    timeSpentMinutes: number;

    @Column({ default: 0 })
    @ApiProperty({
        description: 'Number of questions completed',
        example: 25,
        minimum: 0,
    })
    @IsNumber()
    questionsCompleted: number;

    @Column({ default: 0 })
    @ApiProperty({
        description: 'Total number of questions in the test/course',
        example: 30,
        minimum: 0,
    })
    @IsNumber()
    totalQuestions: number;

    @Column({ type: 'timestamp', default: () => 'NOW()' })
    @ApiProperty({
        description: 'When progress was last updated',
        example: '2024-01-01T10:30:00.000Z',
    })
    lastUpdated: Date;

    @CreateDateColumn()
    @ApiProperty({
        description: 'Progress tracking start timestamp',
        example: '2024-01-01T09:00:00.000Z',
    })
    createdAt: Date;

    @UpdateDateColumn()
    @ApiProperty({
        description: 'Progress last update timestamp',
        example: '2024-01-01T10:30:00.000Z',
    })
    updatedAt: Date;

    @ManyToOne(() => Organization, { nullable: false })
    @ApiProperty({
        description: 'Organization this training progress belongs to',
        type: () => Organization,
    })
    orgId: Organization;

    @ManyToOne(() => Branch, { nullable: true })
    @ApiProperty({
        description: 'Branch this training progress belongs to',
        type: () => Branch,
        required: false,
    })
    branchId?: Branch;

    // Relations
    @ManyToOne(() => User, { onDelete: 'CASCADE' })
    user: User;

    @ManyToOne(() => Course, { onDelete: 'CASCADE' })
    course: Course;

    @ManyToOne(() => Test, { nullable: true, onDelete: 'CASCADE' })
    test: Test;

    constructor(partial: Partial<TrainingProgress>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #284: TrainingProgressController
 * Source: training_progress/training_progress.controller.ts:48
 * Type: Exported Class
 * Methods: 9
 * Properties: 369
 * Decorators: 69
 * Complexity: 203
 * Size: 27750 characters (788 lines)
 */
export class TrainingProgressController {
    private readonly logger = new Logger(TrainingProgressController.name);

    constructor(
        private readonly trainingProgressService: TrainingProgressService,
    ) {}

    @Get('user/:userId')
    @ApiOperation({
        summary: '👤 Get User Training Progress',
        description: `
        **Retrieves comprehensive training progress data for a specific user**
        
        This endpoint provides detailed learning analytics and progress tracking including:
        - Course-specific progress metrics
        - Test completion percentages
        - Time spent learning
        - Question completion statistics
        - Learning pace analysis
        
        **Features:**
        - Optional course filtering for focused analysis
        - Historical progress tracking
        - Learning pattern insights
        - Performance trend analysis
        
        **Access Control:**
        - Users can access their own progress
        - Instructors can view student progress in their courses
        - Administrators have full access
        
        **Use Cases:**
        - Student dashboard
        - Progress tracking
        - Learning analytics
        - Performance monitoring
        - Course completion reporting
        `,
        operationId: 'getUserTrainingProgress',
    })
    @ApiParam({
        name: 'userId',
        type: String,
        description:
            'Unique identifier for the user whose progress to retrieve',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @ApiQuery({
        name: 'courseId',
        type: Number,
        required: false,
        description: 'Optional course ID to filter progress by specific course',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ User training progress retrieved successfully',
        type: [TrainingProgressResponseDto],
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: {
                    type: 'string',
                    example: 'User progress retrieved successfully',
                },
                data: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            progressId: { type: 'number', example: 1 },
                            courseId: { type: 'number', example: 1 },
                            testId: { type: 'number', example: 1 },
                            completionPercentage: {
                                type: 'number',
                                example: 75.5,
                            },
                            timeSpentMinutes: { type: 'number', example: 120 },
                            questionsCompleted: { type: 'number', example: 15 },
                            totalQuestions: { type: 'number', example: 20 },
                            lastUpdated: {
                                type: 'string',
                                example: '2024-01-15T14:30:00.000Z',
                            },
                            course: {
                                type: 'object',
                                properties: {
                                    title: {
                                        type: 'string',
                                        example: 'Web Development Bootcamp',
                                    },
                                    description: {
                                        type: 'string',
                                        example:
                                            'Complete web development course',
                                    },
                                },
                            },
                        },
                    },
                },
            },
        },
    })
    @ApiUnauthorizedResponse({
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiNotFoundResponse({
        description: '❌ User not found or no progress data available',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: false },
                message: {
                    type: 'string',
                    example: 'No progress data found for user',
                },
            },
        },
    })
    @ApiForbiddenResponse({
        description:
            "🚷 Forbidden - Insufficient permissions to access this user's progress",
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 403 },
                message: { type: 'string', example: 'Forbidden' },
            },
        },
    })
    async getUserProgress(
        @Param('userId') userId: string,
        @Query('courseId', new ParseIntPipe({ optional: true }))
        courseId?: number,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        @OrgBranchScope() _scope?: OrgBranchScope,
    ): Promise<TrainingProgressResponseDto[]> {
        this.logger.log(
            `Getting progress for user: ${userId}, course: ${courseId || 'all'}`,
        );
        return this.trainingProgressService.getUserProgress(userId, courseId);
    }

    @Post('update')
    @ApiOperation({
        summary: '🔄 Update Training Progress',
        description: `
        **Updates or creates training progress records for a user**
        
        This endpoint handles real-time progress tracking including:
        - Automatic progress calculation
        - Time tracking and analytics
        - Question completion monitoring
        - Learning milestone recording
        - Performance trend updates
        
        **Smart Features:**
        - Automatic creation if no progress exists
        - Incremental updates for existing progress
        - Real-time learning analytics
        - Optimized for frequent updates
        
        **Business Logic:**
        - Progress percentages calculated automatically
        - Time spent accumulates over sessions
        - Question completion tracking
        - Course-level and test-level progress
        
        **Use Cases:**
        - Real-time progress updates during learning
        - Session completion tracking
        - Learning analytics data collection
        - Performance milestone recording
        `,
        operationId: 'updateTrainingProgress',
    })
    @ApiBody({
        description:
            'Progress update data with flexible structure for various update scenarios',
        schema: {
            type: 'object',
            properties: {
                userId: {
                    type: 'string',
                    description: 'User ID for progress tracking',
                    example: '123e4567-e89b-12d3-a456-426614174000',
                },
                courseId: {
                    type: 'number',
                    description: 'Course ID for progress context',
                    example: 1,
                },
                testId: {
                    type: 'number',
                    description: 'Optional test ID for specific test progress',
                    example: 1,
                },
                updateData: {
                    type: 'object',
                    description: 'Progress data to update',
                    properties: {
                        completionPercentage: { type: 'number', example: 85.5 },
                        timeSpentMinutes: { type: 'number', example: 30 },
                        questionsCompleted: { type: 'number', example: 17 },
                        totalQuestions: { type: 'number', example: 20 },
                    },
                },
            },
            required: ['userId', 'courseId'],
        },
        examples: {
            'course-progress': {
                summary: '📚 Course Progress Update',
                description: 'Update overall course progress',
                value: {
                    userId: '123e4567-e89b-12d3-a456-426614174000',
                    courseId: 1,
                    updateData: {
                        completionPercentage: 65.0,
                        timeSpentMinutes: 45,
                    },
                },
            },
            'test-progress': {
                summary: '📝 Test Progress Update',
                description: 'Update specific test progress',
                value: {
                    userId: '123e4567-e89b-12d3-a456-426614174000',
                    courseId: 1,
                    testId: 3,
                    updateData: {
                        completionPercentage: 100.0,
                        timeSpentMinutes: 60,
                        questionsCompleted: 20,
                        totalQuestions: 20,
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CREATED,
        description: '✅ Training progress updated successfully',
        type: TrainingProgressResponseDto,
    })
    @ApiBadRequestResponse({
        description: '❌ Invalid input data or validation errors',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: { type: 'array', items: { type: 'string' } },
                error: { type: 'string', example: 'Bad Request' },
            },
        },
    })
    async updateProgress(
        @Body()
        body: {
            userId: string;
            courseId: number;
            testId?: number;
            updateData?: Partial<CreateTrainingProgressDto>;
        },
        @OrgBranchScope() _scope: OrgBranchScope,
    ): Promise<TrainingProgressResponseDto> {
        this.logger.log(
            `Updating progress for user: ${body.userId}, course: ${body.courseId}`,
        );
        return this.trainingProgressService.updateProgress(
            body.userId,
            body.courseId,
            body.testId,
            body.updateData,
        );
    }

    @Get('course/:courseId')
    @ApiOperation({
        summary: '📚 Get Course Training Progress',
        description: `
        **Retrieves comprehensive progress analytics for all users in a course**
        
        This endpoint provides course-wide learning analytics including:
        - Student progress summaries
        - Course completion statistics
        - Learning pace analysis
        - Performance distribution
        - Engagement metrics
        
        **Instructor Features:**
        - Class-wide progress overview
        - Individual student tracking
        - Learning analytics dashboard
        - Performance identification
        - Completion monitoring
        
        **Access Control:**
        - Course instructors have full access
        - Students can only see aggregated data
        - Administrators have unrestricted access
        
        **Use Cases:**
        - Instructor dashboard
        - Course analytics
        - Student progress monitoring
        - Performance analysis
        - Curriculum effectiveness assessment
        `,
        operationId: 'getCourseTrainingProgress',
    })
    @ApiParam({
        name: 'courseId',
        type: Number,
        description: 'Course identifier for progress retrieval',
        example: 1,
    })
    @ApiQuery({
        name: 'userId',
        type: String,
        required: false,
        description: 'Optional user ID to filter progress for specific student',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Course training progress retrieved successfully',
        type: [TrainingProgressResponseDto],
    })
    @ApiNotFoundResponse({
        description: '❌ Course not found or no progress data available',
    })
    async getCourseProgress(
        @Param('courseId', ParseIntPipe) courseId: number,
        @Query('userId') userId?: string,
        @OrgBranchScope() _scope?: OrgBranchScope,
    ): Promise<TrainingProgressResponseDto[]> {
        this.logger.log(
            `Getting course progress for course: ${courseId}, user: ${userId || 'all'}`,
        );
        return this.trainingProgressService.getCourseProgress(courseId, userId);
    }

    @Get('completion/:userId/:courseId')
    @ApiOperation({
        summary: '🎯 Calculate Completion Analytics',
        description: `
        **Calculates comprehensive completion analytics for user and course**
        
        This endpoint provides detailed completion analysis including:
        - Overall course completion percentage
        - Individual test completion breakdown
        - Learning milestone achievements
        - Time investment analysis
        - Progress trajectory insights
        
        **Analytics Features:**
        - Real-time completion calculation
        - Test-by-test breakdown
        - Performance trending
        - Learning velocity metrics
        - Completion predictions
        
        **Use Cases:**
        - Student progress reports
        - Completion certificates
        - Learning analytics
        - Progress dashboards
        - Academic reporting
        `,
        operationId: 'calculateCompletionAnalytics',
    })
    @ApiParam({
        name: 'userId',
        type: String,
        description: 'User identifier for completion calculation',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @ApiParam({
        name: 'courseId',
        type: Number,
        description: 'Course identifier for completion context',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Completion analytics calculated successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: {
                    type: 'string',
                    example: 'Completion analytics calculated successfully',
                },
                data: {
                    type: 'object',
                    properties: {
                        overallCompletion: {
                            type: 'number',
                            example: 78.5,
                            description: 'Overall course completion percentage',
                        },
                        testCompletions: {
                            type: 'array',
                            description: 'Individual test completion details',
                            items: {
                                type: 'object',
                                properties: {
                                    testId: { type: 'number', example: 1 },
                                    testTitle: {
                                        type: 'string',
                                        example: 'JavaScript Fundamentals',
                                    },
                                    completionPercentage: {
                                        type: 'number',
                                        example: 100.0,
                                    },
                                    questionsCompleted: {
                                        type: 'number',
                                        example: 20,
                                    },
                                    totalQuestions: {
                                        type: 'number',
                                        example: 20,
                                    },
                                    timeSpentMinutes: {
                                        type: 'number',
                                        example: 45,
                                    },
                                },
                            },
                        },
                    },
                },
            },
        },
    })
    async calculateCompletion(
        @Param('userId') userId: string,
        @Param('courseId', ParseIntPipe) courseId: number,
        @OrgBranchScope() _scope: OrgBranchScope,
    ): Promise<{ overallCompletion: number; testCompletions: any[] }> {
        this.logger.log(
            `Calculating completion for user: ${userId}, course: ${courseId}`,
        );
        return this.trainingProgressService.calculateCompletion(
            userId,
            courseId,
        );
    }

    @Get('stats/:userId')
    @ApiOperation({
        summary: '📊 Get User Progress Statistics',
        description: `
        **Retrieves comprehensive learning statistics and analytics for a user**
        
        This endpoint provides detailed learning insights including:
        - Overall learning time investment
        - Question completion statistics
        - Course engagement metrics
        - Learning velocity analysis
        - Achievement summaries
        
        **Analytics Included:**
        - Total time spent learning
        - Questions completed across all courses
        - Average completion percentages
        - Active course participation
        - Learning consistency metrics
        
        **Use Cases:**
        - Personal learning dashboard
        - Achievement tracking
        - Learning habit analysis
        - Performance reporting
        - Gamification features
        `,
        operationId: 'getUserProgressStatistics',
    })
    @ApiParam({
        name: 'userId',
        type: String,
        description: 'User identifier for statistics retrieval',
        example: '123e4567-e89b-12d3-a456-426614174000',
    })
    @ApiQuery({
        name: 'courseId',
        type: Number,
        required: false,
        description:
            'Optional course ID to filter statistics by specific course',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Progress statistics retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: {
                    type: 'string',
                    example: 'Progress statistics retrieved successfully',
                },
                data: {
                    type: 'object',
                    properties: {
                        totalTimeSpent: {
                            type: 'number',
                            example: 1250,
                            description: 'Total learning time in minutes',
                        },
                        totalQuestionsCompleted: {
                            type: 'number',
                            example: 485,
                            description:
                                'Total questions answered across all courses',
                        },
                        averageCompletion: {
                            type: 'number',
                            example: 78.5,
                            description:
                                'Average completion percentage across courses',
                        },
                        coursesInProgress: {
                            type: 'number',
                            example: 3,
                            description:
                                'Number of courses currently being studied',
                        },
                        testsCompleted: {
                            type: 'number',
                            example: 12,
                            description:
                                'Number of tests completed with 100% progress',
                        },
                    },
                },
            },
        },
    })
    async getProgressStats(
        @Param('userId') userId: string,
        @Query('courseId', new ParseIntPipe({ optional: true }))
        courseId?: number,
        @OrgBranchScope() _scope?: OrgBranchScope,
    ): Promise<{
        totalTimeSpent: number;
        totalQuestionsCompleted: number;
        averageCompletion: number;
        coursesInProgress: number;
        testsCompleted: number;
    }> {
        this.logger.log(
            `Getting progress stats for user: ${userId}, course: ${courseId || 'all'}`,
        );
        return this.trainingProgressService.getProgressStats(userId, courseId);
    }

    @Get(':id')
    @ApiOperation({
        summary: '🔍 Get Training Progress by ID',
        description: `
        **Retrieves specific training progress record with comprehensive details**
        
        This endpoint provides detailed information about a single progress entry including:
        - Complete progress metrics
        - Associated course and test information
        - User context and relationships
        - Historical tracking data
        - Learning analytics insights
        
        **Features:**
        - Full relational data loading
        - Complete progress context
        - Associated entity information
        - Timestamp tracking
        
        **Use Cases:**
        - Progress detail views
        - Administrative monitoring
        - Data analysis
        - Audit trails
        - Progress verification
        `,
        operationId: 'getTrainingProgressById',
    })
    @ApiParam({
        name: 'id',
        type: Number,
        description: 'Training progress record identifier',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Training progress retrieved successfully',
        type: TrainingProgressResponseDto,
    })
    @ApiNotFoundResponse({
        description: '❌ Training progress record not found',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: false },
                message: {
                    type: 'string',
                    example: 'Training progress not found',
                },
            },
        },
    })
    async findOne(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() _scope: OrgBranchScope,
    ): Promise<TrainingProgressResponseDto> {
        this.logger.log(`Getting progress record: ${id}`);
        return this.trainingProgressService.findOne(id);
    }

    @Patch(':id')
    @ApiOperation({
        summary: '✏️ Update Training Progress by ID',
        description: `
        **Updates specific training progress record with validation and security**
        
        This endpoint allows direct updates to progress records including:
        - Completion percentage adjustments
        - Time tracking modifications
        - Question completion updates
        - Learning milestone corrections
        - Progress data maintenance
        
        **Administrative Features:**
        - Direct progress record modification
        - Bulk data corrections
        - Historical data updates
        - Progress recalculation
        - Data integrity maintenance
        
        **Security & Validation:**
        - Permission-based access control
        - Data integrity validation
        - Audit trail maintenance
        - Change tracking
        
        **Use Cases:**
        - Administrative corrections
        - Data migration
        - Progress adjustments
        - System maintenance
        - Bulk updates
        `,
        operationId: 'updateTrainingProgressById',
    })
    @ApiParam({
        name: 'id',
        type: Number,
        description: 'Training progress record identifier to update',
        example: 1,
    })
    @ApiBody({
        type: UpdateTrainingProgressDto,
        description:
            'Progress update data with optional fields for partial updates',
        examples: {
            'completion-update': {
                summary: '📈 Completion Update',
                description: 'Update completion percentage and time',
                value: {
                    completionPercentage: 95.0,
                    timeSpentMinutes: 180,
                },
            },
            'question-update': {
                summary: '❓ Question Progress Update',
                description: 'Update question completion metrics',
                value: {
                    questionsCompleted: 18,
                    totalQuestions: 20,
                    completionPercentage: 90.0,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Training progress updated successfully',
        type: TrainingProgressResponseDto,
    })
    @ApiBadRequestResponse({
        description: '❌ Invalid update data or validation errors',
    })
    @ApiNotFoundResponse({
        description: '❌ Training progress record not found',
    })
    async update(
        @Param('id', ParseIntPipe) id: number,
        @Body() updateTrainingProgressDto: UpdateTrainingProgressDto,
        @OrgBranchScope() _scope: OrgBranchScope,
    ): Promise<TrainingProgressResponseDto> {
        this.logger.log(`Updating progress record: ${id}`);
        return this.trainingProgressService.update(
            id,
            updateTrainingProgressDto,
        );
    }

    @Delete(':id')
    @ApiOperation({
        summary: '🗑️ Delete Training Progress Record',
        description: `
        **Permanently deletes a training progress record with proper validation**
        
        This endpoint handles secure deletion of progress records including:
        - Data integrity verification
        - Dependency checking
        - Audit trail maintenance
        - Cascade effect analysis
        - Cleanup operations
        
        **Security Features:**
        - Permission validation
        - Data relationship checking
        - Soft delete considerations
        - Audit logging
        - Recovery options
        
        **Administrative Control:**
        - Bulk deletion support
        - Data cleanup operations
        - System maintenance
        - Historical data management
        
        **Use Cases:**
        - Data cleanup
        - User account deletion
        - Course removal
        - System maintenance
        - Privacy compliance
        `,
        operationId: 'deleteTrainingProgress',
    })
    @ApiParam({
        name: 'id',
        type: Number,
        description: 'Training progress record identifier to delete',
        example: 1,
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Training progress deleted successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: {
                    type: 'string',
                    example: 'Training progress deleted successfully',
                },
            },
        },
    })
    @ApiNotFoundResponse({
        description: '❌ Training progress record not found',
    })
    @ApiForbiddenResponse({
        description:
            '🚷 Forbidden - Insufficient permissions to delete this record',
    })
    async remove(
        @Param('id', ParseIntPipe) id: number,
        @OrgBranchScope() _scope: OrgBranchScope,
    ): Promise<void> {
        this.logger.log(`Deleting progress record: ${id}`);
        return this.trainingProgressService.remove(id);
    }
}

/*
 * Class #285: TrainingProgressModule
 * Source: training_progress/training_progress.module.ts:16
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 38 characters (1 lines)
 */
export class TrainingProgressModule {}

/*
 * Class #286: TrainingProgressService
 * Source: training_progress/training_progress.service.ts:15
 * Type: Exported Class
 * Methods: 31
 * Properties: 59
 * Decorators: 1
 * Complexity: 151
 * Size: 11310 characters (323 lines)
 */
export class TrainingProgressService {
    constructor(
        @InjectRepository(TrainingProgress)
        private readonly progressRepository: Repository<TrainingProgress>,
    ) {}

    async getUserProgress(
        userId: string,
        courseId?: number,
    ): Promise<TrainingProgressResponseDto[]> {
        try {
            const queryBuilder = this.progressRepository
                .createQueryBuilder('progress')
                .leftJoinAndSelect('progress.user', 'user')
                .leftJoinAndSelect('progress.course', 'course')
                .leftJoinAndSelect('progress.test', 'test')
                .where('progress.userId = :userId', { userId });

            if (courseId) {
                queryBuilder.andWhere('progress.courseId = :courseId', {
                    courseId,
                });
            }

            const progressEntries = await queryBuilder
                .orderBy('progress.lastUpdated', 'DESC')
                .getMany();

            return progressEntries.map(entry =>
                plainToClass(TrainingProgressResponseDto, entry, {
                    excludeExtraneousValues: true,
                }),
            );
        } catch (error) {
            throw new InternalServerErrorException(
                'Failed to fetch user progress',
            );
        }
    }

    async updateProgress(
        userId: string,
        courseId: number,
        testId?: number,
        updateData?: Partial<CreateTrainingProgressDto>,
    ): Promise<TrainingProgressResponseDto> {
        try {
            // Find existing progress entry
            const whereCondition = {
                userId,
                courseId,
                testId: testId || IsNull(),
            };

            let progressEntry = await this.progressRepository.findOne({
                where: whereCondition,
                relations: ['user', 'course', 'test'],
            });

            if (progressEntry) {
                // Update existing entry
                if (updateData?.completionPercentage !== undefined) {
                    progressEntry.completionPercentage =
                        updateData.completionPercentage;
                }
                if (updateData?.timeSpentMinutes !== undefined) {
                    progressEntry.timeSpentMinutes +=
                        updateData.timeSpentMinutes;
                }
                if (updateData?.questionsCompleted !== undefined) {
                    progressEntry.questionsCompleted =
                        updateData.questionsCompleted;
                }
                if (updateData?.totalQuestions !== undefined) {
                    progressEntry.totalQuestions = updateData.totalQuestions;
                }
                progressEntry.lastUpdated = new Date();
            } else {
                // Create new progress entry
                const createDto: CreateTrainingProgressDto = {
                    userId,
                    courseId,
                    testId,
                    completionPercentage: updateData?.completionPercentage || 0,
                    timeSpentMinutes: updateData?.timeSpentMinutes || 0,
                    questionsCompleted: updateData?.questionsCompleted || 0,
                    totalQuestions: updateData?.totalQuestions || 0,
                };
                progressEntry = this.progressRepository.create(createDto);
            }

            const savedProgress =
                await this.progressRepository.save(progressEntry);

            // Fetch with relations for response
            const fullProgress = await this.progressRepository.findOne({
                where: { progressId: savedProgress.progressId },
                relations: ['user', 'course', 'test'],
            });

            return plainToClass(TrainingProgressResponseDto, fullProgress, {
                excludeExtraneousValues: true,
            });
        } catch (error) {
            throw new InternalServerErrorException('Failed to update progress');
        }
    }

    async getCourseProgress(
        courseId: number,
        userId?: string,
    ): Promise<TrainingProgressResponseDto[]> {
        try {
            const queryBuilder = this.progressRepository
                .createQueryBuilder('progress')
                .leftJoinAndSelect('progress.user', 'user')
                .leftJoinAndSelect('progress.course', 'course')
                .leftJoinAndSelect('progress.test', 'test')
                .where('progress.courseId = :courseId', { courseId });

            if (userId) {
                queryBuilder.andWhere('progress.userId = :userId', { userId });
            }

            const progressEntries = await queryBuilder
                .orderBy('progress.lastUpdated', 'DESC')
                .getMany();

            return progressEntries.map(entry =>
                plainToClass(TrainingProgressResponseDto, entry, {
                    excludeExtraneousValues: true,
                }),
            );
        } catch (error) {
            throw new InternalServerErrorException(
                'Failed to fetch course progress',
            );
        }
    }

    async calculateCompletion(
        userId: string,
        courseId: number,
    ): Promise<{ overallCompletion: number; testCompletions: any[] }> {
        try {
            const progressEntries = await this.progressRepository.find({
                where: { userId, courseId },
                relations: ['test'],
            });

            if (progressEntries.length === 0) {
                return { overallCompletion: 0, testCompletions: [] };
            }

            const testCompletions = progressEntries.map(entry => ({
                testId: entry.testId,
                testTitle: entry.test?.title || 'Unknown Test',
                completionPercentage: entry.completionPercentage,
                questionsCompleted: entry.questionsCompleted,
                totalQuestions: entry.totalQuestions,
                timeSpentMinutes: entry.timeSpentMinutes,
            }));

            const overallCompletion =
                progressEntries.reduce(
                    (sum, entry) => sum + entry.completionPercentage,
                    0,
                ) / progressEntries.length;

            return {
                overallCompletion: Math.round(overallCompletion * 100) / 100,
                testCompletions,
            };
        } catch (error) {
            throw new InternalServerErrorException(
                'Failed to calculate completion',
            );
        }
    }

    async getProgressStats(
        userId: string,
        courseId?: number,
    ): Promise<{
        totalTimeSpent: number;
        totalQuestionsCompleted: number;
        averageCompletion: number;
        coursesInProgress: number;
        testsCompleted: number;
    }> {
        try {
            const queryBuilder = this.progressRepository
                .createQueryBuilder('progress')
                .where('progress.userId = :userId', { userId });

            if (courseId) {
                queryBuilder.andWhere('progress.courseId = :courseId', {
                    courseId,
                });
            }

            const progressEntries = await queryBuilder.getMany();

            const stats = {
                totalTimeSpent: progressEntries.reduce(
                    (sum, entry) => sum + entry.timeSpentMinutes,
                    0,
                ),
                totalQuestionsCompleted: progressEntries.reduce(
                    (sum, entry) => sum + entry.questionsCompleted,
                    0,
                ),
                averageCompletion:
                    progressEntries.length > 0
                        ? progressEntries.reduce(
                              (sum, entry) => sum + entry.completionPercentage,
                              0,
                          ) / progressEntries.length
                        : 0,
                coursesInProgress: new Set(
                    progressEntries.map(entry => entry.courseId),
                ).size,
                testsCompleted: progressEntries.filter(
                    entry => entry.completionPercentage >= 100,
                ).length,
            };

            stats.averageCompletion =
                Math.round(stats.averageCompletion * 100) / 100;

            return stats;
        } catch (error) {
            throw new InternalServerErrorException(
                'Failed to get progress stats',
            );
        }
    }

    async findOne(progressId: number): Promise<TrainingProgressResponseDto> {
        try {
            const progress = await this.progressRepository.findOne({
                where: { progressId },
                relations: ['user', 'course', 'test'],
            });

            if (!progress) {
                throw new NotFoundException(
                    `Training progress with ID ${progressId} not found`,
                );
            }

            return plainToClass(TrainingProgressResponseDto, progress, {
                excludeExtraneousValues: true,
            });
        } catch (error) {
            if (error instanceof NotFoundException) {
                throw error;
            }
            throw new InternalServerErrorException(
                'Failed to fetch training progress',
            );
        }
    }

    async update(
        progressId: number,
        updateTrainingProgressDto: UpdateTrainingProgressDto,
    ): Promise<TrainingProgressResponseDto> {
        try {
            const progress = await this.progressRepository.findOne({
                where: { progressId },
                relations: ['user', 'course', 'test'],
            });

            if (!progress) {
                throw new NotFoundException(
                    `Training progress with ID ${progressId} not found`,
                );
            }

            // Update fields
            Object.assign(progress, updateTrainingProgressDto);
            progress.lastUpdated = new Date();

            const updatedProgress =
                await this.progressRepository.save(progress);

            return plainToClass(TrainingProgressResponseDto, updatedProgress, {
                excludeExtraneousValues: true,
            });
        } catch (error) {
            if (error instanceof NotFoundException) {
                throw error;
            }
            throw new InternalServerErrorException(
                'Failed to update training progress',
            );
        }
    }

    async remove(progressId: number): Promise<void> {
        try {
            const progress = await this.progressRepository.findOne({
                where: { progressId },
            });

            if (!progress) {
                throw new NotFoundException(
                    `Training progress with ID ${progressId} not found`,
                );
            }

            await this.progressRepository.remove(progress);
        } catch (error) {
            if (error instanceof NotFoundException) {
                throw error;
            }
            throw new InternalServerErrorException(
                'Failed to delete training progress',
            );
        }
    }
}

/*
 * Class #287: AssignOrgBranchDto
 * Source: user/dto/assign-org-branch.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 2
 * Decorators: 6
 * Complexity: 15
 * Size: 569 characters (19 lines)
 */
export class AssignOrgBranchDto {
    @ApiProperty({
        description: 'Organization ID to assign to the user',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
        required: false,
    })
    @IsOptional()
    @IsString({ message: 'Organization ID must be a string' })
    orgId?: string;

    @ApiProperty({
        description: 'Branch ID to assign to the user',
        example: 'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
        required: false,
    })
    @IsOptional()
    @IsString({ message: 'Branch ID must be a string' })
    branchId?: string;
}

/*
 * Class #288: ChangePasswordDto
 * Source: user/dto/change-password.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 13
 * Decorators: 8
 * Complexity: 28
 * Size: 1366 characters (37 lines)
 */
export class ChangePasswordDto {
    @ApiProperty({
        description:
            'Current password for verification before changing to new password',
        example: 'CurrentPass123!',
        type: String,
        title: 'Current Password',
        format: 'password',
        minLength: 8,
    })
    @IsString({ message: 'Current password must be a string' })
    @IsNotEmpty({ message: 'Current password is required' })
    currentPassword: string;

    @ApiProperty({
        description:
            'New secure password with uppercase, lowercase, number, and special character requirements',
        example: 'NewSecurePass123!',
        type: String,
        title: 'New Password',
        format: 'password',
        minLength: 8,
        pattern:
            '^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>\\/?])',
    })
    @IsString({ message: 'New password must be a string' })
    @IsNotEmpty({ message: 'New password is required' })
    @MinLength(8, { message: 'Password must be at least 8 characters long' })
    @Matches(
        /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=[\]{};':"\\|,.<>/?])/,
        {
            message:
                'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character',
        },
    )
    newPassword: string;
}

/*
 * Class #289: StandardApiResponse
 * Source: user/dto/common-response.dto.ts:3
 * Type: Exported Class
 * Methods: 0
 * Properties: 11
 * Decorators: 4
 * Complexity: 15
 * Size: 810 characters (34 lines)
 */
export class StandardApiResponse<T = any> {
    @ApiProperty({
        description: 'Indicates if the operation was successful',
        example: true,
    })
    success: boolean;

    @ApiProperty({
        description: 'Human-readable message about the operation result',
        example: 'Question option created successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Response data payload',
        required: false,
    })
    data?: T;

    @ApiProperty({
        description: 'Additional metadata about the response',
        required: false,
    })
    meta?: {
        timestamp?: string;
        requestId?: string;
        pagination?: {
            page: number;
            limit: number;
            total: number;
            totalPages: number;
        };
    };
}

/*
 * Class #290: StandardOperationResponse
 * Source: user/dto/common-response.dto.ts:38
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 7
 * Size: 518 characters (20 lines)
 */
export class StandardOperationResponse {
    @ApiProperty({
        description: 'Human-readable message about the operation result',
        example: 'Question option created successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status indicator',
        example: 'success',
        enum: ['success', 'error', 'warning', 'info', 'debug'],
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #291: UserCreatedResponse
 * Source: user/dto/common-response.dto.ts:60
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 441 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class UserCreatedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: 'User creation success message',
        example: 'User created successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #292: UserUpdatedResponse
 * Source: user/dto/common-response.dto.ts:80
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 439 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class UserUpdatedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: 'User update success message',
        example: 'User updated successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #293: UserDeletedResponse
 * Source: user/dto/common-response.dto.ts:100
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 441 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class UserDeletedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: 'User deletion success message',
        example: 'User deleted successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #294: ProfileUpdatedResponse
 * Source: user/dto/common-response.dto.ts:120
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 448 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class ProfileUpdatedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: 'Profile update success message',
        example: 'Profile updated successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #295: PasswordChangedResponse
 * Source: user/dto/common-response.dto.ts:140
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 451 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class PasswordChangedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: 'Password change success message',
        example: 'Password changed successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #296: PasswordUpdatedResponse
 * Source: user/dto/common-response.dto.ts:160
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 451 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class PasswordUpdatedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: 'Password update success message',
        example: 'Password updated successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #297: EmailVerifiedResponse
 * Source: user/dto/common-response.dto.ts:180
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 450 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class EmailVerifiedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: 'Email verification success message',
        example: 'Email verified successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #298: OrgBranchAssignedResponse
 * Source: user/dto/common-response.dto.ts:200
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 488 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class OrgBranchAssignedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: 'Organization and branch assignment success message',
        example: 'Organization and branch assigned successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #299: UserSoftDeletedResponse
 * Source: user/dto/common-response.dto.ts:220
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 448 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class UserSoftDeletedResponse extends StandardOperationResponse {
    @ApiProperty({
        description: 'User soft delete success message',
        example: 'User deleted successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #300: UserRestoredResponse
 * Source: user/dto/common-response.dto.ts:240
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 8
 * Size: 446 characters (19 lines)
 * Extends: StandardOperationResponse
 */
export class UserRestoredResponse extends StandardOperationResponse {
    @ApiProperty({
        description: 'User restoration success message',
        example: 'User restored successfully',
    })
    message: string;

    @ApiProperty({
        description: 'Operation status',
        example: 'success',
    })
    status: string;

    @ApiProperty({
        description: 'HTTP status code',
        example: 200,
    })
    code: number;
}

/*
 * Class #301: CreateUserDto
 * Source: user/dto/create-user.dto.ts:11
 * Type: Exported Class
 * Methods: 0
 * Properties: 15
 * Decorators: 18
 * Complexity: 57
 * Size: 3002 characters (93 lines)
 */
/**
 * Data Transfer Object for creating a new user account
 * Used for user registration with comprehensive validation
 */
export class CreateUserDto {
    @ApiProperty({
        description:
            'Unique email address for user authentication and communication',
        example: 'brandon.new@orrbit.co.za',
        format: 'email',
        type: String,
        title: 'Email Address',
        maxLength: 255,
        uniqueItems: true,
    })
    @IsEmail({}, { message: 'Please provide a valid email address' })
    email: string;

    @ApiProperty({
        description:
            'Secure password for user authentication. Must contain uppercase, lowercase, number, and special character',
        example: 'SecurePass123!',
        minLength: 8,
        type: String,
        title: 'Password',
        format: 'password',
        pattern:
            '^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+\\-=\\[\\]{};\':"\\\\|,.<>\\/?])',
    })
    @IsString()
    @MinLength(8, { message: 'Password must be at least 8 characters long' })
    @Matches(
        /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-=[\]{};':"\\|,.<>/?])/,
        {
            message:
                'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character',
        },
    )
    password: string;

    @ApiProperty({
        description:
            "User's first name for personalized communication and profile display",
        example: 'Brandon',
        type: String,
        title: 'First Name',
        maxLength: 50,
        minLength: 2,
    })
    @IsString({ message: 'First name must be a string' })
    @MinLength(2, { message: 'First name must be at least 2 characters long' })
    firstName: string;

    @ApiProperty({
        description:
            "User's last name for full identification and profile completion",
        example: 'Kawu',
        type: String,
        title: 'Last Name',
        maxLength: 50,
        minLength: 2,
    })
    @IsString({ message: 'Last name must be a string' })
    @MinLength(2, { message: 'Last name must be at least 2 characters long' })
    lastName: string;

    @ApiProperty({
        description:
            'Profile picture ID from media library for user avatar display across the application',
        example: 1,
        required: false,
        type: Number,
        title: 'Avatar Media ID',
    })
    @IsOptional()
    @IsNumber(
        { allowNaN: false, allowInfinity: false },
        { message: 'Avatar must be a valid media file ID' },
    )
    avatar?: number;

    @ApiProperty({
        description:
            'Optional invitation token from email invitation to automatically assign organization and branch',
        example: 'abc123-invitation-token-xyz789',
        required: false,
        type: String,
        title: 'Invitation Token',
    })
    @IsOptional()
    @IsString({ message: 'Invitation token must be a string' })
    invitationToken?: string;
}

/*
 * Class #302: RefreshTokenDto
 * Source: user/dto/refresh-token.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 3
 * Complexity: 9
 * Size: 671 characters (18 lines)
 */
/**
 * Data Transfer Object for JWT token refresh
 * Used to obtain new access tokens using valid refresh tokens
 */
export class RefreshTokenDto {
    @ApiProperty({
        description: 'Valid JWT refresh token for obtaining new access token',
        example:
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyX2lkIiwidHlwZSI6InJlZnJlc2giLCJpYXQiOjE3MDUzMTcwMDAsImV4cCI6MTcwNzk5NTQwMH0.signature',
        type: String,
        title: 'Refresh Token',
        minLength: 10,
        format: 'jwt',
    })
    @IsString({ message: 'Refresh token is required' })
    @MinLength(10, { message: 'Invalid refresh token format' })
    refreshToken: string;
}

/*
 * Class #303: ResendVerificationDto
 * Source: user/dto/resend-verification.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 3
 * Complexity: 10
 * Size: 589 characters (18 lines)
 */
/**
 * Data Transfer Object for resending email verification
 * Used to request a new verification email for unverified accounts
 */
export class ResendVerificationDto {
    @ApiProperty({
        description:
            'Registered email address to resend verification instructions',
        example: 'john.doe@example.com',
        format: 'email',
        type: String,
        title: 'Email Address',
        maxLength: 255,
    })
    @IsEmail({}, { message: 'Please provide a valid email address' })
    @MaxLength(255, { message: 'Email address is too long' })
    email: string;
}

/*
 * Class #304: OrgInfo
 * Source: user/dto/session-response.dto.ts:5
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 9
 * Size: 557 characters (21 lines)
 */
export class OrgInfo {
    @ApiProperty({
        description: 'Organization unique identifier',
        example: '1',
    })
    id: string;

    @ApiProperty({
        description: 'Organization name',
        example: 'Legend Systems',
    })
    name: string;

    @ApiProperty({
        description: 'Organization logo URL',
        example:
            'https://images.squarespace-cdn.com/content/v1/60d79a5c5de30045e5fbd613/1624811319877-J4XM9UIJKV7QUZSI4VKI/LegendSystemsLogo.png?format=1500w',
        required: false,
    })
    avatar?: string;
}

/*
 * Class #305: BranchInfo
 * Source: user/dto/session-response.dto.ts:27
 * Type: Exported Class
 * Methods: 0
 * Properties: 6
 * Decorators: 6
 * Complexity: 18
 * Size: 935 characters (42 lines)
 */
export class BranchInfo {
    @ApiProperty({
        description: 'Branch unique identifier',
        example: '1',
    })
    id: string;

    @ApiProperty({
        description: 'Branch name',
        example: 'Denver',
    })
    name: string;

    @ApiProperty({
        description: 'Branch email address',
        example: 'sales@legendsystems.co.za',
        required: false,
    })
    email?: string;

    @ApiProperty({
        description: 'Branch physical address',
        example: '123 Main Street, Downtown, City 12345',
        required: false,
        nullable: true,
    })
    address?: string | null;

    @ApiProperty({
        description: 'Branch contact phone number',
        example: '+27 100132465',
        required: false,
    })
    contactNumber?: string;

    @ApiProperty({
        description: 'Branch manager name',
        example: 'Kats',
        required: false,
    })
    managerName?: string;
}

/*
 * Class #306: UserResponseDto
 * Source: user/dto/session-response.dto.ts:70
 * Type: Exported Class
 * Methods: 0
 * Properties: 23
 * Decorators: 8
 * Complexity: 26
 * Size: 2033 characters (69 lines)
 */
export class UserResponseDto {
    @ApiProperty({
        description: 'User unique identifier',
        example: '1',
    })
    uid: string;

    @ApiProperty({
        description: 'User email address',
        example: 'theguy@orrbit.co.za',
    })
    email: string;

    @ApiProperty({
        description: 'User first name',
        example: 'Brandon',
    })
    firstName: string;

    @ApiProperty({
        description: 'User last name',
        example: 'Nhlanhla',
    })
    lastName: string;

    @ApiProperty({
        description:
            'User avatar image with variants (thumbnail, medium, original)',
        example: {
            id: 1,
            originalName: 'pexels-photo-577585.jpg',
            url: 'https://storage.googleapis.com/crmapplications/media/1/1/2025-05-31/9d8818a4-bb5f-4d82-acf8-120c1485c572-pexels-photo-577585.jpg',
            thumbnail:
                'https://storage.googleapis.com/crmapplications/media/1/1/2025-05-31/9d8818a4-bb5f-4d82-acf8-120c1485c572-pexels-photo-577585-thumbnail.jpg',
            medium: 'https://storage.googleapis.com/crmapplications/media/1/1/2025-05-31/9d8818a4-bb5f-4d82-acf8-120c1485c572-pexels-photo-577585.jpg',
            original:
                'https://storage.googleapis.com/crmapplications/media/1/1/2025-05-31/9d8818a4-bb5f-4d82-acf8-120c1485c572-pexels-photo-577585.jpg',
        },
        required: false,
    })
    avatar?: {
        id: number;
        originalName?: string;
        url?: string;
        thumbnail?: string;
        medium?: string;
        original?: string;
    };

    @ApiProperty({
        description: 'User role in the system',
        example: 'brandon',
        enum: UserRole,
        required: false,
    })
    role?: UserRole;

    @ApiProperty({
        description: 'Account creation date',
        example: '2025-05-30T16:40:02.055Z',
    })
    createdAt: Date;

    @ApiProperty({
        description: 'Last update date',
        example: '2025-05-31T18:55:12.552Z',
    })
    updatedAt: Date;
}

/*
 * Class #307: SignUpResponseDto
 * Source: user/dto/session-response.dto.ts:141
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 11
 * Size: 567 characters (23 lines)
 */
export class SignUpResponseDto {
    @ApiProperty({
        description: 'Registered user information',
        type: UserResponseDto,
    })
    user: UserResponseDto;

    @ApiProperty({
        description:
            'Organization information if user was invited to organization',
        type: OrgInfo,
        required: false,
    })
    organization?: OrgInfo;

    @ApiProperty({
        description:
            'Branch information if user was invited to specific branch',
        type: BranchInfo,
        required: false,
    })
    branch?: BranchInfo;
}

/*
 * Class #308: SessionResponseDto
 * Source: user/dto/session-response.dto.ts:166
 * Type: Exported Class
 * Methods: 0
 * Properties: 7
 * Decorators: 7
 * Complexity: 22
 * Size: 1740 characters (57 lines)
 */
export class SessionResponseDto {
    @ApiProperty({
        description: 'JWT access token for API authentication',
        example:
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwiZW1haWwiOiJ0aGVndXlAb3JyYml0LmNvLnphIiwiZmlyc3ROYW1lIjoiQnJhbmRvbiIsImxhc3ROYW1lIjoiTmhsYW5obGEiLCJvcmdJZCI6IjEiLCJicmFuY2hJZCI6IjEiLCJpYXQiOjE3NDg3MTc3MjgsImV4cCI6MTc0ODcyMTMyOH0.g58W5uSLHCNf59GS6qSCuYJAvZJvsPR68qFFX4bSrho',
    })
    accessToken: string;

    @ApiProperty({
        description: 'JWT refresh token for token renewal',
        example:
            'c1c2fd688db5151443a65c6033d58f38bdee084c116f8c8213ed54692a0a522e',
    })
    refreshToken: string;

    @ApiProperty({
        description: 'Token expiration time in seconds',
        example: 3600,
    })
    expiresIn: number;

    @ApiProperty({
        description: 'Authenticated user information',
        type: UserResponseDto,
    })
    user: UserResponseDto;

    @ApiProperty({
        description: 'User leaderboard statistics and performance metrics',
        type: UserStatsResponseDto,
        required: false,
        example: {
            totalPoints: 0,
            totalTestsCompleted: 0,
            averageScore: 0,
            coursesEnrolled: 0,
            bestRank: null,
            recentActivity: [],
        },
    })
    leaderboard?: UserStatsResponseDto;

    @ApiProperty({
        description:
            'Organization information if user belongs to an organization',
        type: OrgInfo,
        required: false,
    })
    organization?: OrgInfo;

    @ApiProperty({
        description: 'Branch information if user belongs to a specific branch',
        type: BranchInfo,
        required: false,
    })
    branch?: BranchInfo;
}

/*
 * Class #309: StandardApiResponse
 * Source: user/dto/session-response.dto.ts:224
 * Type: Exported Class
 * Methods: 0
 * Properties: 3
 * Decorators: 3
 * Complexity: 9
 * Size: 469 characters (19 lines)
 */
export class StandardApiResponse<T = any> {
    @ApiProperty({
        description: 'Indicates if the operation was successful',
        example: true,
    })
    success: boolean;

    @ApiProperty({
        description: 'Response data payload',
        required: false,
    })
    data?: T;

    @ApiProperty({
        description: 'Human-readable message about the operation result',
        example: 'Operation completed successfully',
    })
    message: string;
}

/*
 * Class #310: AuthSuccessResponse
 * Source: user/dto/session-response.dto.ts:244
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 1
 * Complexity: 4
 * Size: 313 characters (8 lines)
 * Extends: StandardApiResponse<SessionResponseDto>
 */
export class AuthSuccessResponse extends StandardApiResponse<SessionResponseDto> {
    @ApiProperty({
        description:
            'Authentication session data with tokens, user info, leaderboard stats, and organization/branch details',
        type: SessionResponseDto,
    })
    data: SessionResponseDto;
}

/*
 * Class #311: SignUpSuccessResponse
 * Source: user/dto/session-response.dto.ts:253
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 1
 * Complexity: 5
 * Size: 276 characters (8 lines)
 * Extends: StandardApiResponse<SignUpResponseDto>
 */
export class SignUpSuccessResponse extends StandardApiResponse<SignUpResponseDto> {
    @ApiProperty({
        description:
            'User registration data with organization/branch info if applicable',
        type: SignUpResponseDto,
    })
    data: SignUpResponseDto;
}

/*
 * Class #312: SignInDto
 * Source: user/dto/sign-in.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 8
 * Decorators: 5
 * Complexity: 15
 * Size: 750 characters (24 lines)
 */
export class SignInDto {
    @ApiProperty({
        description: 'Registered email address for user authentication',
        example: 'john.doe@example.com',
        format: 'email',
        type: String,
        title: 'Email Address',
        maxLength: 255,
    })
    @IsEmail({}, { message: 'Please provide a valid email address' })
    email: string;

    @ApiProperty({
        description: 'User password for authentication (minimum 8 characters)',
        example: 'SecurePass123!',
        type: String,
        title: 'Password',
        format: 'password',
        minLength: 8,
    })
    @IsString({ message: 'Password is required' })
    @MinLength(8, { message: 'Password must be at least 8 characters long' })
    password: string;
}

/*
 * Class #313: UpdateUserDto
 * Source: user/dto/update-user.dto.ts:12
 * Type: Exported Class
 * Methods: 1
 * Properties: 4
 * Decorators: 14
 * Complexity: 38
 * Size: 1671 characters (57 lines)
 * Extends: PartialType(CreateUserDto)
 */
export class UpdateUserDto extends PartialType(CreateUserDto) {
    @ApiProperty({
        description: 'Updated email address for the user account',
        example: 'brandon.updated@orrbit.co.za',
        format: 'email',
        required: false,
        type: String,
        title: 'Email Address',
        maxLength: 255,
    })
    @IsOptional()
    @IsEmail({}, { message: 'Please provide a valid email address' })
    email?: string;

    @ApiProperty({
        description: 'Updated first name of the user',
        example: 'Brandon',
        required: false,
        type: String,
        title: 'First Name',
        maxLength: 50,
        minLength: 2,
    })
    @IsOptional()
    @IsString({ message: 'First name must be a string' })
    @MinLength(2, { message: 'First name must be at least 2 characters long' })
    firstName?: string;

    @ApiProperty({
        description: 'Updated last name of the user',
        example: 'Nhlanhla',
        required: false,
        type: String,
        title: 'Last Name',
        maxLength: 50,
        minLength: 2,
    })
    @IsOptional()
    @IsString({ message: 'Last name must be a string' })
    @MinLength(2, { message: 'Last name must be at least 2 characters long' })
    lastName?: string;

    @ApiProperty({
        description:
            'Updated avatar image ID reference from media library for the user profile',
        example: 2,
        required: false,
        type: Number,
        title: 'Avatar Media ID',
    })
    @IsOptional()
    @IsNumber(
        { allowNaN: false, allowInfinity: false },
        { message: 'Avatar must be a valid media file ID' },
    )
    avatar?: number;
}

/*
 * Class #314: VerifyEmailDto
 * Source: user/dto/verify-email.dto.ts:4
 * Type: Exported Class
 * Methods: 0
 * Properties: 1
 * Decorators: 3
 * Complexity: 8
 * Size: 692 characters (18 lines)
 */
/**
 * Data Transfer Object for email verification
 * Used to verify user email address with secure token validation
 */
export class VerifyEmailDto {
    @ApiProperty({
        description: 'Email verification token received via email',
        example:
            'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InVzZXJAZXhhbXBsZS5jb20iLCJ0eXBlIjoidmVyaWZpY2F0aW9uIiwiaWF0IjoxNzA1MzE3MDAwLCJleHAiOjE3MDU0MDM0MDB9.signature',
        type: String,
        title: 'Verification Token',
        minLength: 10,
        format: 'jwt',
    })
    @IsString({ message: 'Verification token is required' })
    @MinLength(10, { message: 'Invalid verification token format' })
    token: string;
}

/*
 * Class #315: User
 * Source: user/entities/user.entity.ts:42
 * Type: Exported Class
 * Methods: 1
 * Properties: 34
 * Decorators: 41
 * Complexity: 91
 * Size: 3087 characters (130 lines)
 */
export class User {
    @PrimaryGeneratedColumn('uuid')
    @ApiProperty({
        description: 'User unique identifier',
        example: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
    })
    id: string;

    @Column({ unique: true })
    @ApiProperty({
        description: 'User email address',
        example: 'john.doe@example.com',
    })
    @IsEmail()
    email: string;

    @Column()
    @ApiProperty({
        description: 'User password (excluded from responses)',
        example: 'securePassword123',
    })
    @IsString()
    @MinLength(6)
    @Exclude({ toPlainOnly: true })
    password: string;

    @Column()
    @ApiProperty({
        description: 'User first name',
        example: 'John',
    })
    @IsString()
    firstName: string;

    @Column()
    @ApiProperty({
        description: 'User last name',
        example: 'Doe',
    })
    @IsString()
    lastName: string;

    @ManyToOne(() => MediaFile, { nullable: true })
    @ApiProperty({
        description: 'User avatar image from media library',
        type: () => MediaFile,
        required: false,
    })
    avatar?: MediaFile;

    @Column({ nullable: true, default: UserRole.USER })
    @ApiProperty({
        description: 'User role',
        example: 'admin',
        required: false,
    })
    @IsEnum(UserRole)
    role?: UserRole;

    @Column({ default: false })
    @ApiProperty({
        description: 'Whether user email is verified',
        example: true,
        default: false,
    })
    emailVerified: boolean;

    @Column({ nullable: true, default: UserStatus.ACTIVE })
    @ApiProperty({
        description: 'User account status',
        example: 'active',
        default: 'active',
        enum: UserStatus,
    })
    @IsEnum(UserStatus)
    status: UserStatus;

    @IsString()
    @CreateDateColumn()
    @ApiProperty({
        description: 'Account creation date',
        example: '2024-01-01T00:00:00.000Z',
    })
    createdAt: Date;

    @UpdateDateColumn()
    @ApiProperty({
        description: 'Last update date',
        example: '2024-01-01T00:00:00.000Z',
    })
    updatedAt: Date;

    @ManyToOne(() => Organization, { nullable: true })
    @ApiProperty({
        description: 'Organization this user belongs to',
        type: () => Organization,
        required: false,
    })
    orgId?: Organization;

    @ManyToOne(() => Branch, { nullable: true })
    @ApiProperty({
        description: 'Branch this user belongs to',
        type: () => Branch,
        required: false,
    })
    branchId?: Branch;

    @OneToMany(() => Course, 'creator')
    createdCourses: Course[];

    @OneToMany(() => TestAttempt, 'user')
    testAttempts: TestAttempt[];

    @OneToMany(() => Result, 'user')
    results: Result[];

    @OneToMany(() => Answer, 'markedByUser')
    markedAnswers: Answer[];

    @OneToMany(() => Leaderboard, 'user')
    leaderboardEntries: Leaderboard[];

    @OneToMany(() => TrainingProgress, 'user')
    trainingProgress: TrainingProgress[];

    constructor(partial: Partial<User>) {
        Object.assign(this, partial);
    }
}

/*
 * Class #316: UserController
 * Source: user/user.controller.ts:52
 * Type: Exported Class
 * Methods: 23
 * Properties: 403
 * Decorators: 59
 * Complexity: 257
 * Size: 32287 characters (950 lines)
 */
export class UserController {
    private readonly logger = new Logger(UserController.name);

    constructor(private readonly userService: UserService) {}

    @Get('profile')
    @ApiOperation({
        summary: '📋 Retrieve User Profile',
        description: `
      **Retrieves the complete profile information for the authenticated user**
      
      This endpoint returns comprehensive user profile data including:
      - Personal information (name, email, avatar)
      - Account metadata (creation date, last update)
      - Secure data handling (password excluded from response)
      
      **Security Features:**
      - Requires valid JWT authentication
      - Automatically excludes sensitive information
      - User can only access their own profile
      
      **Use Cases:**
      - Profile page display
      - User account settings
      - Profile completion checks
      - Avatar and name display across application
    `,
        operationId: 'getUserProfile',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ User profile retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success status',
                },
                message: {
                    type: 'string',
                    example: 'Profile retrieved successfully',
                    description: 'Human-readable success message',
                },
                data: {
                    type: 'object',
                    description: 'User profile data (password excluded)',
                    properties: {
                        id: {
                            type: 'string',
                            example: '1',
                            description: 'Unique user identifier',
                        },
                        email: {
                            type: 'string',
                            example: 'theguy@orrbit.co.za',
                            description: 'User email address',
                        },
                        name: {
                            type: 'string',
                            example: 'Brandon Nhlanhla',
                            description: 'Full display name',
                        },
                        firstName: {
                            type: 'string',
                            example: 'Brandon',
                            description: 'First name (optional)',
                        },
                        lastName: {
                            type: 'string',
                            example: 'Nhlanhla',
                            description: 'Last name (optional)',
                        },
                        avatar: {
                            type: 'object',
                            example: {
                                id: 1,
                                originalName: 'pexels-photo-577585.jpg',
                                url: 'https://storage.googleapis.com/crmapplications/media/1/1/2025-05-31/9d8818a4-bb5f-4d82-acf8-120c1485c572-pexels-photo-577585.jpg',
                                thumbnail:
                                    'https://storage.googleapis.com/crmapplications/media/1/1/2025-05-31/9d8818a4-bb5f-4d82-acf8-120c1485c572-pexels-photo-577585-thumbnail.jpg',
                                medium: 'https://storage.googleapis.com/crmapplications/media/1/1/2025-05-31/9d8818a4-bb5f-4d82-acf8-120c1485c572-pexels-photo-577585.jpg',
                                original:
                                    'https://storage.googleapis.com/crmapplications/media/1/1/2025-05-31/9d8818a4-bb5f-4d82-acf8-120c1485c572-pexels-photo-577585.jpg',
                            },
                            description:
                                'Profile picture with variants (optional)',
                        },
                        createdAt: {
                            type: 'string',
                            example: '2025-05-30T16:40:02.055Z',
                            description: 'Account creation timestamp',
                        },
                        updatedAt: {
                            type: 'string',
                            example: '2025-05-31T18:55:12.552Z',
                            description: 'Last profile update timestamp',
                        },
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ User profile not found',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: false },
                message: { type: 'string', example: 'User not found' },
                data: { type: 'null' },
            },
        },
    })
    async getProfile(
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardApiResponse> {
        try {
            this.logger.log(`Getting profile for user: ${req.user.id}`);

            const user = await this.userService.findById(req.user.id);

            if (!user) {
                this.logger.error(`User not found: ${req.user.id}`);
                return {
                    success: false,
                    message: 'User not found',
                    data: null,
                };
            }

            // Remove sensitive data
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const { password, ...userProfile } = user;

            this.logger.log(
                `Profile retrieved successfully for user: ${req.user.id}`,
            );

            return {
                success: true,
                message: 'Profile retrieved successfully',
                data: userProfile,
            };
        } catch (error) {
            this.logger.error(
                `Error getting profile for user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Put('profile')
    @ApiOperation({
        summary: '✏️ Update User Profile',
        description: `
      **Updates user profile information with comprehensive validation**
      
      This endpoint allows authenticated users to update their profile data including:
      - Personal information (name, firstName, lastName)
      - Contact information (email with uniqueness validation)
      - Profile picture (avatar URL)
      
      **Security & Validation Features:**
      - Email uniqueness checking across all users
      - Input validation for all fields
      - Password updates blocked (use dedicated endpoint)
      - User can only update their own profile
      
      **Business Rules:**
      - Email must be unique across the system
      - Names must be at least 2 characters if provided
      - Avatar must be a valid URL if provided
      - Password changes require separate endpoint for security
      
      **Use Cases:**
      - Profile settings page
      - Account information updates
      - Avatar changes
      - Contact information updates
    `,
        operationId: 'updateUserProfile',
    })
    @ApiBody({
        type: UpdateUserDto,
        description: 'Profile update data with optional fields',
        examples: {
            'full-update': {
                summary: '🔄 Complete Profile Update',
                description: 'Updates all available profile fields',
                value: {
                    email: 'brandon.updated@orrbit.co.za',
                    firstName: 'Brandon',
                    lastName: 'Nhlanhla',
                    avatar: 2,
                },
            },
            'name-only': {
                summary: '📝 Name Update Only',
                description: 'Updates only name-related fields',
                value: {
                    firstName: 'Brandon',
                    lastName: 'Kawu-Nhlanhla',
                },
            },
            'email-change': {
                summary: '📧 Email Address Change',
                description: 'Updates email with validation',
                value: {
                    email: 'brandon.new-email@legendsystems.co.za',
                },
            },
            'avatar-update': {
                summary: '🖼️ Avatar Picture Update',
                description: 'Updates profile picture ID',
                value: {
                    avatar: 3,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Profile updated successfully',
        type: ProfileUpdatedResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data or password update attempt',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    examples: [
                        'Use /user/change-password endpoint to update password',
                        'Name must be at least 2 characters long',
                        'Please provide a valid email address',
                    ],
                },
                status: {
                    type: 'string',
                    example: 'error',
                },
                code: {
                    type: 'number',
                    example: 400,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.CONFLICT,
        description: '⚠️ Email address already exists',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'Email address already in use',
                },
                status: {
                    type: 'string',
                    example: 'error',
                },
                code: {
                    type: 'number',
                    example: 409,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async updateProfile(
        @Request() req: AuthenticatedRequest,
        @Body() updateUserDto: UpdateUserDto,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(`Updating profile for user: ${req.user.id}`);

            // Check if email is being updated and if it already exists
            if (updateUserDto.email) {
                const existingUser = await this.userService.findByEmail(
                    updateUserDto.email,
                );
                if (existingUser && existingUser.id !== req.user.id) {
                    this.logger.warn(
                        `Email already exists: ${updateUserDto.email}`,
                    );
                    throw new ConflictException('Email address already in use');
                }
            }

            // Remove password from update data (use separate endpoint)
            const { password, ...updateData } = updateUserDto;

            if (password) {
                this.logger.warn(
                    `Password update attempted through profile update for user: ${req.user.id}`,
                );
                throw new BadRequestException(
                    'Use /user/change-password endpoint to update password',
                );
            }

            const result = await this.userService.updateProfile(
                req.user.id,
                updateData,
            );

            this.logger.log(
                `Profile updated successfully for user: ${req.user.id}`,
            );

            return result;
        } catch (error) {
            this.logger.error(
                `Error updating profile for user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Put('change-password')
    @ApiOperation({
        summary: '🔐 Change User Password',
        description: `
      **Securely changes user password with current password verification**
      
      This dedicated endpoint handles password changes with comprehensive security:
      - Current password verification required
      - Strong password requirements enforced
      - Secure password hashing with bcrypt
      - Automatic session invalidation considerations
      
      **Security Features:**
      - Current password must be provided and verified
      - New password must meet complexity requirements
      - Password history validation (prevents reuse)
      - Secure password storage with salt rounds
      
      **Password Requirements:**
      - Minimum 8 characters length
      - At least one uppercase letter (A-Z)
      - At least one lowercase letter (a-z)
      - At least one digit (0-9)
      - At least one special character (!@#$%^&*()_+-=[]{}|;':"\\,.<>?)
      
      **Use Cases:**
      - Account security updates
      - Password strength improvements
      - Compromised account recovery
      - Regular security maintenance
    `,
        operationId: 'changeUserPassword',
    })
    @ApiBody({
        type: ChangePasswordDto,
        description: 'Password change request with current and new password',
        examples: {
            'password-change': {
                summary: '🔄 Standard Password Change',
                description:
                    'Change password with current password verification',
                value: {
                    currentPassword: 'CurrentPass123!',
                    newPassword: 'NewSecurePass456@',
                },
            },
            'security-upgrade': {
                summary: '🛡️ Security Upgrade',
                description:
                    'Upgrade to stronger password for enhanced security',
                value: {
                    currentPassword: 'OldWeakPass123',
                    newPassword: 'SuperSecure2024!@#$',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Password changed successfully',
        type: PasswordChangedResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid current password or validation errors',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    examples: [
                        'Current password is incorrect',
                        'Password must be at least 8 characters long',
                        'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character',
                    ],
                },
                status: {
                    type: 'string',
                    example: 'error',
                },
                code: {
                    type: 'number',
                    example: 400,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async changePassword(
        @Request() req: AuthenticatedRequest,
        @Body() changePasswordDto: ChangePasswordDto,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(`Changing password for user: ${req.user.id}`);

            const result = await this.userService.changePassword(
                req.user.id,
                changePasswordDto.currentPassword,
                changePasswordDto.newPassword,
            );

            if (result.status === 'error') {
                this.logger.warn(
                    `Password change failed for user: ${req.user.id} - ${result.message}`,
                );
                if (result.code === 400) {
                    throw new BadRequestException(result.message);
                }
            }

            this.logger.log(
                `Password changed successfully for user: ${req.user.id}`,
            );

            return result;
        } catch (error) {
            this.logger.error(
                `Error changing password for user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Patch('assign-organization')
    @ApiOperation({
        summary: '🏢 Assign Organization and Branch to User',
        description: `
      **Assigns an organization and branch to a user**
      
      This endpoint allows administrators to assign an organization and branch to a user.
      
      **Security Features:**
      - Requires valid JWT authentication
      - Only administrators can assign organizations
      
      **Use Cases:**
      - User assignment to a new organization
      - User assignment to a new branch
    `,
        operationId: 'assignOrganizationToUser',
    })
    @ApiBody({
        type: AssignOrgBranchDto,
        description: 'Organization and branch assignment data',
        examples: {
            'assign-organization': {
                summary: '🏢 Assign Organization and Branch',
                description: 'Assign an organization and branch to a user',
                value: {
                    orgId: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
                    branchId: 'b1c2d3e4-f5g6-7890-bcde-fg1234567890',
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Organization and branch assigned successfully',
        type: OrgBranchAssignedResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ Invalid input data',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'Failed to assign organization',
                },
                status: {
                    type: 'string',
                    example: 'error',
                },
                code: {
                    type: 'number',
                    example: 400,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async assignOrganization(
        @Request() req: AuthenticatedRequest,
        @Body() assignOrgBranchDto: AssignOrgBranchDto,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(`Assigning organization to user: ${req.user.id}`);

            const result = await this.userService.assignOrgAndBranch(
                req.user.id,
                assignOrgBranchDto.orgId,
                assignOrgBranchDto.branchId,
                req.user.id, // assignedBy
            );

            this.logger.log(
                `Organization assigned successfully to user: ${req.user.id}`,
            );

            return result;
        } catch (error) {
            this.logger.error(
                `Error assigning organization to user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Delete('soft-delete')
    @ApiOperation({
        summary: '🗑️ Soft Delete User Account',
        description: `
      **Soft deletes the authenticated user's account by setting status to DELETED**
      
      This endpoint performs a soft delete of the user account:
      - Sets user status to DELETED instead of removing the record
      - Preserves user data for potential restoration
      - User will no longer appear in normal queries
      - Account can be restored later using the restore endpoint
      
      **Security Features:**
      - Requires valid JWT authentication
      - User can only soft delete their own account
      - Checks if user is already deleted before proceeding
      
      **Use Cases:**
      - Account deactivation
      - Temporary account suspension
      - GDPR compliance (soft deletion)
      - User-initiated account closure
    `,
        operationId: 'softDeleteUser',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ User account soft deleted successfully',
        type: UserSoftDeletedResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ User is already deleted',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'User is already deleted',
                },
                status: {
                    type: 'string',
                    example: 'error',
                },
                code: {
                    type: 'number',
                    example: 400,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async softDeleteUser(
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(`Soft deleting user: ${req.user.id}`);

            const result = await this.userService.softDelete(
                req.user.id,
                req.user.id,
            );

            this.logger.log(`User soft deleted successfully: ${req.user.id}`);

            return result;
        } catch (error) {
            this.logger.error(
                `Error soft deleting user ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Patch('restore')
    @ApiOperation({
        summary: '♻️ Restore Soft Deleted User Account',
        description: `
      **Restores a soft-deleted user account by setting status to ACTIVE**
      
      This endpoint restores a previously soft-deleted user account:
      - Sets user status back to ACTIVE
      - Makes the account accessible again
      - User will appear in normal queries again
      - Validates that user is currently in DELETED status
      
      **Security Features:**
      - Requires valid JWT authentication
      - User can only restore their own account
      - Checks if user is actually deleted before proceeding
      
      **Use Cases:**
      - Account reactivation
      - Undoing accidental deletion
      - User returning after temporary deactivation
      - Admin-assisted account recovery
    `,
        operationId: 'restoreUser',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ User account restored successfully',
        type: UserRestoredResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ User is not deleted and cannot be restored',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'User is not deleted and cannot be restored',
                },
                status: {
                    type: 'string',
                    example: 'error',
                },
                code: {
                    type: 'number',
                    example: 400,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async restoreUser(
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(`Restoring user: ${req.user.id}`);

            const result = await this.userService.restoreUser(
                req.user.id,
                req.user.id,
            );

            this.logger.log(`User restored successfully: ${req.user.id}`);

            return result;
        } catch (error) {
            this.logger.error(`Error restoring user ${req.user.id}:`, error);
            throw error;
        }
    }

    @Get('admin/deleted')
    @ApiOperation({
        summary: '📋 Get Deleted Users (Admin)',
        description: `
      **Retrieves all soft-deleted users (for administrative purposes)**
      
      This endpoint returns all users with DELETED status:
      - Shows users who have been soft-deleted
      - Includes full user profile data
      - Intended for administrative use
      - Helps with account recovery operations
      
      **Security Features:**
      - Requires valid JWT authentication
      - Should be restricted to admin users in production
      
      **Use Cases:**
      - Administrative user management
      - Account recovery operations
      - Audit trails and reporting
      - Bulk restoration operations
    `,
        operationId: 'adminGetDeletedUsers',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ Deleted users retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: {
                    type: 'boolean',
                    example: true,
                    description: 'Operation success status',
                },
                message: {
                    type: 'string',
                    example: 'Deleted users retrieved successfully',
                    description: 'Success confirmation message',
                },
                data: {
                    type: 'array',
                    description: 'List of soft-deleted users',
                    items: {
                        type: 'object',
                        description: 'Deleted user profile data',
                    },
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async adminGetDeletedUsers(
        @Request() req: AuthenticatedRequest,
    ): Promise<StandardApiResponse> {
        try {
            this.logger.log(`Getting deleted users for admin: ${req.user.id}`);

            const deletedUsers = await this.userService.findDeleted();

            // Remove sensitive data from all users
            const sanitizedUsers = deletedUsers.map(user => {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { password, ...userProfile } = user;
                return userProfile;
            });

            this.logger.log(
                `Retrieved ${deletedUsers.length} deleted users for admin: ${req.user.id}`,
            );

            return {
                success: true,
                message: 'Deleted users retrieved successfully',
                data: sanitizedUsers,
            };
        } catch (error) {
            this.logger.error(
                `Error getting deleted users for admin ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }

    @Patch('admin/restore/:userId')
    @ApiOperation({
        summary: '♻️ Restore User by ID (Admin)',
        description: `
      **Restores a soft-deleted user account by user ID (for administrative use)**
      
      This endpoint allows administrators to restore any soft-deleted user:
      - Sets specified user status back to ACTIVE
      - Makes the account accessible again
      - Validates that target user exists and is deleted
      - Returns success confirmation only
      
      **Security Features:**
      - Requires valid JWT authentication
      - Should be restricted to admin users in production
      - Validates target user exists and is deleted
      
      **Use Cases:**
      - Administrative account recovery
      - Bulk user restoration
      - Customer support operations
      - Data recovery procedures
    `,
        operationId: 'adminRestoreUser',
    })
    @ApiResponse({
        status: HttpStatus.OK,
        description: '✅ User account restored successfully by admin',
        type: UserRestoredResponse,
    })
    @ApiResponse({
        status: HttpStatus.BAD_REQUEST,
        description: '❌ User is not deleted and cannot be restored',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'User is not deleted and cannot be restored',
                },
                status: {
                    type: 'string',
                    example: 'error',
                },
                code: {
                    type: 'number',
                    example: 400,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.NOT_FOUND,
        description: '❌ User not found',
        schema: {
            type: 'object',
            properties: {
                message: {
                    type: 'string',
                    example: 'User with ID xxx not found',
                },
                status: {
                    type: 'string',
                    example: 'error',
                },
                code: {
                    type: 'number',
                    example: 404,
                },
            },
        },
    })
    @ApiResponse({
        status: HttpStatus.UNAUTHORIZED,
        description: '🚫 Unauthorized - Invalid or missing JWT token',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 401 },
                message: { type: 'string', example: 'Unauthorized' },
            },
        },
    })
    async adminRestoreUser(
        @Request() req: AuthenticatedRequest,
        @Param('userId') userId: string,
    ): Promise<StandardOperationResponse> {
        try {
            this.logger.log(`Admin ${req.user.id} restoring user: ${userId}`);

            const result = await this.userService.restoreUser(
                userId,
                req.user.id,
            );

            this.logger.log(
                `User ${userId} restored successfully by admin: ${req.user.id}`,
            );

            return result;
        } catch (error) {
            this.logger.error(
                `Error restoring user ${userId} by admin ${req.user.id}:`,
                error,
            );
            throw error;
        }
    }
}

/*
 * Class #317: UserModule
 * Source: user/user.module.ts:21
 * Type: Exported Class
 * Methods: 0
 * Properties: 0
 * Decorators: 0
 * Complexity: 1
 * Size: 26 characters (1 lines)
 */
export class UserModule {}

/*
 * Class #318: UserService
 * Source: user/user.service.ts:28
 * Type: Exported Class
 * Methods: 59
 * Properties: 129
 * Decorators: 3
 * Complexity: 310
 * Size: 24011 characters (749 lines)
 */
export class UserService {
    // Cache keys
    private readonly CACHE_KEYS = {
        USER_BY_ID: (id: string) => `user:id:${id}`,
        USER_BY_EMAIL: (email: string) => `user:email:${email}`,
        USER_ORG: (orgId: string) => `user:org:${orgId}`,
        USER_BRANCH: (branchId: string) => `user:branch:${branchId}`,
        USER_AVATAR_VARIANTS: (avatarId: number) => `user:avatar:${avatarId}`,
    };

    // Cache TTL in seconds
    private readonly CACHE_TTL = {
        USER: 300, // 5 minutes
        USER_LIST: 180, // 3 minutes
        AVATAR_VARIANTS: 600, // 10 minutes
    };

    constructor(
        @InjectRepository(User)
        private readonly userRepository: Repository<User>,
        @InjectRepository(MediaFile)
        private readonly mediaRepository: Repository<MediaFile>,
        private readonly eventEmitter: EventEmitter2,
        @Inject(CACHE_MANAGER)
        private readonly cacheManager: Cache,
    ) {}

    private async retryOperation<T>(
        operation: () => Promise<T>,
        maxRetries = 3,
        delay = 1000,
    ): Promise<T> {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return await operation();
            } catch (error) {
                const isConnectionError =
                    error instanceof Error &&
                    (error.message.includes('ECONNRESET') ||
                        error.message.includes('Connection lost') ||
                        error.message.includes('connect ETIMEDOUT'));

                if (isConnectionError && attempt < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                    continue;
                }
                throw error;
            }
        }
        throw new Error('Max retries exceeded');
    }

    /**
     * Cache helper methods
     */
    private async invalidateUserCache(
        userId: string,
        email?: string,
    ): Promise<void> {
        const keysToDelete = [this.CACHE_KEYS.USER_BY_ID(userId)];

        if (email) {
            keysToDelete.push(this.CACHE_KEYS.USER_BY_EMAIL(email));
        }

        await Promise.all(keysToDelete.map(key => this.cacheManager.del(key)));
    }

    private async invalidateUserListCaches(): Promise<void> {
        // Note: This is a simplified approach. In production, you might want to
        // maintain a list of active org/branch cache keys or use cache tags
        // For now, we'll just clear specific pattern-based keys
        // await this.cacheManager.reset(); // This method might not exist in all cache implementations
    }

    async create(
        createUserDto: CreateUserDto,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            const { avatar, ...userData } = createUserDto;
            const userToCreate: Partial<User> = { ...userData };

            // Convert avatar ID to MediaFile reference if provided
            if (avatar) {
                userToCreate.avatar = { id: avatar } as MediaFile;
            }

            const user = this.userRepository.create(userToCreate);
            const savedUser = await this.userRepository.save(user);

            // Invalidate list caches since a new user was created
            await this.invalidateUserListCaches();

            // Emit user created event
            this.eventEmitter.emit(
                'user.created',
                new UserCreatedEvent(
                    savedUser.id,
                    savedUser.email,
                    savedUser.firstName,
                    savedUser.lastName,
                    savedUser.orgId?.id,
                    savedUser.orgId?.name,
                    savedUser.branchId?.id,
                    savedUser.branchId?.name,
                    savedUser.avatar?.id?.toString(),
                ),
            );

            return {
                message: 'User created successfully',
                status: 'success',
                code: 200,
            };
        });
    }

    /**
     * Load avatar variants for a user
     */
    private async loadAvatarVariants(user: User): Promise<User> {
        if (user.avatar?.id) {
            try {
                // Check cache first for avatar variants
                const cacheKey = this.CACHE_KEYS.USER_AVATAR_VARIANTS(
                    user.avatar.id,
                );
                const cachedVariants =
                    await this.cacheManager.get<any[]>(cacheKey);

                if (cachedVariants) {
                    user.avatar.variants = cachedVariants;
                } else {
                    // Fetch from database if not cached
                    const variants = await this.mediaRepository.find({
                        where: {
                            originalFileId: user.avatar.id,
                            isActive: true,
                        },
                        order: { variant: 'ASC' },
                    });

                    if (variants.length > 0) {
                        user.avatar.variants = variants;
                        // Cache the variants
                        await this.cacheManager.set(
                            cacheKey,
                            variants,
                            this.CACHE_TTL.AVATAR_VARIANTS * 1000,
                        );
                    }
                }
            } catch (error) {
                console.warn('Failed to load avatar variants:', error);
            }
        }
        return user;
    }

    async findAll(): Promise<User[]> {
        return this.retryOperation(async () => {
            const users = await this.userRepository.find({
                where: { status: UserStatus.ACTIVE },
                relations: ['orgId', 'branchId', 'avatar'],
            });

            // Load avatar variants for all users
            return Promise.all(
                users.map(user => this.loadAvatarVariants(user)),
            );
        });
    }

    async findOne(id: string): Promise<User | null> {
        return this.retryOperation(async () => {
            const user = await this.userRepository.findOne({
                where: { id, status: UserStatus.ACTIVE },
                relations: ['orgId', 'branchId', 'avatar'],
            });

            if (user) {
                return this.loadAvatarVariants(user);
            }
            return user;
        });
    }

    async findByEmail(email: string): Promise<User | null> {
        return this.retryOperation(async () => {
            // Check cache first
            const cacheKey = this.CACHE_KEYS.USER_BY_EMAIL(email);
            const cachedUser = await this.cacheManager.get<User>(cacheKey);

            if (cachedUser) {
                return cachedUser;
            }

            // If not in cache, fetch from database
            const user = await this.userRepository.findOne({
                where: { email, status: UserStatus.ACTIVE },
                relations: ['orgId', 'branchId', 'avatar'],
            });

            if (user) {
                const userWithVariants = await this.loadAvatarVariants(user);
                // Cache the result
                await this.cacheManager.set(
                    cacheKey,
                    userWithVariants,
                    this.CACHE_TTL.USER * 1000,
                );
                return userWithVariants;
            }
            return user;
        });
    }

    async findByEmailWithFullDetails(email: string): Promise<User | null> {
        return this.retryOperation(async () => {
            const user = await this.userRepository.findOne({
                where: { email },
                relations: ['orgId', 'branchId', 'avatar'],
            });

            if (user) {
                return this.loadAvatarVariants(user);
            }
            return user;
        });
    }

    async findById(id: string): Promise<User | null> {
        return this.retryOperation(async () => {
            // Check cache first
            const cacheKey = this.CACHE_KEYS.USER_BY_ID(id);
            const cachedUser = await this.cacheManager.get<User>(cacheKey);

            if (cachedUser) {
                return cachedUser;
            }

            // If not in cache, fetch from database
            const user = await this.userRepository.findOne({
                where: { id },
                relations: ['orgId', 'branchId', 'avatar'],
            });

            if (user) {
                const userWithVariants = await this.loadAvatarVariants(user);
                // Cache the result
                await this.cacheManager.set(
                    cacheKey,
                    userWithVariants,
                    this.CACHE_TTL.USER * 1000, // Convert to milliseconds
                );
                return userWithVariants;
            }
            return user;
        });
    }

    async findByOrganization(orgId: string): Promise<User[]> {
        return this.retryOperation(async () => {
            // Check cache first
            const cacheKey = this.CACHE_KEYS.USER_ORG(orgId);
            const cachedUsers = await this.cacheManager.get<User[]>(cacheKey);

            if (cachedUsers) {
                return cachedUsers;
            }

            // If not in cache, fetch from database
            const users = await this.userRepository.find({
                where: {
                    orgId: { id: orgId },
                    status: UserStatus.ACTIVE,
                },
                relations: ['orgId', 'branchId', 'avatar'],
            });

            // Load avatar variants for all users
            const usersWithVariants = await Promise.all(
                users.map(user => this.loadAvatarVariants(user)),
            );

            // Cache the result
            await this.cacheManager.set(
                cacheKey,
                usersWithVariants,
                this.CACHE_TTL.USER_LIST * 1000,
            );

            return usersWithVariants;
        });
    }

    async findByBranch(branchId: string): Promise<User[]> {
        return this.retryOperation(async () => {
            // Check cache first
            const cacheKey = this.CACHE_KEYS.USER_BRANCH(branchId);
            const cachedUsers = await this.cacheManager.get<User[]>(cacheKey);

            if (cachedUsers) {
                return cachedUsers;
            }

            // If not in cache, fetch from database
            const users = await this.userRepository.find({
                where: {
                    branchId: { id: branchId },
                    status: UserStatus.ACTIVE,
                },
                relations: ['orgId', 'branchId', 'avatar'],
            });

            // Load avatar variants for all users
            const usersWithVariants = await Promise.all(
                users.map(user => this.loadAvatarVariants(user)),
            );

            // Cache the result
            await this.cacheManager.set(
                cacheKey,
                usersWithVariants,
                this.CACHE_TTL.USER_LIST * 1000,
            );

            return usersWithVariants;
        });
    }

    async update(
        id: string,
        updateUserDto: UpdateUserDto,
    ): Promise<StandardOperationResponse> {
        const { avatar, ...updateData } = updateUserDto;
        const dataToUpdate: Partial<User> = { ...updateData };

        // Get user first to know email for cache invalidation
        const existingUser = await this.findOne(id);
        if (!existingUser) {
            throw new NotFoundException(`User with ID ${id} not found`);
        }

        // Convert avatar ID to MediaFile reference if provided
        if (avatar !== undefined) {
            dataToUpdate.avatar = avatar
                ? ({ id: avatar } as MediaFile)
                : undefined;
        }

        await this.userRepository.update(id, dataToUpdate);

        // Invalidate user cache
        await this.invalidateUserCache(id, existingUser.email);
        await this.invalidateUserListCaches();

        return {
            message: 'User updated successfully',
            status: 'success',
            code: 200,
        };
    }

    async remove(id: string): Promise<StandardOperationResponse> {
        const result = await this.userRepository.delete(id);
        if (result.affected === 0) {
            throw new NotFoundException(`User with ID ${id} not found`);
        }

        return {
            message: 'User deleted successfully',
            status: 'success',
            code: 200,
        };
    }

    async updateProfile(
        id: string,
        updateData: Partial<UpdateUserDto>,
    ): Promise<StandardOperationResponse> {
        try {
            const { avatar, ...profileData } = updateData;
            const dataToUpdate: Partial<User> = { ...profileData };

            // Get user first for cache invalidation and event data
            const user = await this.findById(id);
            if (!user) {
                throw new NotFoundException(`User with ID ${id} not found`);
            }

            // Convert avatar ID to MediaFile reference if provided
            if (avatar !== undefined) {
                dataToUpdate.avatar = avatar
                    ? ({ id: avatar } as MediaFile)
                    : undefined;
            }

            await this.userRepository.update(id, dataToUpdate);

            // Invalidate user cache
            await this.invalidateUserCache(id, user.email);

            // Emit user profile updated event
            const updatedFields = Object.keys(updateData);
            this.eventEmitter.emit(
                'user.profile.updated',
                new UserProfileUpdatedEvent(
                    user.id,
                    user.email,
                    user.firstName,
                    user.lastName,
                    user.orgId?.id,
                    user.orgId?.name,
                    user.branchId?.id,
                    user.branchId?.name,
                    user.avatar?.id?.toString(),
                    updatedFields,
                ),
            );

            return {
                message: 'Profile updated successfully',
                status: 'success',
                code: 200,
            };
        } catch (error) {
            if (error instanceof NotFoundException) {
                return {
                    message: error.message,
                    status: 'error',
                    code: 404,
                };
            }
            throw error;
        }
    }

    async changePassword(
        id: string,
        currentPassword: string,
        newPassword: string,
    ): Promise<StandardOperationResponse> {
        const user = await this.findById(id);
        if (!user) {
            return {
                message: `User with ID ${id} not found`,
                status: 'error',
                code: 404,
            };
        }

        // Verify current password
        const isCurrentPasswordValid = await bcrypt.compare(
            currentPassword,
            user.password,
        );
        if (!isCurrentPasswordValid) {
            return {
                message: 'Current password is incorrect',
                status: 'error',
                code: 400,
            };
        }

        // Hash new password
        const saltRounds = 12;
        const hashedNewPassword = await bcrypt.hash(newPassword, saltRounds);

        // Update password
        await this.userRepository.update(id, {
            password: hashedNewPassword,
        });

        // Emit password changed event
        this.eventEmitter.emit(
            'user.password.changed',
            new UserPasswordChangedEvent(
                user.id,
                user.email,
                user.firstName,
                user.lastName,
                user.orgId?.id,
                user.orgId?.name,
                user.branchId?.id,
                user.branchId?.name,
            ),
        );

        return {
            message: 'Password changed successfully',
            status: 'success',
            code: 200,
        };
    }

    /**
     * Assign organization and branch to a user
     */
    async assignOrgAndBranch(
        userId: string,
        orgId?: string,
        branchId?: string,
        assignedBy?: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            const updateData: Record<string, any> = {};

            if (orgId) {
                updateData['orgId'] = { id: orgId };
            }

            if (branchId) {
                updateData['branchId'] = { id: branchId };
            }

            await this.userRepository.update(userId, updateData);

            const user = await this.findOne(userId);
            if (!user) {
                throw new NotFoundException(`User with ID ${userId} not found`);
            }

            // Emit user organization/branch assignment event
            this.eventEmitter.emit(
                'user.org.branch.assigned',
                new UserOrgBranchAssignedEvent(
                    user.id,
                    user.email,
                    user.firstName,
                    user.lastName,
                    user.orgId?.id,
                    user.orgId?.name,
                    user.branchId?.id,
                    user.branchId?.name,
                    user.avatar?.id?.toString(),
                    assignedBy,
                ),
            );

            return {
                message: 'Organization and branch assigned successfully',
                status: 'success',
                code: 200,
            };
        });
    }

    /**
     * Update user password directly (for password reset)
     */
    async updatePassword(
        userId: string,
        hashedPassword: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            const result = await this.userRepository.update(userId, {
                password: hashedPassword,
            });

            if (result.affected === 0) {
                throw new NotFoundException(`User with ID ${userId} not found`);
            }

            return {
                message: 'Password updated successfully',
                status: 'success',
                code: 200,
            };
        });
    }

    /**
     * Mark user email as verified
     */
    async verifyEmail(userId: string): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            const result = await this.userRepository.update(userId, {
                emailVerified: true,
            });

            if (result.affected === 0) {
                throw new NotFoundException(`User with ID ${userId} not found`);
            }

            return {
                message: 'Email verified successfully',
                status: 'success',
                code: 200,
            };
        });
    }

    /**
     * Soft delete a user by setting status to DELETED
     */
    async softDelete(
        userId: string,
        deactivatedBy?: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            // First check if user exists and is not already deleted
            const user = await this.userRepository.findOne({
                where: { id: userId },
                relations: ['orgId', 'branchId', 'avatar'],
            });

            if (!user) {
                throw new NotFoundException(`User with ID ${userId} not found`);
            }

            if (user.status === UserStatus.DELETED) {
                throw new BadRequestException('User is already deleted');
            }

            // Update status to DELETED
            await this.userRepository.update(userId, {
                status: UserStatus.DELETED,
            });

            // Emit user deactivated event
            this.eventEmitter.emit(
                'user.deactivated',
                new UserDeactivatedEvent(
                    user.id,
                    user.email,
                    user.firstName,
                    user.lastName,
                    user.orgId?.id,
                    user.orgId?.name,
                    user.branchId?.id,
                    user.branchId?.name,
                    deactivatedBy,
                    'Account deactivated by user',
                ),
            );

            return {
                message: 'User deleted successfully',
                status: 'success',
                code: 200,
            };
        });
    }

    /**
     * Restore a soft-deleted user by setting status to ACTIVE
     */
    async restoreUser(
        userId: string,
        restoredBy?: string,
    ): Promise<StandardOperationResponse> {
        return this.retryOperation(async () => {
            // First check if user exists and is deleted
            const user = await this.userRepository.findOne({
                where: { id: userId },
                relations: ['orgId', 'branchId', 'avatar'],
            });

            if (!user) {
                throw new NotFoundException(`User with ID ${userId} not found`);
            }

            if (user.status !== UserStatus.DELETED) {
                throw new BadRequestException(
                    'User is not deleted and cannot be restored',
                );
            }

            // Update status to ACTIVE
            await this.userRepository.update(userId, {
                status: UserStatus.ACTIVE,
            });

            // Emit user restored event
            this.eventEmitter.emit(
                'user.restored',
                new UserRestoredEvent(
                    user.id,
                    user.email,
                    user.firstName,
                    user.lastName,
                    user.orgId?.id,
                    user.orgId?.name,
                    user.branchId?.id,
                    user.branchId?.name,
                    restoredBy,
                ),
            );

            return {
                message: 'User restored successfully',
                status: 'success',
                code: 200,
            };
        });
    }

    /**
     * Find all soft-deleted users (for admin purposes)
     */
    async findDeleted(): Promise<User[]> {
        return this.retryOperation(async () => {
            const users = await this.userRepository.find({
                where: { status: UserStatus.DELETED },
                relations: ['orgId', 'branchId', 'avatar'],
            });

            // Load avatar variants for all users
            return Promise.all(
                users.map(user => this.loadAvatarVariants(user)),
            );
        });
    }

    /**
     * Find all users with any status (for admin purposes)
     */
    async findAllWithDeleted(): Promise<User[]> {
        return this.retryOperation(async () => {
            const users = await this.userRepository.find({
                relations: ['orgId', 'branchId', 'avatar'],
            });

            // Load avatar variants for all users
            return Promise.all(
                users.map(user => this.loadAvatarVariants(user)),
            );
        });
    }

    /**
     * Find user by ID including deleted users (for admin purposes)
     */
    async findByIdWithDeleted(id: string): Promise<User | null> {
        return this.retryOperation(async () => {
            const user = await this.userRepository.findOne({
                where: { id },
                relations: ['orgId', 'branchId', 'avatar'],
            });

            if (user) {
                return this.loadAvatarVariants(user);
            }
            return user;
        });
    }
}

// ==========================================
// COMPREHENSIVE SUMMARY
// ==========================================
/*
 * EXTRACTION STATISTICS:
 * =====================
 * Total Enums: 14
 * Total Interfaces: 40
 * Total Type Aliases: 0
 * Total Classes: 318
 * Total Decorators: 0
 * Total Constants: 0
 * Total Functions: 0
 * 
 * FILES PROCESSED: 188
 * TOTAL LINES: 45,853
 * EXTERNAL DEPENDENCIES: 306
 * ERRORS: 0
 * WARNINGS: 0
 * 
 * COMPLEXITY ANALYSIS:
 * ===================
 * Total Complexity Score: 13294
 * Average Complexity per File: 70.71
 * 
 * Generated by SuperDetailedTypeExtractor
 * Timestamp: 2025-06-01T14:33:34.374Z
 */
